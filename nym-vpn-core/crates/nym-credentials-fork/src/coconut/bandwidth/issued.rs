// Copyright 2024 - Nym Technologies SA <contact@nymtech.net>
// SPDX-License-Identifier: Apache-2.0

use crate::coconut::bandwidth::freepass::FreePassIssuedData;
use crate::coconut::bandwidth::voucher::BandwidthVoucherIssuedData;
use crate::coconut::bandwidth::CredentialType;
use crate::coconut::utils::scalar_serde_helper;
use crate::error::Error;
use nym_credentials_interface_fork::{PrivateAttribute, PublicAttribute, Signature};
use nym_validator_client::nym_api::EpochId;
use serde::{Deserialize, Serialize};
use zeroize::{Zeroize, ZeroizeOnDrop};

pub const CURRENT_SERIALIZATION_REVISION: u8 = 1;

#[derive(Debug, Zeroize, Serialize, Deserialize)]
pub enum BandwidthCredentialIssuedDataVariant {
    Voucher(BandwidthVoucherIssuedData),
    FreePass(FreePassIssuedData),
}

impl BandwidthCredentialIssuedDataVariant {
    pub(crate) fn info(&self) -> CredentialType {
        match self {
            BandwidthCredentialIssuedDataVariant::Voucher(..) => CredentialType::Voucher,
            BandwidthCredentialIssuedDataVariant::FreePass(..) => CredentialType::FreePass,
        }
    }
}

// the only important thing to zeroize here are the private attributes, the rest can be made fully public for what we're concerned
#[derive(Zeroize, ZeroizeOnDrop, Serialize, Deserialize)]
pub struct IssuedBandwidthCredential {
    // private attributes
    /// a random secret value generated by the client used for double-spending detection
    #[serde(with = "scalar_serde_helper")]
    serial_number: PrivateAttribute,

    /// a random secret value generated by the client used to bind multiple credentials together
    #[serde(with = "scalar_serde_helper")]
    binding_number: PrivateAttribute,

    /// the underlying aggregated signature on the attributes
    #[zeroize(skip)]
    signature: Signature,

    /// data specific to given bandwidth credential, for example a value for bandwidth voucher and expiry date for the free pass
    variant_data: BandwidthCredentialIssuedDataVariant,

    /// type of the bandwdith credential hashed onto a scalar
    #[serde(with = "scalar_serde_helper")]
    type_prehashed: PublicAttribute,

    /// Specifies the (DKG) epoch id when this credential has been issued
    epoch_id: EpochId,
}

impl IssuedBandwidthCredential {
    pub fn try_unpack(bytes: &[u8], revision: impl Into<Option<u8>>) -> Result<Self, Error> {
        let revision = revision.into().unwrap_or(CURRENT_SERIALIZATION_REVISION);

        match revision {
            1 => Self::unpack_v1(bytes),
            _ => Err(Error::UnknownSerializationRevision { revision }),
        }
    }

    pub fn epoch_id(&self) -> EpochId {
        self.epoch_id
    }

    pub fn variant_data(&self) -> &BandwidthCredentialIssuedDataVariant {
        &self.variant_data
    }

    pub fn current_serialization_revision(&self) -> u8 {
        CURRENT_SERIALIZATION_REVISION
    }

    /// Unpack (deserialize) the credential data from the given bytes using v1 serializer.
    pub fn unpack_v1(bytes: &[u8]) -> Result<Self, Error> {
        use bincode::Options;
        make_storable_bincode_serializer()
            .deserialize(bytes)
            .map_err(|source| Error::SerializationFailure {
                source,
                revision: 1,
            })
    }

    pub fn typ(&self) -> CredentialType {
        self.variant_data.info()
    }
}

fn make_storable_bincode_serializer() -> impl bincode::Options {
    use bincode::Options;
    bincode::DefaultOptions::new()
        .with_big_endian()
        .with_varint_encoding()
}
