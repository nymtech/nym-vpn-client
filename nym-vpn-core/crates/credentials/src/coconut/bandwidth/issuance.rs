// Copyright 2024 - Nym Technologies SA <contact@nymtech.net>
// SPDX-License-Identifier: Apache-2.0

use crate::coconut::bandwidth::freepass::FreePassIssuanceData;
use crate::coconut::bandwidth::voucher::BandwidthVoucherIssuanceData;
use crate::coconut::bandwidth::{
    CredentialType,
};
use crate::coconut::utils::scalar_serde_helper;
use nym_credentials_interface::{
    Attribute, 
    Parameters,
    PrivateAttribute, PublicAttribute,
};
use serde::{Deserialize, Serialize};
use zeroize::{Zeroize, ZeroizeOnDrop};

#[derive(Zeroize, ZeroizeOnDrop, Serialize, Deserialize)]
pub(crate) enum BandwidthCredentialIssuanceDataVariant {
    Voucher(BandwidthVoucherIssuanceData),
    FreePass(FreePassIssuanceData),
}

impl From<FreePassIssuanceData> for BandwidthCredentialIssuanceDataVariant {
    fn from(value: FreePassIssuanceData) -> Self {
        BandwidthCredentialIssuanceDataVariant::FreePass(value)
    }
}

impl From<BandwidthVoucherIssuanceData> for BandwidthCredentialIssuanceDataVariant {
    fn from(value: BandwidthVoucherIssuanceData) -> Self {
        BandwidthCredentialIssuanceDataVariant::Voucher(value)
    }
}

impl BandwidthCredentialIssuanceDataVariant {
    pub(crate) fn info(&self) -> CredentialType {
        match self {
            BandwidthCredentialIssuanceDataVariant::Voucher(..) => CredentialType::Voucher,
            BandwidthCredentialIssuanceDataVariant::FreePass(..) => CredentialType::FreePass,
        }
    }

    // currently this works under the assumption of there being a single unique public attribute for given variant
    pub(crate) fn public_value(&self) -> &Attribute {
        match self {
            BandwidthCredentialIssuanceDataVariant::Voucher(voucher) => voucher.value_attribute(),
            BandwidthCredentialIssuanceDataVariant::FreePass(freepass) => {
                freepass.expiry_date_attribute()
            }
        }
    }

    // currently this works under the assumption of there being a single unique public attribute for given variant
    pub(crate) fn public_value_plain(&self) -> String {
        match self {
            BandwidthCredentialIssuanceDataVariant::Voucher(voucher) => voucher.value_plain(),
            BandwidthCredentialIssuanceDataVariant::FreePass(freepass) => {
                freepass.expiry_date_plain()
            }
        }
    }

    pub(crate) fn voucher_data(&self) -> Option<&BandwidthVoucherIssuanceData> {
        match self {
            BandwidthCredentialIssuanceDataVariant::Voucher(voucher) => Some(voucher),
            _ => None,
        }
    }
}

// all types of bandwidth credentials contain serial number and binding number
#[derive(Zeroize, ZeroizeOnDrop, Serialize, Deserialize)]
pub(crate) struct IssuanceBandwidthCredential {
    // private attributes
    /// a random secret value generated by the client used for double-spending detection
    #[serde(with = "scalar_serde_helper")]
    serial_number: PrivateAttribute,

    /// a random secret value generated by the client used to bind multiple credentials together
    #[serde(with = "scalar_serde_helper")]
    binding_number: PrivateAttribute,

    /// data specific to given bandwidth credential, for example a value for bandwidth voucher and expiry date for the free pass
    variant_data: BandwidthCredentialIssuanceDataVariant,

    /// type of the bandwdith credential hashed onto a scalar
    #[serde(with = "scalar_serde_helper")]
    type_prehashed: PublicAttribute,
}

impl IssuanceBandwidthCredential {
    pub(crate) const PUBLIC_ATTRIBUTES: u32 = 2;
    pub(crate) const PRIVATE_ATTRIBUTES: u32 = 2;
    pub(crate) const ENCODED_ATTRIBUTES: u32 = Self::PUBLIC_ATTRIBUTES + Self::PRIVATE_ATTRIBUTES;

    pub(crate) fn default_parameters() -> Parameters {
        // safety: the unwrap is fine here as Self::ENCODED_ATTRIBUTES is non-zero
        Parameters::new(Self::ENCODED_ATTRIBUTES).unwrap()
    }
}
