// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(nym_vpn_libFFI)
import nym_vpn_libFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_nym_vpn_lib_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_nym_vpn_lib_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: nil)
}

private func rustCallWithError<T>(
    _ errorHandler: @escaping (RustBuffer) throws -> Error,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}




/**
 * Types observing network changes.
 */
public protocol OsDefaultPathObserver : AnyObject {
    
    func onDefaultPathChange(newPath: OsDefaultPath) 
    
}

/**
 * Types observing network changes.
 */
open class OsDefaultPathObserverImpl:
    OsDefaultPathObserver {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nym_vpn_lib_fn_clone_osdefaultpathobserver(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nym_vpn_lib_fn_free_osdefaultpathobserver(pointer, $0) }
    }

    

    
open func onDefaultPathChange(newPath: OsDefaultPath) {try! rustCall() {
    uniffi_nym_vpn_lib_fn_method_osdefaultpathobserver_on_default_path_change(self.uniffiClonePointer(),
        FfiConverterTypeOSDefaultPath.lower(newPath),$0
    )
}
}
    

}
// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceOSDefaultPathObserver {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceOsDefaultPathObserver = UniffiVTableCallbackInterfaceOsDefaultPathObserver(
        onDefaultPathChange: { (
            uniffiHandle: UInt64,
            newPath: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeOSDefaultPathObserver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onDefaultPathChange(
                     newPath: try FfiConverterTypeOSDefaultPath.lift(newPath)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeOSDefaultPathObserver.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface OSDefaultPathObserver: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitOSDefaultPathObserver() {
    uniffi_nym_vpn_lib_fn_init_callback_vtable_osdefaultpathobserver(&UniffiCallbackInterfaceOSDefaultPathObserver.vtable)
}

public struct FfiConverterTypeOSDefaultPathObserver: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<OsDefaultPathObserver>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = OsDefaultPathObserver

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> OsDefaultPathObserver {
        return OsDefaultPathObserverImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: OsDefaultPathObserver) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OsDefaultPathObserver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: OsDefaultPathObserver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeOSDefaultPathObserver_lift(_ pointer: UnsafeMutableRawPointer) throws -> OsDefaultPathObserver {
    return try FfiConverterTypeOSDefaultPathObserver.lift(pointer)
}

public func FfiConverterTypeOSDefaultPathObserver_lower(_ value: OsDefaultPathObserver) -> UnsafeMutableRawPointer {
    return FfiConverterTypeOSDefaultPathObserver.lower(value)
}




public protocol OsTunProvider : AnyObject {
    
    /**
     * Set network settings including tun, dns, ip.
     */
    func setTunnelNetworkSettings(tunnelSettings: TunnelNetworkSettings) async throws 
    
    /**
     * Set or unset the default path observer.
     */
    func setDefaultPathObserver(observer: OsDefaultPathObserver?) async throws 
    
}

open class OsTunProviderImpl:
    OsTunProvider {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nym_vpn_lib_fn_clone_ostunprovider(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nym_vpn_lib_fn_free_ostunprovider(pointer, $0) }
    }

    

    
    /**
     * Set network settings including tun, dns, ip.
     */
open func setTunnelNetworkSettings(tunnelSettings: TunnelNetworkSettings)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nym_vpn_lib_fn_method_ostunprovider_set_tunnel_network_settings(
                    self.uniffiClonePointer(),
                    FfiConverterTypeTunnelNetworkSettings.lower(tunnelSettings)
                )
            },
            pollFunc: ffi_nym_vpn_lib_rust_future_poll_void,
            completeFunc: ffi_nym_vpn_lib_rust_future_complete_void,
            freeFunc: ffi_nym_vpn_lib_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeVpnError.lift
        )
}
    
    /**
     * Set or unset the default path observer.
     */
open func setDefaultPathObserver(observer: OsDefaultPathObserver?)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nym_vpn_lib_fn_method_ostunprovider_set_default_path_observer(
                    self.uniffiClonePointer(),
                    FfiConverterOptionTypeOSDefaultPathObserver.lower(observer)
                )
            },
            pollFunc: ffi_nym_vpn_lib_rust_future_poll_void,
            completeFunc: ffi_nym_vpn_lib_rust_future_complete_void,
            freeFunc: ffi_nym_vpn_lib_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeVpnError.lift
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceOSTunProvider {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceOsTunProvider = UniffiVTableCallbackInterfaceOsTunProvider(
        setTunnelNetworkSettings: { (
            uniffiHandle: UInt64,
            tunnelSettings: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeOSTunProvider.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.setTunnelNetworkSettings(
                     tunnelSettings: try FfiConverterTypeTunnelNetworkSettings.lift(tunnelSettings)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeVpnError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        setDefaultPathObserver: { (
            uniffiHandle: UInt64,
            observer: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeOSTunProvider.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.setDefaultPathObserver(
                     observer: try FfiConverterOptionTypeOSDefaultPathObserver.lift(observer)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeVpnError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeOSTunProvider.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface OSTunProvider: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitOSTunProvider() {
    uniffi_nym_vpn_lib_fn_init_callback_vtable_ostunprovider(&UniffiCallbackInterfaceOSTunProvider.vtable)
}

public struct FfiConverterTypeOSTunProvider: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<OsTunProvider>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = OsTunProvider

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> OsTunProvider {
        return OsTunProviderImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: OsTunProvider) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OsTunProvider {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: OsTunProvider, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeOSTunProvider_lift(_ pointer: UnsafeMutableRawPointer) throws -> OsTunProvider {
    return try FfiConverterTypeOSTunProvider.lift(pointer)
}

public func FfiConverterTypeOSTunProvider_lower(_ value: OsTunProvider) -> UnsafeMutableRawPointer {
    return FfiConverterTypeOSTunProvider.lower(value)
}




public protocol TunnelStatusListener : AnyObject {
    
    func onEvent(event: TunnelEvent) 
    
}

open class TunnelStatusListenerImpl:
    TunnelStatusListener {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nym_vpn_lib_fn_clone_tunnelstatuslistener(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nym_vpn_lib_fn_free_tunnelstatuslistener(pointer, $0) }
    }

    

    
open func onEvent(event: TunnelEvent) {try! rustCall() {
    uniffi_nym_vpn_lib_fn_method_tunnelstatuslistener_on_event(self.uniffiClonePointer(),
        FfiConverterTypeTunnelEvent.lower(event),$0
    )
}
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceTunnelStatusListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceTunnelStatusListener = UniffiVTableCallbackInterfaceTunnelStatusListener(
        onEvent: { (
            uniffiHandle: UInt64,
            event: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeTunnelStatusListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onEvent(
                     event: try FfiConverterTypeTunnelEvent.lift(event)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeTunnelStatusListener.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface TunnelStatusListener: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitTunnelStatusListener() {
    uniffi_nym_vpn_lib_fn_init_callback_vtable_tunnelstatuslistener(&UniffiCallbackInterfaceTunnelStatusListener.vtable)
}

public struct FfiConverterTypeTunnelStatusListener: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<TunnelStatusListener>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TunnelStatusListener

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TunnelStatusListener {
        return TunnelStatusListenerImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TunnelStatusListener) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TunnelStatusListener {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TunnelStatusListener, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeTunnelStatusListener_lift(_ pointer: UnsafeMutableRawPointer) throws -> TunnelStatusListener {
    return try FfiConverterTypeTunnelStatusListener.lift(pointer)
}

public func FfiConverterTypeTunnelStatusListener_lower(_ value: TunnelStatusListener) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTunnelStatusListener.lower(value)
}


public struct AccountLinks {
    public var signUp: String
    public var signIn: String
    public var account: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(signUp: String, signIn: String, account: String?) {
        self.signUp = signUp
        self.signIn = signIn
        self.account = account
    }
}



extension AccountLinks: Equatable, Hashable {
    public static func ==(lhs: AccountLinks, rhs: AccountLinks) -> Bool {
        if lhs.signUp != rhs.signUp {
            return false
        }
        if lhs.signIn != rhs.signIn {
            return false
        }
        if lhs.account != rhs.account {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(signUp)
        hasher.combine(signIn)
        hasher.combine(account)
    }
}


public struct FfiConverterTypeAccountLinks: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountLinks {
        return
            try AccountLinks(
                signUp: FfiConverterString.read(from: &buf), 
                signIn: FfiConverterString.read(from: &buf), 
                account: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: AccountLinks, into buf: inout [UInt8]) {
        FfiConverterString.write(value.signUp, into: &buf)
        FfiConverterString.write(value.signIn, into: &buf)
        FfiConverterOptionString.write(value.account, into: &buf)
    }
}


public func FfiConverterTypeAccountLinks_lift(_ buf: RustBuffer) throws -> AccountLinks {
    return try FfiConverterTypeAccountLinks.lift(buf)
}

public func FfiConverterTypeAccountLinks_lower(_ value: AccountLinks) -> RustBuffer {
    return FfiConverterTypeAccountLinks.lower(value)
}


public struct AccountStateSummary {
    public var mnemonic: MnemonicState?
    public var accountRegistered: AccountRegistered?
    public var accountSummary: AccountSummary?
    public var device: DeviceState?
    public var deviceRegistration: DeviceRegistration?
    public var pendingZkNym: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(mnemonic: MnemonicState?, accountRegistered: AccountRegistered?, accountSummary: AccountSummary?, device: DeviceState?, deviceRegistration: DeviceRegistration?, pendingZkNym: Bool) {
        self.mnemonic = mnemonic
        self.accountRegistered = accountRegistered
        self.accountSummary = accountSummary
        self.device = device
        self.deviceRegistration = deviceRegistration
        self.pendingZkNym = pendingZkNym
    }
}



extension AccountStateSummary: Equatable, Hashable {
    public static func ==(lhs: AccountStateSummary, rhs: AccountStateSummary) -> Bool {
        if lhs.mnemonic != rhs.mnemonic {
            return false
        }
        if lhs.accountRegistered != rhs.accountRegistered {
            return false
        }
        if lhs.accountSummary != rhs.accountSummary {
            return false
        }
        if lhs.device != rhs.device {
            return false
        }
        if lhs.deviceRegistration != rhs.deviceRegistration {
            return false
        }
        if lhs.pendingZkNym != rhs.pendingZkNym {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(mnemonic)
        hasher.combine(accountRegistered)
        hasher.combine(accountSummary)
        hasher.combine(device)
        hasher.combine(deviceRegistration)
        hasher.combine(pendingZkNym)
    }
}


public struct FfiConverterTypeAccountStateSummary: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountStateSummary {
        return
            try AccountStateSummary(
                mnemonic: FfiConverterOptionTypeMnemonicState.read(from: &buf), 
                accountRegistered: FfiConverterOptionTypeAccountRegistered.read(from: &buf), 
                accountSummary: FfiConverterOptionTypeAccountSummary.read(from: &buf), 
                device: FfiConverterOptionTypeDeviceState.read(from: &buf), 
                deviceRegistration: FfiConverterOptionTypeDeviceRegistration.read(from: &buf), 
                pendingZkNym: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: AccountStateSummary, into buf: inout [UInt8]) {
        FfiConverterOptionTypeMnemonicState.write(value.mnemonic, into: &buf)
        FfiConverterOptionTypeAccountRegistered.write(value.accountRegistered, into: &buf)
        FfiConverterOptionTypeAccountSummary.write(value.accountSummary, into: &buf)
        FfiConverterOptionTypeDeviceState.write(value.device, into: &buf)
        FfiConverterOptionTypeDeviceRegistration.write(value.deviceRegistration, into: &buf)
        FfiConverterBool.write(value.pendingZkNym, into: &buf)
    }
}


public func FfiConverterTypeAccountStateSummary_lift(_ buf: RustBuffer) throws -> AccountStateSummary {
    return try FfiConverterTypeAccountStateSummary.lift(buf)
}

public func FfiConverterTypeAccountStateSummary_lower(_ value: AccountStateSummary) -> RustBuffer {
    return FfiConverterTypeAccountStateSummary.lower(value)
}


public struct AccountSummary {
    public var account: AccountState
    public var subscription: SubscriptionState
    public var deviceSummary: DeviceSummary
    public var fairUsage: FairUsage

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(account: AccountState, subscription: SubscriptionState, deviceSummary: DeviceSummary, fairUsage: FairUsage) {
        self.account = account
        self.subscription = subscription
        self.deviceSummary = deviceSummary
        self.fairUsage = fairUsage
    }
}



extension AccountSummary: Equatable, Hashable {
    public static func ==(lhs: AccountSummary, rhs: AccountSummary) -> Bool {
        if lhs.account != rhs.account {
            return false
        }
        if lhs.subscription != rhs.subscription {
            return false
        }
        if lhs.deviceSummary != rhs.deviceSummary {
            return false
        }
        if lhs.fairUsage != rhs.fairUsage {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(account)
        hasher.combine(subscription)
        hasher.combine(deviceSummary)
        hasher.combine(fairUsage)
    }
}


public struct FfiConverterTypeAccountSummary: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountSummary {
        return
            try AccountSummary(
                account: FfiConverterTypeAccountState.read(from: &buf), 
                subscription: FfiConverterTypeSubscriptionState.read(from: &buf), 
                deviceSummary: FfiConverterTypeDeviceSummary.read(from: &buf), 
                fairUsage: FfiConverterTypeFairUsage.read(from: &buf)
        )
    }

    public static func write(_ value: AccountSummary, into buf: inout [UInt8]) {
        FfiConverterTypeAccountState.write(value.account, into: &buf)
        FfiConverterTypeSubscriptionState.write(value.subscription, into: &buf)
        FfiConverterTypeDeviceSummary.write(value.deviceSummary, into: &buf)
        FfiConverterTypeFairUsage.write(value.fairUsage, into: &buf)
    }
}


public func FfiConverterTypeAccountSummary_lift(_ buf: RustBuffer) throws -> AccountSummary {
    return try FfiConverterTypeAccountSummary.lift(buf)
}

public func FfiConverterTypeAccountSummary_lower(_ value: AccountSummary) -> RustBuffer {
    return FfiConverterTypeAccountSummary.lower(value)
}


public struct ChainDetails {
    public var bech32AccountPrefix: String
    public var mixDenom: DenomDetails
    public var stakeDenom: DenomDetails

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bech32AccountPrefix: String, mixDenom: DenomDetails, stakeDenom: DenomDetails) {
        self.bech32AccountPrefix = bech32AccountPrefix
        self.mixDenom = mixDenom
        self.stakeDenom = stakeDenom
    }
}



extension ChainDetails: Equatable, Hashable {
    public static func ==(lhs: ChainDetails, rhs: ChainDetails) -> Bool {
        if lhs.bech32AccountPrefix != rhs.bech32AccountPrefix {
            return false
        }
        if lhs.mixDenom != rhs.mixDenom {
            return false
        }
        if lhs.stakeDenom != rhs.stakeDenom {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bech32AccountPrefix)
        hasher.combine(mixDenom)
        hasher.combine(stakeDenom)
    }
}


public struct FfiConverterTypeChainDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChainDetails {
        return
            try ChainDetails(
                bech32AccountPrefix: FfiConverterString.read(from: &buf), 
                mixDenom: FfiConverterTypeDenomDetails.read(from: &buf), 
                stakeDenom: FfiConverterTypeDenomDetails.read(from: &buf)
        )
    }

    public static func write(_ value: ChainDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.bech32AccountPrefix, into: &buf)
        FfiConverterTypeDenomDetails.write(value.mixDenom, into: &buf)
        FfiConverterTypeDenomDetails.write(value.stakeDenom, into: &buf)
    }
}


public func FfiConverterTypeChainDetails_lift(_ buf: RustBuffer) throws -> ChainDetails {
    return try FfiConverterTypeChainDetails.lift(buf)
}

public func FfiConverterTypeChainDetails_lower(_ value: ChainDetails) -> RustBuffer {
    return FfiConverterTypeChainDetails.lower(value)
}


public struct ConnectionData {
    /**
     * Mixnet entry gateway
     */
    public var entryGateway: BoxedNodeIdentity
    /**
     * Mixnet exit gateway
     */
    public var exitGateway: BoxedNodeIdentity
    /**
     * When the tunnel was last established.
     * Set once the tunnel is connected.
     */
    public var connectedAt: OffsetDateTime?
    /**
     * Tunnel connection data.
     */
    public var tunnel: TunnelConnectionData

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Mixnet entry gateway
         */entryGateway: BoxedNodeIdentity, 
        /**
         * Mixnet exit gateway
         */exitGateway: BoxedNodeIdentity, 
        /**
         * When the tunnel was last established.
         * Set once the tunnel is connected.
         */connectedAt: OffsetDateTime?, 
        /**
         * Tunnel connection data.
         */tunnel: TunnelConnectionData) {
        self.entryGateway = entryGateway
        self.exitGateway = exitGateway
        self.connectedAt = connectedAt
        self.tunnel = tunnel
    }
}



extension ConnectionData: Equatable, Hashable {
    public static func ==(lhs: ConnectionData, rhs: ConnectionData) -> Bool {
        if lhs.entryGateway != rhs.entryGateway {
            return false
        }
        if lhs.exitGateway != rhs.exitGateway {
            return false
        }
        if lhs.connectedAt != rhs.connectedAt {
            return false
        }
        if lhs.tunnel != rhs.tunnel {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(entryGateway)
        hasher.combine(exitGateway)
        hasher.combine(connectedAt)
        hasher.combine(tunnel)
    }
}


public struct FfiConverterTypeConnectionData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConnectionData {
        return
            try ConnectionData(
                entryGateway: FfiConverterTypeBoxedNodeIdentity.read(from: &buf), 
                exitGateway: FfiConverterTypeBoxedNodeIdentity.read(from: &buf), 
                connectedAt: FfiConverterOptionTypeOffsetDateTime.read(from: &buf), 
                tunnel: FfiConverterTypeTunnelConnectionData.read(from: &buf)
        )
    }

    public static func write(_ value: ConnectionData, into buf: inout [UInt8]) {
        FfiConverterTypeBoxedNodeIdentity.write(value.entryGateway, into: &buf)
        FfiConverterTypeBoxedNodeIdentity.write(value.exitGateway, into: &buf)
        FfiConverterOptionTypeOffsetDateTime.write(value.connectedAt, into: &buf)
        FfiConverterTypeTunnelConnectionData.write(value.tunnel, into: &buf)
    }
}


public func FfiConverterTypeConnectionData_lift(_ buf: RustBuffer) throws -> ConnectionData {
    return try FfiConverterTypeConnectionData.lift(buf)
}

public func FfiConverterTypeConnectionData_lower(_ value: ConnectionData) -> RustBuffer {
    return FfiConverterTypeConnectionData.lower(value)
}


public struct DenomDetails {
    public var base: String
    public var display: String
    public var displayExponent: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(base: String, display: String, displayExponent: UInt32) {
        self.base = base
        self.display = display
        self.displayExponent = displayExponent
    }
}



extension DenomDetails: Equatable, Hashable {
    public static func ==(lhs: DenomDetails, rhs: DenomDetails) -> Bool {
        if lhs.base != rhs.base {
            return false
        }
        if lhs.display != rhs.display {
            return false
        }
        if lhs.displayExponent != rhs.displayExponent {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(base)
        hasher.combine(display)
        hasher.combine(displayExponent)
    }
}


public struct FfiConverterTypeDenomDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DenomDetails {
        return
            try DenomDetails(
                base: FfiConverterString.read(from: &buf), 
                display: FfiConverterString.read(from: &buf), 
                displayExponent: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: DenomDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.base, into: &buf)
        FfiConverterString.write(value.display, into: &buf)
        FfiConverterUInt32.write(value.displayExponent, into: &buf)
    }
}


public func FfiConverterTypeDenomDetails_lift(_ buf: RustBuffer) throws -> DenomDetails {
    return try FfiConverterTypeDenomDetails.lift(buf)
}

public func FfiConverterTypeDenomDetails_lower(_ value: DenomDetails) -> RustBuffer {
    return FfiConverterTypeDenomDetails.lower(value)
}


public struct DeviceSummary {
    public var active: UInt64
    public var max: UInt64
    public var remaining: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(active: UInt64, max: UInt64, remaining: UInt64) {
        self.active = active
        self.max = max
        self.remaining = remaining
    }
}



extension DeviceSummary: Equatable, Hashable {
    public static func ==(lhs: DeviceSummary, rhs: DeviceSummary) -> Bool {
        if lhs.active != rhs.active {
            return false
        }
        if lhs.max != rhs.max {
            return false
        }
        if lhs.remaining != rhs.remaining {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(active)
        hasher.combine(max)
        hasher.combine(remaining)
    }
}


public struct FfiConverterTypeDeviceSummary: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeviceSummary {
        return
            try DeviceSummary(
                active: FfiConverterUInt64.read(from: &buf), 
                max: FfiConverterUInt64.read(from: &buf), 
                remaining: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: DeviceSummary, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.active, into: &buf)
        FfiConverterUInt64.write(value.max, into: &buf)
        FfiConverterUInt64.write(value.remaining, into: &buf)
    }
}


public func FfiConverterTypeDeviceSummary_lift(_ buf: RustBuffer) throws -> DeviceSummary {
    return try FfiConverterTypeDeviceSummary.lift(buf)
}

public func FfiConverterTypeDeviceSummary_lower(_ value: DeviceSummary) -> RustBuffer {
    return FfiConverterTypeDeviceSummary.lower(value)
}


public struct DnsSettings {
    /**
     * DNS IP addresses.
     */
    public var servers: [IpAddr]
    /**
     * DNS server search domains.
     */
    public var searchDomains: [String]?
    /**
     * Which domains to resolve using these DNS settings.
     */
    public var matchDomains: [String]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * DNS IP addresses.
         */servers: [IpAddr], 
        /**
         * DNS server search domains.
         */searchDomains: [String]?, 
        /**
         * Which domains to resolve using these DNS settings.
         */matchDomains: [String]?) {
        self.servers = servers
        self.searchDomains = searchDomains
        self.matchDomains = matchDomains
    }
}



extension DnsSettings: Equatable, Hashable {
    public static func ==(lhs: DnsSettings, rhs: DnsSettings) -> Bool {
        if lhs.servers != rhs.servers {
            return false
        }
        if lhs.searchDomains != rhs.searchDomains {
            return false
        }
        if lhs.matchDomains != rhs.matchDomains {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(servers)
        hasher.combine(searchDomains)
        hasher.combine(matchDomains)
    }
}


public struct FfiConverterTypeDnsSettings: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DnsSettings {
        return
            try DnsSettings(
                servers: FfiConverterSequenceTypeIpAddr.read(from: &buf), 
                searchDomains: FfiConverterOptionSequenceString.read(from: &buf), 
                matchDomains: FfiConverterOptionSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: DnsSettings, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeIpAddr.write(value.servers, into: &buf)
        FfiConverterOptionSequenceString.write(value.searchDomains, into: &buf)
        FfiConverterOptionSequenceString.write(value.matchDomains, into: &buf)
    }
}


public func FfiConverterTypeDnsSettings_lift(_ buf: RustBuffer) throws -> DnsSettings {
    return try FfiConverterTypeDnsSettings.lift(buf)
}

public func FfiConverterTypeDnsSettings_lower(_ value: DnsSettings) -> RustBuffer {
    return FfiConverterTypeDnsSettings.lower(value)
}


public struct FairUsage {
    public var usedGb: Double?
    public var limitGb: Double?
    public var resetsOnUtc: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(usedGb: Double?, limitGb: Double?, resetsOnUtc: String?) {
        self.usedGb = usedGb
        self.limitGb = limitGb
        self.resetsOnUtc = resetsOnUtc
    }
}



extension FairUsage: Equatable, Hashable {
    public static func ==(lhs: FairUsage, rhs: FairUsage) -> Bool {
        if lhs.usedGb != rhs.usedGb {
            return false
        }
        if lhs.limitGb != rhs.limitGb {
            return false
        }
        if lhs.resetsOnUtc != rhs.resetsOnUtc {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(usedGb)
        hasher.combine(limitGb)
        hasher.combine(resetsOnUtc)
    }
}


public struct FfiConverterTypeFairUsage: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FairUsage {
        return
            try FairUsage(
                usedGb: FfiConverterOptionDouble.read(from: &buf), 
                limitGb: FfiConverterOptionDouble.read(from: &buf), 
                resetsOnUtc: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: FairUsage, into buf: inout [UInt8]) {
        FfiConverterOptionDouble.write(value.usedGb, into: &buf)
        FfiConverterOptionDouble.write(value.limitGb, into: &buf)
        FfiConverterOptionString.write(value.resetsOnUtc, into: &buf)
    }
}


public func FfiConverterTypeFairUsage_lift(_ buf: RustBuffer) throws -> FairUsage {
    return try FfiConverterTypeFairUsage.lift(buf)
}

public func FfiConverterTypeFairUsage_lower(_ value: FairUsage) -> RustBuffer {
    return FfiConverterTypeFairUsage.lower(value)
}


public struct FeatureFlags {
    public var flags: [String: FlagValue]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(flags: [String: FlagValue]) {
        self.flags = flags
    }
}



extension FeatureFlags: Equatable, Hashable {
    public static func ==(lhs: FeatureFlags, rhs: FeatureFlags) -> Bool {
        if lhs.flags != rhs.flags {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(flags)
    }
}


public struct FfiConverterTypeFeatureFlags: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeatureFlags {
        return
            try FeatureFlags(
                flags: FfiConverterDictionaryStringTypeFlagValue.read(from: &buf)
        )
    }

    public static func write(_ value: FeatureFlags, into buf: inout [UInt8]) {
        FfiConverterDictionaryStringTypeFlagValue.write(value.flags, into: &buf)
    }
}


public func FfiConverterTypeFeatureFlags_lift(_ buf: RustBuffer) throws -> FeatureFlags {
    return try FfiConverterTypeFeatureFlags.lift(buf)
}

public func FfiConverterTypeFeatureFlags_lower(_ value: FeatureFlags) -> RustBuffer {
    return FfiConverterTypeFeatureFlags.lower(value)
}


public struct GatewayMinPerformance {
    public var mixnetMinPerformance: UInt64?
    public var vpnMinPerformance: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(mixnetMinPerformance: UInt64?, vpnMinPerformance: UInt64?) {
        self.mixnetMinPerformance = mixnetMinPerformance
        self.vpnMinPerformance = vpnMinPerformance
    }
}



extension GatewayMinPerformance: Equatable, Hashable {
    public static func ==(lhs: GatewayMinPerformance, rhs: GatewayMinPerformance) -> Bool {
        if lhs.mixnetMinPerformance != rhs.mixnetMinPerformance {
            return false
        }
        if lhs.vpnMinPerformance != rhs.vpnMinPerformance {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(mixnetMinPerformance)
        hasher.combine(vpnMinPerformance)
    }
}


public struct FfiConverterTypeGatewayMinPerformance: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GatewayMinPerformance {
        return
            try GatewayMinPerformance(
                mixnetMinPerformance: FfiConverterOptionUInt64.read(from: &buf), 
                vpnMinPerformance: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: GatewayMinPerformance, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.mixnetMinPerformance, into: &buf)
        FfiConverterOptionUInt64.write(value.vpnMinPerformance, into: &buf)
    }
}


public func FfiConverterTypeGatewayMinPerformance_lift(_ buf: RustBuffer) throws -> GatewayMinPerformance {
    return try FfiConverterTypeGatewayMinPerformance.lift(buf)
}

public func FfiConverterTypeGatewayMinPerformance_lower(_ value: GatewayMinPerformance) -> RustBuffer {
    return FfiConverterTypeGatewayMinPerformance.lower(value)
}


public struct Ipv4Settings {
    /**
     * IPv4 addresses that will be set on tunnel interface.
     */
    public var addresses: [Ipv4Network]
    /**
     * Traffic matching these routes will be routed over the tun interface.
     */
    public var includedRoutes: [Ipv4Route]?
    /**
     * Traffic matching these routes will be routed over the primary physical interface.
     */
    public var excludedRoutes: [Ipv4Route]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * IPv4 addresses that will be set on tunnel interface.
         */addresses: [Ipv4Network], 
        /**
         * Traffic matching these routes will be routed over the tun interface.
         */includedRoutes: [Ipv4Route]?, 
        /**
         * Traffic matching these routes will be routed over the primary physical interface.
         */excludedRoutes: [Ipv4Route]?) {
        self.addresses = addresses
        self.includedRoutes = includedRoutes
        self.excludedRoutes = excludedRoutes
    }
}



extension Ipv4Settings: Equatable, Hashable {
    public static func ==(lhs: Ipv4Settings, rhs: Ipv4Settings) -> Bool {
        if lhs.addresses != rhs.addresses {
            return false
        }
        if lhs.includedRoutes != rhs.includedRoutes {
            return false
        }
        if lhs.excludedRoutes != rhs.excludedRoutes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(addresses)
        hasher.combine(includedRoutes)
        hasher.combine(excludedRoutes)
    }
}


public struct FfiConverterTypeIpv4Settings: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Ipv4Settings {
        return
            try Ipv4Settings(
                addresses: FfiConverterSequenceTypeIpv4Network.read(from: &buf), 
                includedRoutes: FfiConverterOptionSequenceTypeIpv4Route.read(from: &buf), 
                excludedRoutes: FfiConverterOptionSequenceTypeIpv4Route.read(from: &buf)
        )
    }

    public static func write(_ value: Ipv4Settings, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeIpv4Network.write(value.addresses, into: &buf)
        FfiConverterOptionSequenceTypeIpv4Route.write(value.includedRoutes, into: &buf)
        FfiConverterOptionSequenceTypeIpv4Route.write(value.excludedRoutes, into: &buf)
    }
}


public func FfiConverterTypeIpv4Settings_lift(_ buf: RustBuffer) throws -> Ipv4Settings {
    return try FfiConverterTypeIpv4Settings.lift(buf)
}

public func FfiConverterTypeIpv4Settings_lower(_ value: Ipv4Settings) -> RustBuffer {
    return FfiConverterTypeIpv4Settings.lower(value)
}


public struct Ipv6Settings {
    /**
     * IPv4 addresses that will be set on tunnel interface.
     */
    public var addresses: [Ipv6Network]
    /**
     * Traffic matching these routes will be routed over the tun interface.
     */
    public var includedRoutes: [Ipv6Route]?
    /**
     * Traffic matching these routes will be routed over the primary physical interface.
     */
    public var excludedRoutes: [Ipv6Route]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * IPv4 addresses that will be set on tunnel interface.
         */addresses: [Ipv6Network], 
        /**
         * Traffic matching these routes will be routed over the tun interface.
         */includedRoutes: [Ipv6Route]?, 
        /**
         * Traffic matching these routes will be routed over the primary physical interface.
         */excludedRoutes: [Ipv6Route]?) {
        self.addresses = addresses
        self.includedRoutes = includedRoutes
        self.excludedRoutes = excludedRoutes
    }
}



extension Ipv6Settings: Equatable, Hashable {
    public static func ==(lhs: Ipv6Settings, rhs: Ipv6Settings) -> Bool {
        if lhs.addresses != rhs.addresses {
            return false
        }
        if lhs.includedRoutes != rhs.includedRoutes {
            return false
        }
        if lhs.excludedRoutes != rhs.excludedRoutes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(addresses)
        hasher.combine(includedRoutes)
        hasher.combine(excludedRoutes)
    }
}


public struct FfiConverterTypeIpv6Settings: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Ipv6Settings {
        return
            try Ipv6Settings(
                addresses: FfiConverterSequenceTypeIpv6Network.read(from: &buf), 
                includedRoutes: FfiConverterOptionSequenceTypeIpv6Route.read(from: &buf), 
                excludedRoutes: FfiConverterOptionSequenceTypeIpv6Route.read(from: &buf)
        )
    }

    public static func write(_ value: Ipv6Settings, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeIpv6Network.write(value.addresses, into: &buf)
        FfiConverterOptionSequenceTypeIpv6Route.write(value.includedRoutes, into: &buf)
        FfiConverterOptionSequenceTypeIpv6Route.write(value.excludedRoutes, into: &buf)
    }
}


public func FfiConverterTypeIpv6Settings_lift(_ buf: RustBuffer) throws -> Ipv6Settings {
    return try FfiConverterTypeIpv6Settings.lift(buf)
}

public func FfiConverterTypeIpv6Settings_lower(_ value: Ipv6Settings) -> RustBuffer {
    return FfiConverterTypeIpv6Settings.lower(value)
}


public struct Location {
    public var twoLetterIsoCountryCode: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(twoLetterIsoCountryCode: String) {
        self.twoLetterIsoCountryCode = twoLetterIsoCountryCode
    }
}



extension Location: Equatable, Hashable {
    public static func ==(lhs: Location, rhs: Location) -> Bool {
        if lhs.twoLetterIsoCountryCode != rhs.twoLetterIsoCountryCode {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(twoLetterIsoCountryCode)
    }
}


public struct FfiConverterTypeLocation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Location {
        return
            try Location(
                twoLetterIsoCountryCode: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Location, into buf: inout [UInt8]) {
        FfiConverterString.write(value.twoLetterIsoCountryCode, into: &buf)
    }
}


public func FfiConverterTypeLocation_lift(_ buf: RustBuffer) throws -> Location {
    return try FfiConverterTypeLocation.lift(buf)
}

public func FfiConverterTypeLocation_lower(_ value: Location) -> RustBuffer {
    return FfiConverterTypeLocation.lower(value)
}


public struct MixConnectionInfo {
    public var nymAddress: Recipient
    public var entryGateway: NodeIdentity

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(nymAddress: Recipient, entryGateway: NodeIdentity) {
        self.nymAddress = nymAddress
        self.entryGateway = entryGateway
    }
}



extension MixConnectionInfo: Equatable, Hashable {
    public static func ==(lhs: MixConnectionInfo, rhs: MixConnectionInfo) -> Bool {
        if lhs.nymAddress != rhs.nymAddress {
            return false
        }
        if lhs.entryGateway != rhs.entryGateway {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(nymAddress)
        hasher.combine(entryGateway)
    }
}


public struct FfiConverterTypeMixConnectionInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MixConnectionInfo {
        return
            try MixConnectionInfo(
                nymAddress: FfiConverterTypeRecipient.read(from: &buf), 
                entryGateway: FfiConverterTypeNodeIdentity.read(from: &buf)
        )
    }

    public static func write(_ value: MixConnectionInfo, into buf: inout [UInt8]) {
        FfiConverterTypeRecipient.write(value.nymAddress, into: &buf)
        FfiConverterTypeNodeIdentity.write(value.entryGateway, into: &buf)
    }
}


public func FfiConverterTypeMixConnectionInfo_lift(_ buf: RustBuffer) throws -> MixConnectionInfo {
    return try FfiConverterTypeMixConnectionInfo.lift(buf)
}

public func FfiConverterTypeMixConnectionInfo_lower(_ value: MixConnectionInfo) -> RustBuffer {
    return FfiConverterTypeMixConnectionInfo.lower(value)
}


public struct MixExitConnectionInfo {
    public var exitGateway: NodeIdentity
    public var exitIpr: Recipient
    public var ips: IpPair

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(exitGateway: NodeIdentity, exitIpr: Recipient, ips: IpPair) {
        self.exitGateway = exitGateway
        self.exitIpr = exitIpr
        self.ips = ips
    }
}



extension MixExitConnectionInfo: Equatable, Hashable {
    public static func ==(lhs: MixExitConnectionInfo, rhs: MixExitConnectionInfo) -> Bool {
        if lhs.exitGateway != rhs.exitGateway {
            return false
        }
        if lhs.exitIpr != rhs.exitIpr {
            return false
        }
        if lhs.ips != rhs.ips {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(exitGateway)
        hasher.combine(exitIpr)
        hasher.combine(ips)
    }
}


public struct FfiConverterTypeMixExitConnectionInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MixExitConnectionInfo {
        return
            try MixExitConnectionInfo(
                exitGateway: FfiConverterTypeNodeIdentity.read(from: &buf), 
                exitIpr: FfiConverterTypeRecipient.read(from: &buf), 
                ips: FfiConverterTypeIpPair.read(from: &buf)
        )
    }

    public static func write(_ value: MixExitConnectionInfo, into buf: inout [UInt8]) {
        FfiConverterTypeNodeIdentity.write(value.exitGateway, into: &buf)
        FfiConverterTypeRecipient.write(value.exitIpr, into: &buf)
        FfiConverterTypeIpPair.write(value.ips, into: &buf)
    }
}


public func FfiConverterTypeMixExitConnectionInfo_lift(_ buf: RustBuffer) throws -> MixExitConnectionInfo {
    return try FfiConverterTypeMixExitConnectionInfo.lift(buf)
}

public func FfiConverterTypeMixExitConnectionInfo_lower(_ value: MixExitConnectionInfo) -> RustBuffer {
    return FfiConverterTypeMixExitConnectionInfo.lower(value)
}


public struct MixnetConnectionData {
    public var nymAddress: BoxedRecepient
    public var exitIpr: BoxedRecepient
    public var ipv4: Ipv4Addr
    public var ipv6: Ipv6Addr

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(nymAddress: BoxedRecepient, exitIpr: BoxedRecepient, ipv4: Ipv4Addr, ipv6: Ipv6Addr) {
        self.nymAddress = nymAddress
        self.exitIpr = exitIpr
        self.ipv4 = ipv4
        self.ipv6 = ipv6
    }
}



extension MixnetConnectionData: Equatable, Hashable {
    public static func ==(lhs: MixnetConnectionData, rhs: MixnetConnectionData) -> Bool {
        if lhs.nymAddress != rhs.nymAddress {
            return false
        }
        if lhs.exitIpr != rhs.exitIpr {
            return false
        }
        if lhs.ipv4 != rhs.ipv4 {
            return false
        }
        if lhs.ipv6 != rhs.ipv6 {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(nymAddress)
        hasher.combine(exitIpr)
        hasher.combine(ipv4)
        hasher.combine(ipv6)
    }
}


public struct FfiConverterTypeMixnetConnectionData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MixnetConnectionData {
        return
            try MixnetConnectionData(
                nymAddress: FfiConverterTypeBoxedRecepient.read(from: &buf), 
                exitIpr: FfiConverterTypeBoxedRecepient.read(from: &buf), 
                ipv4: FfiConverterTypeIpv4Addr.read(from: &buf), 
                ipv6: FfiConverterTypeIpv6Addr.read(from: &buf)
        )
    }

    public static func write(_ value: MixnetConnectionData, into buf: inout [UInt8]) {
        FfiConverterTypeBoxedRecepient.write(value.nymAddress, into: &buf)
        FfiConverterTypeBoxedRecepient.write(value.exitIpr, into: &buf)
        FfiConverterTypeIpv4Addr.write(value.ipv4, into: &buf)
        FfiConverterTypeIpv6Addr.write(value.ipv6, into: &buf)
    }
}


public func FfiConverterTypeMixnetConnectionData_lift(_ buf: RustBuffer) throws -> MixnetConnectionData {
    return try FfiConverterTypeMixnetConnectionData.lift(buf)
}

public func FfiConverterTypeMixnetConnectionData_lower(_ value: MixnetConnectionData) -> RustBuffer {
    return FfiConverterTypeMixnetConnectionData.lower(value)
}


/**
 * Represents the nym network environment together with the environment specific to nym-vpn. These
 * need to be exported to the environment (for now, until it's refactored internally in the nym
 * crates) so that the client can have access to the necessary information.
 *
 * The list is as of today:
 *
 * NETWORK_NAME = nym_network::network_name
 *
 * BECH32_PREFIX = nym_network::chain_details::bech32_account_prefix
 * MIX_DENOM = nym_network::chain_details::mix_denom::base
 * MIX_DENOM_DISPLAY = nym_network::chain_details::mix_denom::display
 * STAKE_DENOM = nym_network::chain_details::stake_denom::base
 * STAKE_DENOM_DISPLAY = nym_network::chain_details::stake_denom::display
 * DENOMS_EXPONENT = nym_network::chain_details::mix_denom::display_exponent
 *
 * MIXNET_CONTRACT_ADDRESS = nym_network::contracts::mixnet_contract_address
 * VESTING_CONTRACT_ADDRESS = nym_network::contracts::vesting_contract_address
 * GROUP_CONTRACT_ADDRESS = nym_network::contracts::group_contract_address
 * ECASH_CONTRACT_ADDRESS = nym_network::contracts::ecash_contract_address
 * MULTISIG_CONTRACT_ADDRESS = nym_network::contracts::multisig_contract_address
 * COCONUT_DKG_CONTRACT_ADDRESS = nym_network::contracts::coconut_dkg_contract_address
 *
 * NYXD = nym_network::endpoints[0]::nyxd_url
 * NYM_API = nym_network::endpoints[0]::api_url
 * NYXD_WS = nym_network::endpoints[0]::websocket_url
 *
 * NYM_VPN_API = nym_vpn_network::nym_vpn_api_url
 */
public struct NetworkEnvironment {
    public var nymNetwork: NymNetworkDetails
    public var nymVpnNetwork: NymVpnNetwork
    public var featureFlags: FeatureFlags?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(nymNetwork: NymNetworkDetails, nymVpnNetwork: NymVpnNetwork, featureFlags: FeatureFlags?) {
        self.nymNetwork = nymNetwork
        self.nymVpnNetwork = nymVpnNetwork
        self.featureFlags = featureFlags
    }
}



extension NetworkEnvironment: Equatable, Hashable {
    public static func ==(lhs: NetworkEnvironment, rhs: NetworkEnvironment) -> Bool {
        if lhs.nymNetwork != rhs.nymNetwork {
            return false
        }
        if lhs.nymVpnNetwork != rhs.nymVpnNetwork {
            return false
        }
        if lhs.featureFlags != rhs.featureFlags {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(nymNetwork)
        hasher.combine(nymVpnNetwork)
        hasher.combine(featureFlags)
    }
}


public struct FfiConverterTypeNetworkEnvironment: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkEnvironment {
        return
            try NetworkEnvironment(
                nymNetwork: FfiConverterTypeNymNetworkDetails.read(from: &buf), 
                nymVpnNetwork: FfiConverterTypeNymVpnNetwork.read(from: &buf), 
                featureFlags: FfiConverterOptionTypeFeatureFlags.read(from: &buf)
        )
    }

    public static func write(_ value: NetworkEnvironment, into buf: inout [UInt8]) {
        FfiConverterTypeNymNetworkDetails.write(value.nymNetwork, into: &buf)
        FfiConverterTypeNymVpnNetwork.write(value.nymVpnNetwork, into: &buf)
        FfiConverterOptionTypeFeatureFlags.write(value.featureFlags, into: &buf)
    }
}


public func FfiConverterTypeNetworkEnvironment_lift(_ buf: RustBuffer) throws -> NetworkEnvironment {
    return try FfiConverterTypeNetworkEnvironment.lift(buf)
}

public func FfiConverterTypeNetworkEnvironment_lower(_ value: NetworkEnvironment) -> RustBuffer {
    return FfiConverterTypeNetworkEnvironment.lower(value)
}


public struct NymContracts {
    public var mixnetContractAddress: String?
    public var vestingContractAddress: String?
    public var ecashContractAddress: String?
    public var groupContractAddress: String?
    public var multisigContractAddress: String?
    public var coconutDkgContractAddress: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(mixnetContractAddress: String?, vestingContractAddress: String?, ecashContractAddress: String?, groupContractAddress: String?, multisigContractAddress: String?, coconutDkgContractAddress: String?) {
        self.mixnetContractAddress = mixnetContractAddress
        self.vestingContractAddress = vestingContractAddress
        self.ecashContractAddress = ecashContractAddress
        self.groupContractAddress = groupContractAddress
        self.multisigContractAddress = multisigContractAddress
        self.coconutDkgContractAddress = coconutDkgContractAddress
    }
}



extension NymContracts: Equatable, Hashable {
    public static func ==(lhs: NymContracts, rhs: NymContracts) -> Bool {
        if lhs.mixnetContractAddress != rhs.mixnetContractAddress {
            return false
        }
        if lhs.vestingContractAddress != rhs.vestingContractAddress {
            return false
        }
        if lhs.ecashContractAddress != rhs.ecashContractAddress {
            return false
        }
        if lhs.groupContractAddress != rhs.groupContractAddress {
            return false
        }
        if lhs.multisigContractAddress != rhs.multisigContractAddress {
            return false
        }
        if lhs.coconutDkgContractAddress != rhs.coconutDkgContractAddress {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(mixnetContractAddress)
        hasher.combine(vestingContractAddress)
        hasher.combine(ecashContractAddress)
        hasher.combine(groupContractAddress)
        hasher.combine(multisigContractAddress)
        hasher.combine(coconutDkgContractAddress)
    }
}


public struct FfiConverterTypeNymContracts: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NymContracts {
        return
            try NymContracts(
                mixnetContractAddress: FfiConverterOptionString.read(from: &buf), 
                vestingContractAddress: FfiConverterOptionString.read(from: &buf), 
                ecashContractAddress: FfiConverterOptionString.read(from: &buf), 
                groupContractAddress: FfiConverterOptionString.read(from: &buf), 
                multisigContractAddress: FfiConverterOptionString.read(from: &buf), 
                coconutDkgContractAddress: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: NymContracts, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.mixnetContractAddress, into: &buf)
        FfiConverterOptionString.write(value.vestingContractAddress, into: &buf)
        FfiConverterOptionString.write(value.ecashContractAddress, into: &buf)
        FfiConverterOptionString.write(value.groupContractAddress, into: &buf)
        FfiConverterOptionString.write(value.multisigContractAddress, into: &buf)
        FfiConverterOptionString.write(value.coconutDkgContractAddress, into: &buf)
    }
}


public func FfiConverterTypeNymContracts_lift(_ buf: RustBuffer) throws -> NymContracts {
    return try FfiConverterTypeNymContracts.lift(buf)
}

public func FfiConverterTypeNymContracts_lower(_ value: NymContracts) -> RustBuffer {
    return FfiConverterTypeNymContracts.lower(value)
}


public struct NymNetworkDetails {
    public var networkName: String
    public var chainDetails: ChainDetails
    public var endpoints: [ValidatorDetails]
    public var contracts: NymContracts

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(networkName: String, chainDetails: ChainDetails, endpoints: [ValidatorDetails], contracts: NymContracts) {
        self.networkName = networkName
        self.chainDetails = chainDetails
        self.endpoints = endpoints
        self.contracts = contracts
    }
}



extension NymNetworkDetails: Equatable, Hashable {
    public static func ==(lhs: NymNetworkDetails, rhs: NymNetworkDetails) -> Bool {
        if lhs.networkName != rhs.networkName {
            return false
        }
        if lhs.chainDetails != rhs.chainDetails {
            return false
        }
        if lhs.endpoints != rhs.endpoints {
            return false
        }
        if lhs.contracts != rhs.contracts {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkName)
        hasher.combine(chainDetails)
        hasher.combine(endpoints)
        hasher.combine(contracts)
    }
}


public struct FfiConverterTypeNymNetworkDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NymNetworkDetails {
        return
            try NymNetworkDetails(
                networkName: FfiConverterString.read(from: &buf), 
                chainDetails: FfiConverterTypeChainDetails.read(from: &buf), 
                endpoints: FfiConverterSequenceTypeValidatorDetails.read(from: &buf), 
                contracts: FfiConverterTypeNymContracts.read(from: &buf)
        )
    }

    public static func write(_ value: NymNetworkDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.networkName, into: &buf)
        FfiConverterTypeChainDetails.write(value.chainDetails, into: &buf)
        FfiConverterSequenceTypeValidatorDetails.write(value.endpoints, into: &buf)
        FfiConverterTypeNymContracts.write(value.contracts, into: &buf)
    }
}


public func FfiConverterTypeNymNetworkDetails_lift(_ buf: RustBuffer) throws -> NymNetworkDetails {
    return try FfiConverterTypeNymNetworkDetails.lift(buf)
}

public func FfiConverterTypeNymNetworkDetails_lower(_ value: NymNetworkDetails) -> RustBuffer {
    return FfiConverterTypeNymNetworkDetails.lower(value)
}


public struct NymVpnNetwork {
    public var nymVpnApiUrl: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(nymVpnApiUrl: String) {
        self.nymVpnApiUrl = nymVpnApiUrl
    }
}



extension NymVpnNetwork: Equatable, Hashable {
    public static func ==(lhs: NymVpnNetwork, rhs: NymVpnNetwork) -> Bool {
        if lhs.nymVpnApiUrl != rhs.nymVpnApiUrl {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(nymVpnApiUrl)
    }
}


public struct FfiConverterTypeNymVpnNetwork: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NymVpnNetwork {
        return
            try NymVpnNetwork(
                nymVpnApiUrl: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: NymVpnNetwork, into buf: inout [UInt8]) {
        FfiConverterString.write(value.nymVpnApiUrl, into: &buf)
    }
}


public func FfiConverterTypeNymVpnNetwork_lift(_ buf: RustBuffer) throws -> NymVpnNetwork {
    return try FfiConverterTypeNymVpnNetwork.lift(buf)
}

public func FfiConverterTypeNymVpnNetwork_lower(_ value: NymVpnNetwork) -> RustBuffer {
    return FfiConverterTypeNymVpnNetwork.lower(value)
}


/**
 * Represents a default network route used by the system.
 */
public struct OsDefaultPath {
    /**
     * Indicates whether the process is able to make connection through the given path.
     */
    public var status: OsPathStatus
    /**
     * Set to true for interfaces that are considered expensive, such as when using cellular data plan.
     */
    public var isExpensive: Bool
    /**
     * Set to true when using a constrained interface, such as when using low-data mode.
     */
    public var isConstrained: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Indicates whether the process is able to make connection through the given path.
         */status: OsPathStatus, 
        /**
         * Set to true for interfaces that are considered expensive, such as when using cellular data plan.
         */isExpensive: Bool, 
        /**
         * Set to true when using a constrained interface, such as when using low-data mode.
         */isConstrained: Bool) {
        self.status = status
        self.isExpensive = isExpensive
        self.isConstrained = isConstrained
    }
}



extension OsDefaultPath: Equatable, Hashable {
    public static func ==(lhs: OsDefaultPath, rhs: OsDefaultPath) -> Bool {
        if lhs.status != rhs.status {
            return false
        }
        if lhs.isExpensive != rhs.isExpensive {
            return false
        }
        if lhs.isConstrained != rhs.isConstrained {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(status)
        hasher.combine(isExpensive)
        hasher.combine(isConstrained)
    }
}


public struct FfiConverterTypeOSDefaultPath: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OsDefaultPath {
        return
            try OsDefaultPath(
                status: FfiConverterTypeOSPathStatus.read(from: &buf), 
                isExpensive: FfiConverterBool.read(from: &buf), 
                isConstrained: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: OsDefaultPath, into buf: inout [UInt8]) {
        FfiConverterTypeOSPathStatus.write(value.status, into: &buf)
        FfiConverterBool.write(value.isExpensive, into: &buf)
        FfiConverterBool.write(value.isConstrained, into: &buf)
    }
}


public func FfiConverterTypeOSDefaultPath_lift(_ buf: RustBuffer) throws -> OsDefaultPath {
    return try FfiConverterTypeOSDefaultPath.lift(buf)
}

public func FfiConverterTypeOSDefaultPath_lower(_ value: OsDefaultPath) -> RustBuffer {
    return FfiConverterTypeOSDefaultPath.lower(value)
}


public struct SystemMessage {
    public var name: String
    public var message: String
    public var properties: [String: String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, message: String, properties: [String: String]) {
        self.name = name
        self.message = message
        self.properties = properties
    }
}



extension SystemMessage: Equatable, Hashable {
    public static func ==(lhs: SystemMessage, rhs: SystemMessage) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        if lhs.properties != rhs.properties {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(message)
        hasher.combine(properties)
    }
}


public struct FfiConverterTypeSystemMessage: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SystemMessage {
        return
            try SystemMessage(
                name: FfiConverterString.read(from: &buf), 
                message: FfiConverterString.read(from: &buf), 
                properties: FfiConverterDictionaryStringString.read(from: &buf)
        )
    }

    public static func write(_ value: SystemMessage, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.message, into: &buf)
        FfiConverterDictionaryStringString.write(value.properties, into: &buf)
    }
}


public func FfiConverterTypeSystemMessage_lift(_ buf: RustBuffer) throws -> SystemMessage {
    return try FfiConverterTypeSystemMessage.lift(buf)
}

public func FfiConverterTypeSystemMessage_lower(_ value: SystemMessage) -> RustBuffer {
    return FfiConverterTypeSystemMessage.lower(value)
}


/**
 * Tunnel + network settings
 */
public struct TunnelNetworkSettings {
    /**
     * Tunnel remote address, which is mostly of decorative value.
     */
    public var tunnelRemoteAddress: String
    /**
     * IPv4 interface settings.
     */
    public var ipv4Settings: Ipv4Settings?
    /**
     * IPv6 interface settings.
     */
    public var ipv6Settings: Ipv6Settings?
    /**
     * DNS settings.
     */
    public var dnsSettings: DnsSettings?
    /**
     * Tunnel device MTU.
     */
    public var mtu: UInt16

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Tunnel remote address, which is mostly of decorative value.
         */tunnelRemoteAddress: String, 
        /**
         * IPv4 interface settings.
         */ipv4Settings: Ipv4Settings?, 
        /**
         * IPv6 interface settings.
         */ipv6Settings: Ipv6Settings?, 
        /**
         * DNS settings.
         */dnsSettings: DnsSettings?, 
        /**
         * Tunnel device MTU.
         */mtu: UInt16) {
        self.tunnelRemoteAddress = tunnelRemoteAddress
        self.ipv4Settings = ipv4Settings
        self.ipv6Settings = ipv6Settings
        self.dnsSettings = dnsSettings
        self.mtu = mtu
    }
}



extension TunnelNetworkSettings: Equatable, Hashable {
    public static func ==(lhs: TunnelNetworkSettings, rhs: TunnelNetworkSettings) -> Bool {
        if lhs.tunnelRemoteAddress != rhs.tunnelRemoteAddress {
            return false
        }
        if lhs.ipv4Settings != rhs.ipv4Settings {
            return false
        }
        if lhs.ipv6Settings != rhs.ipv6Settings {
            return false
        }
        if lhs.dnsSettings != rhs.dnsSettings {
            return false
        }
        if lhs.mtu != rhs.mtu {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(tunnelRemoteAddress)
        hasher.combine(ipv4Settings)
        hasher.combine(ipv6Settings)
        hasher.combine(dnsSettings)
        hasher.combine(mtu)
    }
}


public struct FfiConverterTypeTunnelNetworkSettings: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TunnelNetworkSettings {
        return
            try TunnelNetworkSettings(
                tunnelRemoteAddress: FfiConverterString.read(from: &buf), 
                ipv4Settings: FfiConverterOptionTypeIpv4Settings.read(from: &buf), 
                ipv6Settings: FfiConverterOptionTypeIpv6Settings.read(from: &buf), 
                dnsSettings: FfiConverterOptionTypeDnsSettings.read(from: &buf), 
                mtu: FfiConverterUInt16.read(from: &buf)
        )
    }

    public static func write(_ value: TunnelNetworkSettings, into buf: inout [UInt8]) {
        FfiConverterString.write(value.tunnelRemoteAddress, into: &buf)
        FfiConverterOptionTypeIpv4Settings.write(value.ipv4Settings, into: &buf)
        FfiConverterOptionTypeIpv6Settings.write(value.ipv6Settings, into: &buf)
        FfiConverterOptionTypeDnsSettings.write(value.dnsSettings, into: &buf)
        FfiConverterUInt16.write(value.mtu, into: &buf)
    }
}


public func FfiConverterTypeTunnelNetworkSettings_lift(_ buf: RustBuffer) throws -> TunnelNetworkSettings {
    return try FfiConverterTypeTunnelNetworkSettings.lift(buf)
}

public func FfiConverterTypeTunnelNetworkSettings_lower(_ value: TunnelNetworkSettings) -> RustBuffer {
    return FfiConverterTypeTunnelNetworkSettings.lower(value)
}


public struct UserAgent {
    public var application: String
    public var version: String
    public var platform: String
    public var gitCommit: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(application: String, version: String, platform: String, gitCommit: String) {
        self.application = application
        self.version = version
        self.platform = platform
        self.gitCommit = gitCommit
    }
}



extension UserAgent: Equatable, Hashable {
    public static func ==(lhs: UserAgent, rhs: UserAgent) -> Bool {
        if lhs.application != rhs.application {
            return false
        }
        if lhs.version != rhs.version {
            return false
        }
        if lhs.platform != rhs.platform {
            return false
        }
        if lhs.gitCommit != rhs.gitCommit {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(application)
        hasher.combine(version)
        hasher.combine(platform)
        hasher.combine(gitCommit)
    }
}


public struct FfiConverterTypeUserAgent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserAgent {
        return
            try UserAgent(
                application: FfiConverterString.read(from: &buf), 
                version: FfiConverterString.read(from: &buf), 
                platform: FfiConverterString.read(from: &buf), 
                gitCommit: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: UserAgent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.application, into: &buf)
        FfiConverterString.write(value.version, into: &buf)
        FfiConverterString.write(value.platform, into: &buf)
        FfiConverterString.write(value.gitCommit, into: &buf)
    }
}


public func FfiConverterTypeUserAgent_lift(_ buf: RustBuffer) throws -> UserAgent {
    return try FfiConverterTypeUserAgent.lift(buf)
}

public func FfiConverterTypeUserAgent_lower(_ value: UserAgent) -> RustBuffer {
    return FfiConverterTypeUserAgent.lower(value)
}


public struct VpnConfig {
    public var entryGateway: EntryPoint
    public var exitRouter: ExitPoint
    public var enableTwoHop: Bool
    public var tunProvider: OsTunProvider
    public var credentialDataPath: PathBuf?
    public var tunStatusListener: TunnelStatusListener?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(entryGateway: EntryPoint, exitRouter: ExitPoint, enableTwoHop: Bool, tunProvider: OsTunProvider, credentialDataPath: PathBuf?, tunStatusListener: TunnelStatusListener?) {
        self.entryGateway = entryGateway
        self.exitRouter = exitRouter
        self.enableTwoHop = enableTwoHop
        self.tunProvider = tunProvider
        self.credentialDataPath = credentialDataPath
        self.tunStatusListener = tunStatusListener
    }
}



public struct FfiConverterTypeVPNConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VpnConfig {
        return
            try VpnConfig(
                entryGateway: FfiConverterTypeEntryPoint.read(from: &buf), 
                exitRouter: FfiConverterTypeExitPoint.read(from: &buf), 
                enableTwoHop: FfiConverterBool.read(from: &buf), 
                tunProvider: FfiConverterTypeOSTunProvider.read(from: &buf), 
                credentialDataPath: FfiConverterOptionTypePathBuf.read(from: &buf), 
                tunStatusListener: FfiConverterOptionTypeTunnelStatusListener.read(from: &buf)
        )
    }

    public static func write(_ value: VpnConfig, into buf: inout [UInt8]) {
        FfiConverterTypeEntryPoint.write(value.entryGateway, into: &buf)
        FfiConverterTypeExitPoint.write(value.exitRouter, into: &buf)
        FfiConverterBool.write(value.enableTwoHop, into: &buf)
        FfiConverterTypeOSTunProvider.write(value.tunProvider, into: &buf)
        FfiConverterOptionTypePathBuf.write(value.credentialDataPath, into: &buf)
        FfiConverterOptionTypeTunnelStatusListener.write(value.tunStatusListener, into: &buf)
    }
}


public func FfiConverterTypeVPNConfig_lift(_ buf: RustBuffer) throws -> VpnConfig {
    return try FfiConverterTypeVPNConfig.lift(buf)
}

public func FfiConverterTypeVPNConfig_lower(_ value: VpnConfig) -> RustBuffer {
    return FfiConverterTypeVPNConfig.lower(value)
}


public struct ValidatorDetails {
    public var nyxdUrl: String
    public var websocketUrl: String?
    public var apiUrl: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(nyxdUrl: String, websocketUrl: String?, apiUrl: String?) {
        self.nyxdUrl = nyxdUrl
        self.websocketUrl = websocketUrl
        self.apiUrl = apiUrl
    }
}



extension ValidatorDetails: Equatable, Hashable {
    public static func ==(lhs: ValidatorDetails, rhs: ValidatorDetails) -> Bool {
        if lhs.nyxdUrl != rhs.nyxdUrl {
            return false
        }
        if lhs.websocketUrl != rhs.websocketUrl {
            return false
        }
        if lhs.apiUrl != rhs.apiUrl {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(nyxdUrl)
        hasher.combine(websocketUrl)
        hasher.combine(apiUrl)
    }
}


public struct FfiConverterTypeValidatorDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ValidatorDetails {
        return
            try ValidatorDetails(
                nyxdUrl: FfiConverterString.read(from: &buf), 
                websocketUrl: FfiConverterOptionString.read(from: &buf), 
                apiUrl: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: ValidatorDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.nyxdUrl, into: &buf)
        FfiConverterOptionString.write(value.websocketUrl, into: &buf)
        FfiConverterOptionString.write(value.apiUrl, into: &buf)
    }
}


public func FfiConverterTypeValidatorDetails_lift(_ buf: RustBuffer) throws -> ValidatorDetails {
    return try FfiConverterTypeValidatorDetails.lift(buf)
}

public func FfiConverterTypeValidatorDetails_lower(_ value: ValidatorDetails) -> RustBuffer {
    return FfiConverterTypeValidatorDetails.lower(value)
}


public struct WireguardConnectionData {
    public var entry: WireguardNode
    public var exit: WireguardNode

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(entry: WireguardNode, exit: WireguardNode) {
        self.entry = entry
        self.exit = exit
    }
}



extension WireguardConnectionData: Equatable, Hashable {
    public static func ==(lhs: WireguardConnectionData, rhs: WireguardConnectionData) -> Bool {
        if lhs.entry != rhs.entry {
            return false
        }
        if lhs.exit != rhs.exit {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(entry)
        hasher.combine(exit)
    }
}


public struct FfiConverterTypeWireguardConnectionData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WireguardConnectionData {
        return
            try WireguardConnectionData(
                entry: FfiConverterTypeWireguardNode.read(from: &buf), 
                exit: FfiConverterTypeWireguardNode.read(from: &buf)
        )
    }

    public static func write(_ value: WireguardConnectionData, into buf: inout [UInt8]) {
        FfiConverterTypeWireguardNode.write(value.entry, into: &buf)
        FfiConverterTypeWireguardNode.write(value.exit, into: &buf)
    }
}


public func FfiConverterTypeWireguardConnectionData_lift(_ buf: RustBuffer) throws -> WireguardConnectionData {
    return try FfiConverterTypeWireguardConnectionData.lift(buf)
}

public func FfiConverterTypeWireguardConnectionData_lower(_ value: WireguardConnectionData) -> RustBuffer {
    return FfiConverterTypeWireguardConnectionData.lower(value)
}


public struct WireguardConnectionInfo {
    public var gatewayId: NodeIdentity
    public var publicKey: String
    public var privateIpv4: Ipv4Addr

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(gatewayId: NodeIdentity, publicKey: String, privateIpv4: Ipv4Addr) {
        self.gatewayId = gatewayId
        self.publicKey = publicKey
        self.privateIpv4 = privateIpv4
    }
}



extension WireguardConnectionInfo: Equatable, Hashable {
    public static func ==(lhs: WireguardConnectionInfo, rhs: WireguardConnectionInfo) -> Bool {
        if lhs.gatewayId != rhs.gatewayId {
            return false
        }
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.privateIpv4 != rhs.privateIpv4 {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(gatewayId)
        hasher.combine(publicKey)
        hasher.combine(privateIpv4)
    }
}


public struct FfiConverterTypeWireguardConnectionInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WireguardConnectionInfo {
        return
            try WireguardConnectionInfo(
                gatewayId: FfiConverterTypeNodeIdentity.read(from: &buf), 
                publicKey: FfiConverterString.read(from: &buf), 
                privateIpv4: FfiConverterTypeIpv4Addr.read(from: &buf)
        )
    }

    public static func write(_ value: WireguardConnectionInfo, into buf: inout [UInt8]) {
        FfiConverterTypeNodeIdentity.write(value.gatewayId, into: &buf)
        FfiConverterString.write(value.publicKey, into: &buf)
        FfiConverterTypeIpv4Addr.write(value.privateIpv4, into: &buf)
    }
}


public func FfiConverterTypeWireguardConnectionInfo_lift(_ buf: RustBuffer) throws -> WireguardConnectionInfo {
    return try FfiConverterTypeWireguardConnectionInfo.lift(buf)
}

public func FfiConverterTypeWireguardConnectionInfo_lower(_ value: WireguardConnectionInfo) -> RustBuffer {
    return FfiConverterTypeWireguardConnectionInfo.lower(value)
}


public struct WireguardNode {
    public var endpoint: SocketAddr
    public var publicKey: PublicKey
    public var privateIpv4: Ipv4Addr

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(endpoint: SocketAddr, publicKey: PublicKey, privateIpv4: Ipv4Addr) {
        self.endpoint = endpoint
        self.publicKey = publicKey
        self.privateIpv4 = privateIpv4
    }
}



extension WireguardNode: Equatable, Hashable {
    public static func ==(lhs: WireguardNode, rhs: WireguardNode) -> Bool {
        if lhs.endpoint != rhs.endpoint {
            return false
        }
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.privateIpv4 != rhs.privateIpv4 {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(endpoint)
        hasher.combine(publicKey)
        hasher.combine(privateIpv4)
    }
}


public struct FfiConverterTypeWireguardNode: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WireguardNode {
        return
            try WireguardNode(
                endpoint: FfiConverterTypeSocketAddr.read(from: &buf), 
                publicKey: FfiConverterTypePublicKey.read(from: &buf), 
                privateIpv4: FfiConverterTypeIpv4Addr.read(from: &buf)
        )
    }

    public static func write(_ value: WireguardNode, into buf: inout [UInt8]) {
        FfiConverterTypeSocketAddr.write(value.endpoint, into: &buf)
        FfiConverterTypePublicKey.write(value.publicKey, into: &buf)
        FfiConverterTypeIpv4Addr.write(value.privateIpv4, into: &buf)
    }
}


public func FfiConverterTypeWireguardNode_lift(_ buf: RustBuffer) throws -> WireguardNode {
    return try FfiConverterTypeWireguardNode.lift(buf)
}

public func FfiConverterTypeWireguardNode_lower(_ value: WireguardNode) -> RustBuffer {
    return FfiConverterTypeWireguardNode.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AccountRegistered {
    
    case registered
    case notRegistered
}


public struct FfiConverterTypeAccountRegistered: FfiConverterRustBuffer {
    typealias SwiftType = AccountRegistered

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountRegistered {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .registered
        
        case 2: return .notRegistered
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AccountRegistered, into buf: inout [UInt8]) {
        switch value {
        
        
        case .registered:
            writeInt(&buf, Int32(1))
        
        
        case .notRegistered:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeAccountRegistered_lift(_ buf: RustBuffer) throws -> AccountRegistered {
    return try FfiConverterTypeAccountRegistered.lift(buf)
}

public func FfiConverterTypeAccountRegistered_lower(_ value: AccountRegistered) -> RustBuffer {
    return FfiConverterTypeAccountRegistered.lower(value)
}



extension AccountRegistered: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AccountState {
    
    case inactive
    case active
    case deleteMe
}


public struct FfiConverterTypeAccountState: FfiConverterRustBuffer {
    typealias SwiftType = AccountState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .inactive
        
        case 2: return .active
        
        case 3: return .deleteMe
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AccountState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .inactive:
            writeInt(&buf, Int32(1))
        
        
        case .active:
            writeInt(&buf, Int32(2))
        
        
        case .deleteMe:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeAccountState_lift(_ buf: RustBuffer) throws -> AccountState {
    return try FfiConverterTypeAccountState.lift(buf)
}

public func FfiConverterTypeAccountState_lower(_ value: AccountState) -> RustBuffer {
    return FfiConverterTypeAccountState.lower(value)
}



extension AccountState: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Public enum describing action to perform after disconnect
 */

public enum ActionAfterDisconnect {
    
    /**
     * Do nothing after disconnect
     */
    case nothing
    /**
     * Reconnect after disconnect
     */
    case reconnect
    /**
     * Enter error state
     */
    case error
}


public struct FfiConverterTypeActionAfterDisconnect: FfiConverterRustBuffer {
    typealias SwiftType = ActionAfterDisconnect

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ActionAfterDisconnect {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .nothing
        
        case 2: return .reconnect
        
        case 3: return .error
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ActionAfterDisconnect, into buf: inout [UInt8]) {
        switch value {
        
        
        case .nothing:
            writeInt(&buf, Int32(1))
        
        
        case .reconnect:
            writeInt(&buf, Int32(2))
        
        
        case .error:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeActionAfterDisconnect_lift(_ buf: RustBuffer) throws -> ActionAfterDisconnect {
    return try FfiConverterTypeActionAfterDisconnect.lift(buf)
}

public func FfiConverterTypeActionAfterDisconnect_lower(_ value: ActionAfterDisconnect) -> RustBuffer {
    return FfiConverterTypeActionAfterDisconnect.lower(value)
}



extension ActionAfterDisconnect: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum BandwidthEvent {
    
    case noBandwidth
    case remainingBandwidth(Int64
    )
}


public struct FfiConverterTypeBandwidthEvent: FfiConverterRustBuffer {
    typealias SwiftType = BandwidthEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BandwidthEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .noBandwidth
        
        case 2: return .remainingBandwidth(try FfiConverterInt64.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BandwidthEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case .noBandwidth:
            writeInt(&buf, Int32(1))
        
        
        case let .remainingBandwidth(v1):
            writeInt(&buf, Int32(2))
            FfiConverterInt64.write(v1, into: &buf)
            
        }
    }
}


public func FfiConverterTypeBandwidthEvent_lift(_ buf: RustBuffer) throws -> BandwidthEvent {
    return try FfiConverterTypeBandwidthEvent.lift(buf)
}

public func FfiConverterTypeBandwidthEvent_lower(_ value: BandwidthEvent) -> RustBuffer {
    return FfiConverterTypeBandwidthEvent.lower(value)
}



extension BandwidthEvent: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum BandwidthStatus {
    
    case noBandwidth
    case remainingBandwidth(bandwidth: Int64
    )
}


public struct FfiConverterTypeBandwidthStatus: FfiConverterRustBuffer {
    typealias SwiftType = BandwidthStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BandwidthStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .noBandwidth
        
        case 2: return .remainingBandwidth(bandwidth: try FfiConverterInt64.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BandwidthStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .noBandwidth:
            writeInt(&buf, Int32(1))
        
        
        case let .remainingBandwidth(bandwidth):
            writeInt(&buf, Int32(2))
            FfiConverterInt64.write(bandwidth, into: &buf)
            
        }
    }
}


public func FfiConverterTypeBandwidthStatus_lift(_ buf: RustBuffer) throws -> BandwidthStatus {
    return try FfiConverterTypeBandwidthStatus.lift(buf)
}

public func FfiConverterTypeBandwidthStatus_lower(_ value: BandwidthStatus) -> RustBuffer {
    return FfiConverterTypeBandwidthStatus.lower(value)
}



extension BandwidthStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ConnectionEvent {
    
    case entryGatewayDown
    case exitGatewayDownIpv4
    case exitGatewayDownIpv6
    case exitGatewayRoutingErrorIpv4
    case exitGatewayRoutingErrorIpv6
    case connectedIpv4
    case connectedIpv6
}


public struct FfiConverterTypeConnectionEvent: FfiConverterRustBuffer {
    typealias SwiftType = ConnectionEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConnectionEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .entryGatewayDown
        
        case 2: return .exitGatewayDownIpv4
        
        case 3: return .exitGatewayDownIpv6
        
        case 4: return .exitGatewayRoutingErrorIpv4
        
        case 5: return .exitGatewayRoutingErrorIpv6
        
        case 6: return .connectedIpv4
        
        case 7: return .connectedIpv6
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ConnectionEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case .entryGatewayDown:
            writeInt(&buf, Int32(1))
        
        
        case .exitGatewayDownIpv4:
            writeInt(&buf, Int32(2))
        
        
        case .exitGatewayDownIpv6:
            writeInt(&buf, Int32(3))
        
        
        case .exitGatewayRoutingErrorIpv4:
            writeInt(&buf, Int32(4))
        
        
        case .exitGatewayRoutingErrorIpv6:
            writeInt(&buf, Int32(5))
        
        
        case .connectedIpv4:
            writeInt(&buf, Int32(6))
        
        
        case .connectedIpv6:
            writeInt(&buf, Int32(7))
        
        }
    }
}


public func FfiConverterTypeConnectionEvent_lift(_ buf: RustBuffer) throws -> ConnectionEvent {
    return try FfiConverterTypeConnectionEvent.lift(buf)
}

public func FfiConverterTypeConnectionEvent_lower(_ value: ConnectionEvent) -> RustBuffer {
    return FfiConverterTypeConnectionEvent.lower(value)
}



extension ConnectionEvent: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ConnectionStatus {
    
    case entryGatewayDown
    case exitGatewayDownIpv4
    case exitGatewayDownIpv6
    case exitGatewayRoutingErrorIpv4
    case exitGatewayRoutingErrorIpv6
    case connectedIpv4
    case connectedIpv6
}


public struct FfiConverterTypeConnectionStatus: FfiConverterRustBuffer {
    typealias SwiftType = ConnectionStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConnectionStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .entryGatewayDown
        
        case 2: return .exitGatewayDownIpv4
        
        case 3: return .exitGatewayDownIpv6
        
        case 4: return .exitGatewayRoutingErrorIpv4
        
        case 5: return .exitGatewayRoutingErrorIpv6
        
        case 6: return .connectedIpv4
        
        case 7: return .connectedIpv6
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ConnectionStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .entryGatewayDown:
            writeInt(&buf, Int32(1))
        
        
        case .exitGatewayDownIpv4:
            writeInt(&buf, Int32(2))
        
        
        case .exitGatewayDownIpv6:
            writeInt(&buf, Int32(3))
        
        
        case .exitGatewayRoutingErrorIpv4:
            writeInt(&buf, Int32(4))
        
        
        case .exitGatewayRoutingErrorIpv6:
            writeInt(&buf, Int32(5))
        
        
        case .connectedIpv4:
            writeInt(&buf, Int32(6))
        
        
        case .connectedIpv6:
            writeInt(&buf, Int32(7))
        
        }
    }
}


public func FfiConverterTypeConnectionStatus_lift(_ buf: RustBuffer) throws -> ConnectionStatus {
    return try FfiConverterTypeConnectionStatus.lift(buf)
}

public func FfiConverterTypeConnectionStatus_lower(_ value: ConnectionStatus) -> RustBuffer {
    return FfiConverterTypeConnectionStatus.lower(value)
}



extension ConnectionStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DeviceRegistration {
    
    case inProgress
    case success
    case failed(message: String, messageId: String?
    )
}


public struct FfiConverterTypeDeviceRegistration: FfiConverterRustBuffer {
    typealias SwiftType = DeviceRegistration

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeviceRegistration {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .inProgress
        
        case 2: return .success
        
        case 3: return .failed(message: try FfiConverterString.read(from: &buf), messageId: try FfiConverterOptionString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DeviceRegistration, into buf: inout [UInt8]) {
        switch value {
        
        
        case .inProgress:
            writeInt(&buf, Int32(1))
        
        
        case .success:
            writeInt(&buf, Int32(2))
        
        
        case let .failed(message,messageId):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(message, into: &buf)
            FfiConverterOptionString.write(messageId, into: &buf)
            
        }
    }
}


public func FfiConverterTypeDeviceRegistration_lift(_ buf: RustBuffer) throws -> DeviceRegistration {
    return try FfiConverterTypeDeviceRegistration.lift(buf)
}

public func FfiConverterTypeDeviceRegistration_lower(_ value: DeviceRegistration) -> RustBuffer {
    return FfiConverterTypeDeviceRegistration.lower(value)
}



extension DeviceRegistration: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DeviceState {
    
    case notRegistered
    case inactive
    case active
    case deleteMe
}


public struct FfiConverterTypeDeviceState: FfiConverterRustBuffer {
    typealias SwiftType = DeviceState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeviceState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .notRegistered
        
        case 2: return .inactive
        
        case 3: return .active
        
        case 4: return .deleteMe
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DeviceState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .notRegistered:
            writeInt(&buf, Int32(1))
        
        
        case .inactive:
            writeInt(&buf, Int32(2))
        
        
        case .active:
            writeInt(&buf, Int32(3))
        
        
        case .deleteMe:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeDeviceState_lift(_ buf: RustBuffer) throws -> DeviceState {
    return try FfiConverterTypeDeviceState.lift(buf)
}

public func FfiConverterTypeDeviceState_lower(_ value: DeviceState) -> RustBuffer {
    return FfiConverterTypeDeviceState.lower(value)
}



extension DeviceState: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum EntryPoint {
    
    case gateway(identity: NodeIdentity
    )
    case location(location: String
    )
    case randomLowLatency
    case random
}


public struct FfiConverterTypeEntryPoint: FfiConverterRustBuffer {
    typealias SwiftType = EntryPoint

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EntryPoint {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .gateway(identity: try FfiConverterTypeNodeIdentity.read(from: &buf)
        )
        
        case 2: return .location(location: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .randomLowLatency
        
        case 4: return .random
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EntryPoint, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .gateway(identity):
            writeInt(&buf, Int32(1))
            FfiConverterTypeNodeIdentity.write(identity, into: &buf)
            
        
        case let .location(location):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(location, into: &buf)
            
        
        case .randomLowLatency:
            writeInt(&buf, Int32(3))
        
        
        case .random:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeEntryPoint_lift(_ buf: RustBuffer) throws -> EntryPoint {
    return try FfiConverterTypeEntryPoint.lift(buf)
}

public func FfiConverterTypeEntryPoint_lower(_ value: EntryPoint) -> RustBuffer {
    return FfiConverterTypeEntryPoint.lower(value)
}



extension EntryPoint: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ErrorStateReason {
    
    /**
     * Issues related to firewall configuration.
     */
    case firewall
    /**
     * Failure to configure routing.
     */
    case routing
    /**
     * Failure to configure dns.
     */
    case dns
    /**
     * Failure to configure tunnel device.
     */
    case tunDevice
    /**
     * Failure to configure packet tunnel provider.
     */
    case tunnelProvider
    /**
     * Same entry and exit gateway are unsupported.
     */
    case sameEntryAndExitGateway
    /**
     * Invalid country set for entry gateway
     */
    case invalidEntryGatewayCountry
    /**
     * Invalid country set for exit gateway
     */
    case invalidExitGatewayCountry
    /**
     * Gateway is not responding or responding badly to a bandwidth
     * increase request, causing credential waste
     */
    case badBandwidthIncrease
    /**
     * Program errors that must not happen.
     */
    case `internal`
}


public struct FfiConverterTypeErrorStateReason: FfiConverterRustBuffer {
    typealias SwiftType = ErrorStateReason

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ErrorStateReason {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .firewall
        
        case 2: return .routing
        
        case 3: return .dns
        
        case 4: return .tunDevice
        
        case 5: return .tunnelProvider
        
        case 6: return .sameEntryAndExitGateway
        
        case 7: return .invalidEntryGatewayCountry
        
        case 8: return .invalidExitGatewayCountry
        
        case 9: return .badBandwidthIncrease
        
        case 10: return .`internal`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ErrorStateReason, into buf: inout [UInt8]) {
        switch value {
        
        
        case .firewall:
            writeInt(&buf, Int32(1))
        
        
        case .routing:
            writeInt(&buf, Int32(2))
        
        
        case .dns:
            writeInt(&buf, Int32(3))
        
        
        case .tunDevice:
            writeInt(&buf, Int32(4))
        
        
        case .tunnelProvider:
            writeInt(&buf, Int32(5))
        
        
        case .sameEntryAndExitGateway:
            writeInt(&buf, Int32(6))
        
        
        case .invalidEntryGatewayCountry:
            writeInt(&buf, Int32(7))
        
        
        case .invalidExitGatewayCountry:
            writeInt(&buf, Int32(8))
        
        
        case .badBandwidthIncrease:
            writeInt(&buf, Int32(9))
        
        
        case .`internal`:
            writeInt(&buf, Int32(10))
        
        }
    }
}


public func FfiConverterTypeErrorStateReason_lift(_ buf: RustBuffer) throws -> ErrorStateReason {
    return try FfiConverterTypeErrorStateReason.lift(buf)
}

public func FfiConverterTypeErrorStateReason_lower(_ value: ErrorStateReason) -> RustBuffer {
    return FfiConverterTypeErrorStateReason.lower(value)
}



extension ErrorStateReason: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ExitPoint {
    
    case address(address: Recipient
    )
    case gateway(identity: NodeIdentity
    )
    case location(location: String
    )
}


public struct FfiConverterTypeExitPoint: FfiConverterRustBuffer {
    typealias SwiftType = ExitPoint

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExitPoint {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .address(address: try FfiConverterTypeRecipient.read(from: &buf)
        )
        
        case 2: return .gateway(identity: try FfiConverterTypeNodeIdentity.read(from: &buf)
        )
        
        case 3: return .location(location: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ExitPoint, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .address(address):
            writeInt(&buf, Int32(1))
            FfiConverterTypeRecipient.write(address, into: &buf)
            
        
        case let .gateway(identity):
            writeInt(&buf, Int32(2))
            FfiConverterTypeNodeIdentity.write(identity, into: &buf)
            
        
        case let .location(location):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(location, into: &buf)
            
        }
    }
}


public func FfiConverterTypeExitPoint_lift(_ buf: RustBuffer) throws -> ExitPoint {
    return try FfiConverterTypeExitPoint.lift(buf)
}

public func FfiConverterTypeExitPoint_lower(_ value: ExitPoint) -> RustBuffer {
    return FfiConverterTypeExitPoint.lower(value)
}



extension ExitPoint: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ExitStatus {
    
    case failure(error: VpnError
    )
    case stopped
}


public struct FfiConverterTypeExitStatus: FfiConverterRustBuffer {
    typealias SwiftType = ExitStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExitStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .failure(error: try FfiConverterTypeVpnError.read(from: &buf)
        )
        
        case 2: return .stopped
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ExitStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .failure(error):
            writeInt(&buf, Int32(1))
            FfiConverterTypeVpnError.write(error, into: &buf)
            
        
        case .stopped:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeExitStatus_lift(_ buf: RustBuffer) throws -> ExitStatus {
    return try FfiConverterTypeExitStatus.lift(buf)
}

public func FfiConverterTypeExitStatus_lower(_ value: ExitStatus) -> RustBuffer {
    return FfiConverterTypeExitStatus.lower(value)
}



extension ExitStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FlagValue {
    
    case value(String
    )
    case group([String: String]
    )
}


public struct FfiConverterTypeFlagValue: FfiConverterRustBuffer {
    typealias SwiftType = FlagValue

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FlagValue {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .value(try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .group(try FfiConverterDictionaryStringString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FlagValue, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .value(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .group(v1):
            writeInt(&buf, Int32(2))
            FfiConverterDictionaryStringString.write(v1, into: &buf)
            
        }
    }
}


public func FfiConverterTypeFlagValue_lift(_ buf: RustBuffer) throws -> FlagValue {
    return try FfiConverterTypeFlagValue.lift(buf)
}

public func FfiConverterTypeFlagValue_lower(_ value: FlagValue) -> RustBuffer {
    return FfiConverterTypeFlagValue.lower(value)
}



extension FlagValue: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum GatewayType {
    
    case mixnetEntry
    case mixnetExit
    case wg
}


public struct FfiConverterTypeGatewayType: FfiConverterRustBuffer {
    typealias SwiftType = GatewayType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GatewayType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .mixnetEntry
        
        case 2: return .mixnetExit
        
        case 3: return .wg
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: GatewayType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .mixnetEntry:
            writeInt(&buf, Int32(1))
        
        
        case .mixnetExit:
            writeInt(&buf, Int32(2))
        
        
        case .wg:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeGatewayType_lift(_ buf: RustBuffer) throws -> GatewayType {
    return try FfiConverterTypeGatewayType.lift(buf)
}

public func FfiConverterTypeGatewayType_lower(_ value: GatewayType) -> RustBuffer {
    return FfiConverterTypeGatewayType.lower(value)
}



extension GatewayType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Ipv4Route {
    
    /**
     * Default IPv4 route (0.0.0.0/0)
     */
    case `default`
    /**
     * Individual IPv4 route
     */
    case specific(destination: Ipv4Addr, subnetMask: Ipv4Addr, gateway: Ipv4Addr?
    )
}


public struct FfiConverterTypeIpv4Route: FfiConverterRustBuffer {
    typealias SwiftType = Ipv4Route

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Ipv4Route {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`default`
        
        case 2: return .specific(destination: try FfiConverterTypeIpv4Addr.read(from: &buf), subnetMask: try FfiConverterTypeIpv4Addr.read(from: &buf), gateway: try FfiConverterOptionTypeIpv4Addr.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Ipv4Route, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`default`:
            writeInt(&buf, Int32(1))
        
        
        case let .specific(destination,subnetMask,gateway):
            writeInt(&buf, Int32(2))
            FfiConverterTypeIpv4Addr.write(destination, into: &buf)
            FfiConverterTypeIpv4Addr.write(subnetMask, into: &buf)
            FfiConverterOptionTypeIpv4Addr.write(gateway, into: &buf)
            
        }
    }
}


public func FfiConverterTypeIpv4Route_lift(_ buf: RustBuffer) throws -> Ipv4Route {
    return try FfiConverterTypeIpv4Route.lift(buf)
}

public func FfiConverterTypeIpv4Route_lower(_ value: Ipv4Route) -> RustBuffer {
    return FfiConverterTypeIpv4Route.lower(value)
}



extension Ipv4Route: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Ipv6Route {
    
    /**
     * Default IPv6 route (::/0)
     */
    case `default`
    /**
     * Individual IPv6 route
     */
    case specific(destination: Ipv6Addr, prefixLength: UInt8, gateway: Ipv6Addr?
    )
}


public struct FfiConverterTypeIpv6Route: FfiConverterRustBuffer {
    typealias SwiftType = Ipv6Route

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Ipv6Route {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`default`
        
        case 2: return .specific(destination: try FfiConverterTypeIpv6Addr.read(from: &buf), prefixLength: try FfiConverterUInt8.read(from: &buf), gateway: try FfiConverterOptionTypeIpv6Addr.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Ipv6Route, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`default`:
            writeInt(&buf, Int32(1))
        
        
        case let .specific(destination,prefixLength,gateway):
            writeInt(&buf, Int32(2))
            FfiConverterTypeIpv6Addr.write(destination, into: &buf)
            FfiConverterUInt8.write(prefixLength, into: &buf)
            FfiConverterOptionTypeIpv6Addr.write(gateway, into: &buf)
            
        }
    }
}


public func FfiConverterTypeIpv6Route_lift(_ buf: RustBuffer) throws -> Ipv6Route {
    return try FfiConverterTypeIpv6Route.lift(buf)
}

public func FfiConverterTypeIpv6Route_lower(_ value: Ipv6Route) -> RustBuffer {
    return FfiConverterTypeIpv6Route.lower(value)
}



extension Ipv6Route: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MixnetEvent {
    
    case bandwidth(BandwidthEvent
    )
    case connection(ConnectionEvent
    )
}


public struct FfiConverterTypeMixnetEvent: FfiConverterRustBuffer {
    typealias SwiftType = MixnetEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MixnetEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bandwidth(try FfiConverterTypeBandwidthEvent.read(from: &buf)
        )
        
        case 2: return .connection(try FfiConverterTypeConnectionEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MixnetEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .bandwidth(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeBandwidthEvent.write(v1, into: &buf)
            
        
        case let .connection(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeConnectionEvent.write(v1, into: &buf)
            
        }
    }
}


public func FfiConverterTypeMixnetEvent_lift(_ buf: RustBuffer) throws -> MixnetEvent {
    return try FfiConverterTypeMixnetEvent.lift(buf)
}

public func FfiConverterTypeMixnetEvent_lower(_ value: MixnetEvent) -> RustBuffer {
    return FfiConverterTypeMixnetEvent.lower(value)
}



extension MixnetEvent: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MnemonicState {
    
    case notStored
    case stored
}


public struct FfiConverterTypeMnemonicState: FfiConverterRustBuffer {
    typealias SwiftType = MnemonicState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MnemonicState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .notStored
        
        case 2: return .stored
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MnemonicState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .notStored:
            writeInt(&buf, Int32(1))
        
        
        case .stored:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeMnemonicState_lift(_ buf: RustBuffer) throws -> MnemonicState {
    return try FfiConverterTypeMnemonicState.lift(buf)
}

public func FfiConverterTypeMnemonicState_lower(_ value: MnemonicState) -> RustBuffer {
    return FfiConverterTypeMnemonicState.lower(value)
}



extension MnemonicState: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NymVpnStatus {
    
    case mixConnectInfo(mixConnectionInfo: MixConnectionInfo, mixExitConnectionInfo: MixExitConnectionInfo
    )
    case wgConnectInfo(entryConnectionInfo: WireguardConnectionInfo, exitConnectionInfo: WireguardConnectionInfo
    )
}


public struct FfiConverterTypeNymVpnStatus: FfiConverterRustBuffer {
    typealias SwiftType = NymVpnStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NymVpnStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .mixConnectInfo(mixConnectionInfo: try FfiConverterTypeMixConnectionInfo.read(from: &buf), mixExitConnectionInfo: try FfiConverterTypeMixExitConnectionInfo.read(from: &buf)
        )
        
        case 2: return .wgConnectInfo(entryConnectionInfo: try FfiConverterTypeWireguardConnectionInfo.read(from: &buf), exitConnectionInfo: try FfiConverterTypeWireguardConnectionInfo.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NymVpnStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .mixConnectInfo(mixConnectionInfo,mixExitConnectionInfo):
            writeInt(&buf, Int32(1))
            FfiConverterTypeMixConnectionInfo.write(mixConnectionInfo, into: &buf)
            FfiConverterTypeMixExitConnectionInfo.write(mixExitConnectionInfo, into: &buf)
            
        
        case let .wgConnectInfo(entryConnectionInfo,exitConnectionInfo):
            writeInt(&buf, Int32(2))
            FfiConverterTypeWireguardConnectionInfo.write(entryConnectionInfo, into: &buf)
            FfiConverterTypeWireguardConnectionInfo.write(exitConnectionInfo, into: &buf)
            
        }
    }
}


public func FfiConverterTypeNymVpnStatus_lift(_ buf: RustBuffer) throws -> NymVpnStatus {
    return try FfiConverterTypeNymVpnStatus.lift(buf)
}

public func FfiConverterTypeNymVpnStatus_lower(_ value: NymVpnStatus) -> RustBuffer {
    return FfiConverterTypeNymVpnStatus.lower(value)
}



extension NymVpnStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum OsPathStatus {
    
    /**
     * The path cannot be evaluated.
     */
    case invalid
    /**
     * The path is ready to be used for network connections.
     */
    case satisfied
    /**
     * The path for network connections is not available, either due to lack of network
     * connectivity or being prohibited by system policy.
     */
    case unsatisfied
    /**
     * The path is not currently satisfied, but may become satisfied upon a connection attempt.
     * This can be due to a service, such as a VPN or a cellular data connection not being activated.
     */
    case satisfiable
    /**
     * Unknown path status was received.
     * The raw variant code is contained in associated value.
     */
    case unknown(Int64
    )
}


public struct FfiConverterTypeOSPathStatus: FfiConverterRustBuffer {
    typealias SwiftType = OsPathStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OsPathStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .invalid
        
        case 2: return .satisfied
        
        case 3: return .unsatisfied
        
        case 4: return .satisfiable
        
        case 5: return .unknown(try FfiConverterInt64.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: OsPathStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .invalid:
            writeInt(&buf, Int32(1))
        
        
        case .satisfied:
            writeInt(&buf, Int32(2))
        
        
        case .unsatisfied:
            writeInt(&buf, Int32(3))
        
        
        case .satisfiable:
            writeInt(&buf, Int32(4))
        
        
        case let .unknown(v1):
            writeInt(&buf, Int32(5))
            FfiConverterInt64.write(v1, into: &buf)
            
        }
    }
}


public func FfiConverterTypeOSPathStatus_lift(_ buf: RustBuffer) throws -> OsPathStatus {
    return try FfiConverterTypeOSPathStatus.lift(buf)
}

public func FfiConverterTypeOSPathStatus_lower(_ value: OsPathStatus) -> RustBuffer {
    return FfiConverterTypeOSPathStatus.lower(value)
}



extension OsPathStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SubscriptionState {
    
    case notActive
    case pending
    case complete
    case active
}


public struct FfiConverterTypeSubscriptionState: FfiConverterRustBuffer {
    typealias SwiftType = SubscriptionState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SubscriptionState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .notActive
        
        case 2: return .pending
        
        case 3: return .complete
        
        case 4: return .active
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SubscriptionState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .notActive:
            writeInt(&buf, Int32(1))
        
        
        case .pending:
            writeInt(&buf, Int32(2))
        
        
        case .complete:
            writeInt(&buf, Int32(3))
        
        
        case .active:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeSubscriptionState_lift(_ buf: RustBuffer) throws -> SubscriptionState {
    return try FfiConverterTypeSubscriptionState.lift(buf)
}

public func FfiConverterTypeSubscriptionState_lower(_ value: SubscriptionState) -> RustBuffer {
    return FfiConverterTypeSubscriptionState.lower(value)
}



extension SubscriptionState: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum TunStatus {
    
    case up
    case down
    case initializingClient
    case establishingConnection
    case disconnecting
}


public struct FfiConverterTypeTunStatus: FfiConverterRustBuffer {
    typealias SwiftType = TunStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TunStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .up
        
        case 2: return .down
        
        case 3: return .initializingClient
        
        case 4: return .establishingConnection
        
        case 5: return .disconnecting
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TunStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .up:
            writeInt(&buf, Int32(1))
        
        
        case .down:
            writeInt(&buf, Int32(2))
        
        
        case .initializingClient:
            writeInt(&buf, Int32(3))
        
        
        case .establishingConnection:
            writeInt(&buf, Int32(4))
        
        
        case .disconnecting:
            writeInt(&buf, Int32(5))
        
        }
    }
}


public func FfiConverterTypeTunStatus_lift(_ buf: RustBuffer) throws -> TunStatus {
    return try FfiConverterTypeTunStatus.lift(buf)
}

public func FfiConverterTypeTunStatus_lower(_ value: TunStatus) -> RustBuffer {
    return FfiConverterTypeTunStatus.lower(value)
}



extension TunStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum TunnelConnectionData {
    
    case mixnet(MixnetConnectionData
    )
    case wireguard(WireguardConnectionData
    )
}


public struct FfiConverterTypeTunnelConnectionData: FfiConverterRustBuffer {
    typealias SwiftType = TunnelConnectionData

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TunnelConnectionData {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .mixnet(try FfiConverterTypeMixnetConnectionData.read(from: &buf)
        )
        
        case 2: return .wireguard(try FfiConverterTypeWireguardConnectionData.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TunnelConnectionData, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .mixnet(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeMixnetConnectionData.write(v1, into: &buf)
            
        
        case let .wireguard(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeWireguardConnectionData.write(v1, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTunnelConnectionData_lift(_ buf: RustBuffer) throws -> TunnelConnectionData {
    return try FfiConverterTypeTunnelConnectionData.lift(buf)
}

public func FfiConverterTypeTunnelConnectionData_lower(_ value: TunnelConnectionData) -> RustBuffer {
    return FfiConverterTypeTunnelConnectionData.lower(value)
}



extension TunnelConnectionData: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum TunnelEvent {
    
    case newState(TunnelState
    )
    case mixnetState(MixnetEvent
    )
}


public struct FfiConverterTypeTunnelEvent: FfiConverterRustBuffer {
    typealias SwiftType = TunnelEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TunnelEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .newState(try FfiConverterTypeTunnelState.read(from: &buf)
        )
        
        case 2: return .mixnetState(try FfiConverterTypeMixnetEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TunnelEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .newState(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTunnelState.write(v1, into: &buf)
            
        
        case let .mixnetState(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeMixnetEvent.write(v1, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTunnelEvent_lift(_ buf: RustBuffer) throws -> TunnelEvent {
    return try FfiConverterTypeTunnelEvent.lift(buf)
}

public func FfiConverterTypeTunnelEvent_lower(_ value: TunnelEvent) -> RustBuffer {
    return FfiConverterTypeTunnelEvent.lower(value)
}



extension TunnelEvent: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Public enum describing the tunnel state
 */

public enum TunnelState {
    
    case disconnected
    case connecting(connectionData: ConnectionData?
    )
    case connected(connectionData: ConnectionData
    )
    case disconnecting(afterDisconnect: ActionAfterDisconnect
    )
    case error(ErrorStateReason
    )
}


public struct FfiConverterTypeTunnelState: FfiConverterRustBuffer {
    typealias SwiftType = TunnelState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TunnelState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .disconnected
        
        case 2: return .connecting(connectionData: try FfiConverterOptionTypeConnectionData.read(from: &buf)
        )
        
        case 3: return .connected(connectionData: try FfiConverterTypeConnectionData.read(from: &buf)
        )
        
        case 4: return .disconnecting(afterDisconnect: try FfiConverterTypeActionAfterDisconnect.read(from: &buf)
        )
        
        case 5: return .error(try FfiConverterTypeErrorStateReason.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TunnelState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .disconnected:
            writeInt(&buf, Int32(1))
        
        
        case let .connecting(connectionData):
            writeInt(&buf, Int32(2))
            FfiConverterOptionTypeConnectionData.write(connectionData, into: &buf)
            
        
        case let .connected(connectionData):
            writeInt(&buf, Int32(3))
            FfiConverterTypeConnectionData.write(connectionData, into: &buf)
            
        
        case let .disconnecting(afterDisconnect):
            writeInt(&buf, Int32(4))
            FfiConverterTypeActionAfterDisconnect.write(afterDisconnect, into: &buf)
            
        
        case let .error(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeErrorStateReason.write(v1, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTunnelState_lift(_ buf: RustBuffer) throws -> TunnelState {
    return try FfiConverterTypeTunnelState.lift(buf)
}

public func FfiConverterTypeTunnelState_lower(_ value: TunnelState) -> RustBuffer {
    return FfiConverterTypeTunnelState.lower(value)
}



extension TunnelState: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum TunnelType {
    
    case mixnet
    case wireguard
}


public struct FfiConverterTypeTunnelType: FfiConverterRustBuffer {
    typealias SwiftType = TunnelType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TunnelType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .mixnet
        
        case 2: return .wireguard
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TunnelType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .mixnet:
            writeInt(&buf, Int32(1))
        
        
        case .wireguard:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeTunnelType_lift(_ buf: RustBuffer) throws -> TunnelType {
    return try FfiConverterTypeTunnelType.lift(buf)
}

public func FfiConverterTypeTunnelType_lower(_ value: TunnelType) -> RustBuffer {
    return FfiConverterTypeTunnelType.lower(value)
}



extension TunnelType: Equatable, Hashable {}




public enum VpnError {

    
    
    case InternalError(details: String
    )
    case NetworkConnectionError(details: String
    )
    case GatewayError(details: String
    )
    case InvalidCredential(details: String
    )
    case OutOfBandwidth
    case InvalidStateError(details: String
    )
    case AccountReady
    case NoAccountStored
    case AccountNotSynced
    case AccountNotRegistered
    case AccountNotActive
    case NoActiveSubscription
    case AccountDeviceNotRegistered
    case AccountDeviceNotActive
    case NoDeviceIdentity
    case VpnApiTimeout
    case AccountUpdateFailed(details: String, messageId: String?, codeReferenceId: String?
    )
    case DeviceUpdateFailed(details: String, messageId: String?, codeReferenceId: String?
    )
    case DeviceRegistrationFailed(details: String, messageId: String?, codeReferenceId: String?
    )
    case InvalidAccountStoragePath(details: String
    )
}


public struct FfiConverterTypeVpnError: FfiConverterRustBuffer {
    typealias SwiftType = VpnError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VpnError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InternalError(
            details: try FfiConverterString.read(from: &buf)
            )
        case 2: return .NetworkConnectionError(
            details: try FfiConverterString.read(from: &buf)
            )
        case 3: return .GatewayError(
            details: try FfiConverterString.read(from: &buf)
            )
        case 4: return .InvalidCredential(
            details: try FfiConverterString.read(from: &buf)
            )
        case 5: return .OutOfBandwidth
        case 6: return .InvalidStateError(
            details: try FfiConverterString.read(from: &buf)
            )
        case 7: return .AccountReady
        case 8: return .NoAccountStored
        case 9: return .AccountNotSynced
        case 10: return .AccountNotRegistered
        case 11: return .AccountNotActive
        case 12: return .NoActiveSubscription
        case 13: return .AccountDeviceNotRegistered
        case 14: return .AccountDeviceNotActive
        case 15: return .NoDeviceIdentity
        case 16: return .VpnApiTimeout
        case 17: return .AccountUpdateFailed(
            details: try FfiConverterString.read(from: &buf), 
            messageId: try FfiConverterOptionString.read(from: &buf), 
            codeReferenceId: try FfiConverterOptionString.read(from: &buf)
            )
        case 18: return .DeviceUpdateFailed(
            details: try FfiConverterString.read(from: &buf), 
            messageId: try FfiConverterOptionString.read(from: &buf), 
            codeReferenceId: try FfiConverterOptionString.read(from: &buf)
            )
        case 19: return .DeviceRegistrationFailed(
            details: try FfiConverterString.read(from: &buf), 
            messageId: try FfiConverterOptionString.read(from: &buf), 
            codeReferenceId: try FfiConverterOptionString.read(from: &buf)
            )
        case 20: return .InvalidAccountStoragePath(
            details: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VpnError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .InternalError(details):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(details, into: &buf)
            
        
        case let .NetworkConnectionError(details):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(details, into: &buf)
            
        
        case let .GatewayError(details):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(details, into: &buf)
            
        
        case let .InvalidCredential(details):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(details, into: &buf)
            
        
        case .OutOfBandwidth:
            writeInt(&buf, Int32(5))
        
        
        case let .InvalidStateError(details):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(details, into: &buf)
            
        
        case .AccountReady:
            writeInt(&buf, Int32(7))
        
        
        case .NoAccountStored:
            writeInt(&buf, Int32(8))
        
        
        case .AccountNotSynced:
            writeInt(&buf, Int32(9))
        
        
        case .AccountNotRegistered:
            writeInt(&buf, Int32(10))
        
        
        case .AccountNotActive:
            writeInt(&buf, Int32(11))
        
        
        case .NoActiveSubscription:
            writeInt(&buf, Int32(12))
        
        
        case .AccountDeviceNotRegistered:
            writeInt(&buf, Int32(13))
        
        
        case .AccountDeviceNotActive:
            writeInt(&buf, Int32(14))
        
        
        case .NoDeviceIdentity:
            writeInt(&buf, Int32(15))
        
        
        case .VpnApiTimeout:
            writeInt(&buf, Int32(16))
        
        
        case let .AccountUpdateFailed(details,messageId,codeReferenceId):
            writeInt(&buf, Int32(17))
            FfiConverterString.write(details, into: &buf)
            FfiConverterOptionString.write(messageId, into: &buf)
            FfiConverterOptionString.write(codeReferenceId, into: &buf)
            
        
        case let .DeviceUpdateFailed(details,messageId,codeReferenceId):
            writeInt(&buf, Int32(18))
            FfiConverterString.write(details, into: &buf)
            FfiConverterOptionString.write(messageId, into: &buf)
            FfiConverterOptionString.write(codeReferenceId, into: &buf)
            
        
        case let .DeviceRegistrationFailed(details,messageId,codeReferenceId):
            writeInt(&buf, Int32(19))
            FfiConverterString.write(details, into: &buf)
            FfiConverterOptionString.write(messageId, into: &buf)
            FfiConverterOptionString.write(codeReferenceId, into: &buf)
            
        
        case let .InvalidAccountStoragePath(details):
            writeInt(&buf, Int32(20))
            FfiConverterString.write(details, into: &buf)
            
        }
    }
}


extension VpnError: Equatable, Hashable {}

extension VpnError: Error { }

fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionDouble: FfiConverterRustBuffer {
    typealias SwiftType = Double?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDouble.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDouble.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeOSDefaultPathObserver: FfiConverterRustBuffer {
    typealias SwiftType = OsDefaultPathObserver?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeOSDefaultPathObserver.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeOSDefaultPathObserver.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeTunnelStatusListener: FfiConverterRustBuffer {
    typealias SwiftType = TunnelStatusListener?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTunnelStatusListener.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTunnelStatusListener.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeAccountSummary: FfiConverterRustBuffer {
    typealias SwiftType = AccountSummary?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAccountSummary.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAccountSummary.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeConnectionData: FfiConverterRustBuffer {
    typealias SwiftType = ConnectionData?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeConnectionData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeConnectionData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeDnsSettings: FfiConverterRustBuffer {
    typealias SwiftType = DnsSettings?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDnsSettings.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDnsSettings.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeFeatureFlags: FfiConverterRustBuffer {
    typealias SwiftType = FeatureFlags?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFeatureFlags.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFeatureFlags.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeGatewayMinPerformance: FfiConverterRustBuffer {
    typealias SwiftType = GatewayMinPerformance?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeGatewayMinPerformance.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeGatewayMinPerformance.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeIpv4Settings: FfiConverterRustBuffer {
    typealias SwiftType = Ipv4Settings?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeIpv4Settings.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeIpv4Settings.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeIpv6Settings: FfiConverterRustBuffer {
    typealias SwiftType = Ipv6Settings?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeIpv6Settings.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeIpv6Settings.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeUserAgent: FfiConverterRustBuffer {
    typealias SwiftType = UserAgent?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUserAgent.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUserAgent.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeAccountRegistered: FfiConverterRustBuffer {
    typealias SwiftType = AccountRegistered?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAccountRegistered.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAccountRegistered.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeDeviceRegistration: FfiConverterRustBuffer {
    typealias SwiftType = DeviceRegistration?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDeviceRegistration.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDeviceRegistration.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeDeviceState: FfiConverterRustBuffer {
    typealias SwiftType = DeviceState?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDeviceState.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDeviceState.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeMnemonicState: FfiConverterRustBuffer {
    typealias SwiftType = MnemonicState?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMnemonicState.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMnemonicState.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeIpv4Route: FfiConverterRustBuffer {
    typealias SwiftType = [Ipv4Route]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeIpv4Route.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeIpv4Route.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeIpv6Route: FfiConverterRustBuffer {
    typealias SwiftType = [Ipv6Route]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeIpv6Route.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeIpv6Route.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeIpv4Addr: FfiConverterRustBuffer {
    typealias SwiftType = Ipv4Addr?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeIpv4Addr.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeIpv4Addr.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeIpv6Addr: FfiConverterRustBuffer {
    typealias SwiftType = Ipv6Addr?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeIpv6Addr.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeIpv6Addr.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeOffsetDateTime: FfiConverterRustBuffer {
    typealias SwiftType = OffsetDateTime?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeOffsetDateTime.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeOffsetDateTime.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePathBuf: FfiConverterRustBuffer {
    typealias SwiftType = PathBuf?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePathBuf.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePathBuf.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeLocation: FfiConverterRustBuffer {
    typealias SwiftType = [Location]

    public static func write(_ value: [Location], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLocation.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Location] {
        let len: Int32 = try readInt(&buf)
        var seq = [Location]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLocation.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSystemMessage: FfiConverterRustBuffer {
    typealias SwiftType = [SystemMessage]

    public static func write(_ value: [SystemMessage], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSystemMessage.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SystemMessage] {
        let len: Int32 = try readInt(&buf)
        var seq = [SystemMessage]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSystemMessage.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeValidatorDetails: FfiConverterRustBuffer {
    typealias SwiftType = [ValidatorDetails]

    public static func write(_ value: [ValidatorDetails], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeValidatorDetails.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ValidatorDetails] {
        let len: Int32 = try readInt(&buf)
        var seq = [ValidatorDetails]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeValidatorDetails.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeIpv4Route: FfiConverterRustBuffer {
    typealias SwiftType = [Ipv4Route]

    public static func write(_ value: [Ipv4Route], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeIpv4Route.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Ipv4Route] {
        let len: Int32 = try readInt(&buf)
        var seq = [Ipv4Route]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeIpv4Route.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeIpv6Route: FfiConverterRustBuffer {
    typealias SwiftType = [Ipv6Route]

    public static func write(_ value: [Ipv6Route], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeIpv6Route.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Ipv6Route] {
        let len: Int32 = try readInt(&buf)
        var seq = [Ipv6Route]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeIpv6Route.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeIpAddr: FfiConverterRustBuffer {
    typealias SwiftType = [IpAddr]

    public static func write(_ value: [IpAddr], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeIpAddr.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [IpAddr] {
        let len: Int32 = try readInt(&buf)
        var seq = [IpAddr]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeIpAddr.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeIpv4Network: FfiConverterRustBuffer {
    typealias SwiftType = [Ipv4Network]

    public static func write(_ value: [Ipv4Network], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeIpv4Network.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Ipv4Network] {
        let len: Int32 = try readInt(&buf)
        var seq = [Ipv4Network]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeIpv4Network.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeIpv6Network: FfiConverterRustBuffer {
    typealias SwiftType = [Ipv6Network]

    public static func write(_ value: [Ipv6Network], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeIpv6Network.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Ipv6Network] {
        let len: Int32 = try readInt(&buf)
        var seq = [Ipv6Network]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeIpv6Network.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringTypeFlagValue: FfiConverterRustBuffer {
    public static func write(_ value: [String: FlagValue], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeFlagValue.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: FlagValue] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: FlagValue]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeFlagValue.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}


/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias BoxedNodeIdentity = String
public struct FfiConverterTypeBoxedNodeIdentity: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BoxedNodeIdentity {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: BoxedNodeIdentity, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> BoxedNodeIdentity {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: BoxedNodeIdentity) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeBoxedNodeIdentity_lift(_ value: RustBuffer) throws -> BoxedNodeIdentity {
    return try FfiConverterTypeBoxedNodeIdentity.lift(value)
}

public func FfiConverterTypeBoxedNodeIdentity_lower(_ value: BoxedNodeIdentity) -> RustBuffer {
    return FfiConverterTypeBoxedNodeIdentity.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias BoxedRecepient = String
public struct FfiConverterTypeBoxedRecepient: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BoxedRecepient {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: BoxedRecepient, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> BoxedRecepient {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: BoxedRecepient) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeBoxedRecepient_lift(_ value: RustBuffer) throws -> BoxedRecepient {
    return try FfiConverterTypeBoxedRecepient.lift(value)
}

public func FfiConverterTypeBoxedRecepient_lower(_ value: BoxedRecepient) -> RustBuffer {
    return FfiConverterTypeBoxedRecepient.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias IpAddr = String
public struct FfiConverterTypeIpAddr: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IpAddr {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: IpAddr, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> IpAddr {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: IpAddr) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeIpAddr_lift(_ value: RustBuffer) throws -> IpAddr {
    return try FfiConverterTypeIpAddr.lift(value)
}

public func FfiConverterTypeIpAddr_lower(_ value: IpAddr) -> RustBuffer {
    return FfiConverterTypeIpAddr.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias IpPair = String
public struct FfiConverterTypeIpPair: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IpPair {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: IpPair, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> IpPair {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: IpPair) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeIpPair_lift(_ value: RustBuffer) throws -> IpPair {
    return try FfiConverterTypeIpPair.lift(value)
}

public func FfiConverterTypeIpPair_lower(_ value: IpPair) -> RustBuffer {
    return FfiConverterTypeIpPair.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Ipv4Addr = String
public struct FfiConverterTypeIpv4Addr: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Ipv4Addr {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Ipv4Addr, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Ipv4Addr {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Ipv4Addr) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeIpv4Addr_lift(_ value: RustBuffer) throws -> Ipv4Addr {
    return try FfiConverterTypeIpv4Addr.lift(value)
}

public func FfiConverterTypeIpv4Addr_lower(_ value: Ipv4Addr) -> RustBuffer {
    return FfiConverterTypeIpv4Addr.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Ipv4Network = String
public struct FfiConverterTypeIpv4Network: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Ipv4Network {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Ipv4Network, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Ipv4Network {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Ipv4Network) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeIpv4Network_lift(_ value: RustBuffer) throws -> Ipv4Network {
    return try FfiConverterTypeIpv4Network.lift(value)
}

public func FfiConverterTypeIpv4Network_lower(_ value: Ipv4Network) -> RustBuffer {
    return FfiConverterTypeIpv4Network.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Ipv6Addr = String
public struct FfiConverterTypeIpv6Addr: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Ipv6Addr {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Ipv6Addr, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Ipv6Addr {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Ipv6Addr) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeIpv6Addr_lift(_ value: RustBuffer) throws -> Ipv6Addr {
    return try FfiConverterTypeIpv6Addr.lift(value)
}

public func FfiConverterTypeIpv6Addr_lower(_ value: Ipv6Addr) -> RustBuffer {
    return FfiConverterTypeIpv6Addr.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Ipv6Network = String
public struct FfiConverterTypeIpv6Network: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Ipv6Network {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Ipv6Network, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Ipv6Network {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Ipv6Network) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeIpv6Network_lift(_ value: RustBuffer) throws -> Ipv6Network {
    return try FfiConverterTypeIpv6Network.lift(value)
}

public func FfiConverterTypeIpv6Network_lower(_ value: Ipv6Network) -> RustBuffer {
    return FfiConverterTypeIpv6Network.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias NodeIdentity = String
public struct FfiConverterTypeNodeIdentity: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeIdentity {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: NodeIdentity, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> NodeIdentity {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: NodeIdentity) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeNodeIdentity_lift(_ value: RustBuffer) throws -> NodeIdentity {
    return try FfiConverterTypeNodeIdentity.lift(value)
}

public func FfiConverterTypeNodeIdentity_lower(_ value: NodeIdentity) -> RustBuffer {
    return FfiConverterTypeNodeIdentity.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias OffsetDateTime = Int64
public struct FfiConverterTypeOffsetDateTime: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OffsetDateTime {
        return try FfiConverterInt64.read(from: &buf)
    }

    public static func write(_ value: OffsetDateTime, into buf: inout [UInt8]) {
        return FfiConverterInt64.write(value, into: &buf)
    }

    public static func lift(_ value: Int64) throws -> OffsetDateTime {
        return try FfiConverterInt64.lift(value)
    }

    public static func lower(_ value: OffsetDateTime) -> Int64 {
        return FfiConverterInt64.lower(value)
    }
}


public func FfiConverterTypeOffsetDateTime_lift(_ value: Int64) throws -> OffsetDateTime {
    return try FfiConverterTypeOffsetDateTime.lift(value)
}

public func FfiConverterTypeOffsetDateTime_lower(_ value: OffsetDateTime) -> Int64 {
    return FfiConverterTypeOffsetDateTime.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias PathBuf = String
public struct FfiConverterTypePathBuf: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PathBuf {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: PathBuf, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> PathBuf {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: PathBuf) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypePathBuf_lift(_ value: RustBuffer) throws -> PathBuf {
    return try FfiConverterTypePathBuf.lift(value)
}

public func FfiConverterTypePathBuf_lower(_ value: PathBuf) -> RustBuffer {
    return FfiConverterTypePathBuf.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias PublicKey = String
public struct FfiConverterTypePublicKey: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PublicKey {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: PublicKey, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> PublicKey {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: PublicKey) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypePublicKey_lift(_ value: RustBuffer) throws -> PublicKey {
    return try FfiConverterTypePublicKey.lift(value)
}

public func FfiConverterTypePublicKey_lower(_ value: PublicKey) -> RustBuffer {
    return FfiConverterTypePublicKey.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Recipient = String
public struct FfiConverterTypeRecipient: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Recipient {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Recipient, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Recipient {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Recipient) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeRecipient_lift(_ value: RustBuffer) throws -> Recipient {
    return try FfiConverterTypeRecipient.lift(value)
}

public func FfiConverterTypeRecipient_lower(_ value: Recipient) -> RustBuffer {
    return FfiConverterTypeRecipient.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias SocketAddr = String
public struct FfiConverterTypeSocketAddr: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SocketAddr {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: SocketAddr, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> SocketAddr {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: SocketAddr) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeSocketAddr_lift(_ value: RustBuffer) throws -> SocketAddr {
    return try FfiConverterTypeSocketAddr.lift(value)
}

public func FfiConverterTypeSocketAddr_lower(_ value: SocketAddr) -> RustBuffer {
    return FfiConverterTypeSocketAddr.lower(value)
}

private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

fileprivate let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

fileprivate func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> (),
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> (),
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) async throws -> T {
    // Make sure to call uniffiEnsureInitialized() since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8;
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}
private func uniffiTraitInterfaceCallAsync<T>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> ()
) -> UniffiForeignFuture {
    let task = Task {
        do {
            handleSuccess(try await makeCall())
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)

}

private func uniffiTraitInterfaceCallAsyncWithError<T, E>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> (),
    lowerError: @escaping (E) -> RustBuffer
) -> UniffiForeignFuture {
    let task = Task {
        do {
            handleSuccess(try await makeCall())
        } catch let error as E {
            handleError(CALL_ERROR, lowerError(error))
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)
}

// Borrow the callback handle map implementation to store foreign future handles
// TODO: consolidate the handle-map code (https://github.com/mozilla/uniffi-rs/pull/1823)
fileprivate var UNIFFI_FOREIGN_FUTURE_HANDLE_MAP = UniffiHandleMap<UniffiForeignFutureTask>()

// Protocol for tasks that handle foreign futures.
//
// Defining a protocol allows all tasks to be stored in the same handle map.  This can't be done
// with the task object itself, since has generic parameters.
protocol UniffiForeignFutureTask {
    func cancel()
}

extension Task: UniffiForeignFutureTask {}

private func uniffiForeignFutureFree(handle: UInt64) {
    do {
        let task = try UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.remove(handle: handle)
        // Set the cancellation flag on the task.  If it's still running, the code can check the
        // cancellation flag or call `Task.checkCancellation()`.  If the task has completed, this is
        // a no-op.
        task.cancel()
    } catch {
        print("uniffiForeignFutureFree: handle missing from handlemap")
    }
}

// For testing
public func uniffiForeignFutureHandleCountNymVpnLib() -> Int {
    UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.count
}
public func configureLib(dataDir: String)throws  {try rustCallWithError(FfiConverterTypeVpnError.lift) {
    uniffi_nym_vpn_lib_fn_func_configurelib(
        FfiConverterString.lower(dataDir),$0
    )
}
}
public func currentEnvironment()throws  -> NetworkEnvironment {
    return try  FfiConverterTypeNetworkEnvironment.lift(try rustCallWithError(FfiConverterTypeVpnError.lift) {
    uniffi_nym_vpn_lib_fn_func_currentenvironment($0
    )
})
}
public func fetchAccountLinks(accountStorePath: String, networkName: String, locale: String)throws  -> AccountLinks {
    return try  FfiConverterTypeAccountLinks.lift(try rustCallWithError(FfiConverterTypeVpnError.lift) {
    uniffi_nym_vpn_lib_fn_func_fetchaccountlinks(
        FfiConverterString.lower(accountStorePath),
        FfiConverterString.lower(networkName),
        FfiConverterString.lower(locale),$0
    )
})
}
public func fetchEnvironment(networkName: String)throws  -> NetworkEnvironment {
    return try  FfiConverterTypeNetworkEnvironment.lift(try rustCallWithError(FfiConverterTypeVpnError.lift) {
    uniffi_nym_vpn_lib_fn_func_fetchenvironment(
        FfiConverterString.lower(networkName),$0
    )
})
}
public func fetchSystemMessages(networkName: String)throws  -> [SystemMessage] {
    return try  FfiConverterSequenceTypeSystemMessage.lift(try rustCallWithError(FfiConverterTypeVpnError.lift) {
    uniffi_nym_vpn_lib_fn_func_fetchsystemmessages(
        FfiConverterString.lower(networkName),$0
    )
})
}
public func forgetAccount(path: String)throws  {try rustCallWithError(FfiConverterTypeVpnError.lift) {
    uniffi_nym_vpn_lib_fn_func_forgetaccount(
        FfiConverterString.lower(path),$0
    )
}
}
public func getAccountState()throws  -> AccountStateSummary {
    return try  FfiConverterTypeAccountStateSummary.lift(try rustCallWithError(FfiConverterTypeVpnError.lift) {
    uniffi_nym_vpn_lib_fn_func_getaccountstate($0
    )
})
}
public func getGatewayCountries(gwType: GatewayType, userAgent: UserAgent?, minGatewayPerformance: GatewayMinPerformance?)throws  -> [Location] {
    return try  FfiConverterSequenceTypeLocation.lift(try rustCallWithError(FfiConverterTypeVpnError.lift) {
    uniffi_nym_vpn_lib_fn_func_getgatewaycountries(
        FfiConverterTypeGatewayType.lower(gwType),
        FfiConverterOptionTypeUserAgent.lower(userAgent),
        FfiConverterOptionTypeGatewayMinPerformance.lower(minGatewayPerformance),$0
    )
})
}
public func getLowLatencyEntryCountry(userAgent: UserAgent)throws  -> Location {
    return try  FfiConverterTypeLocation.lift(try rustCallWithError(FfiConverterTypeVpnError.lift) {
    uniffi_nym_vpn_lib_fn_func_getlowlatencyentrycountry(
        FfiConverterTypeUserAgent.lower(userAgent),$0
    )
})
}
/**
 * Fetches the network environment details from the network name and initializes the environment,
 * including exporting to the environment
 */
public func initEnvironment(networkName: String)throws  {try rustCallWithError(FfiConverterTypeVpnError.lift) {
    uniffi_nym_vpn_lib_fn_func_initenvironment(
        FfiConverterString.lower(networkName),$0
    )
}
}
/**
 * Helps iOS synchronise tunnel start
 */
public func initEnvironmentAsync(networkName: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nym_vpn_lib_fn_func_initenvironmentasync(FfiConverterString.lower(networkName)
                )
            },
            pollFunc: ffi_nym_vpn_lib_rust_future_poll_void,
            completeFunc: ffi_nym_vpn_lib_rust_future_complete_void,
            freeFunc: ffi_nym_vpn_lib_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeVpnError.lift
        )
}
public func initLogger() {try! rustCall() {
    uniffi_nym_vpn_lib_fn_func_initlogger($0
    )
}
}
public func isAccountMnemonicStored(path: String)throws  -> Bool {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeVpnError.lift) {
    uniffi_nym_vpn_lib_fn_func_isaccountmnemonicstored(
        FfiConverterString.lower(path),$0
    )
})
}
public func removeAccountMnemonic(path: String)throws  -> Bool {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeVpnError.lift) {
    uniffi_nym_vpn_lib_fn_func_removeaccountmnemonic(
        FfiConverterString.lower(path),$0
    )
})
}
public func resetDeviceIdentity(path: String)throws  {try rustCallWithError(FfiConverterTypeVpnError.lift) {
    uniffi_nym_vpn_lib_fn_func_resetdeviceidentity(
        FfiConverterString.lower(path),$0
    )
}
}
public func shutdown()throws  {try rustCallWithError(FfiConverterTypeVpnError.lift) {
    uniffi_nym_vpn_lib_fn_func_shutdown($0
    )
}
}
public func startVpn(config: VpnConfig)throws  {try rustCallWithError(FfiConverterTypeVpnError.lift) {
    uniffi_nym_vpn_lib_fn_func_startvpn(
        FfiConverterTypeVPNConfig.lower(config),$0
    )
}
}
public func stopVpn()throws  {try rustCallWithError(FfiConverterTypeVpnError.lift) {
    uniffi_nym_vpn_lib_fn_func_stopvpn($0
    )
}
}
public func storeAccountMnemonic(mnemonic: String, path: String)throws  {try rustCallWithError(FfiConverterTypeVpnError.lift) {
    uniffi_nym_vpn_lib_fn_func_storeaccountmnemonic(
        FfiConverterString.lower(mnemonic),
        FfiConverterString.lower(path),$0
    )
}
}
public func updateAccountState()throws  {try rustCallWithError(FfiConverterTypeVpnError.lift) {
    uniffi_nym_vpn_lib_fn_func_updateaccountstate($0
    )
}
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_nym_vpn_lib_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_nym_vpn_lib_checksum_func_configurelib() != 38732) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nym_vpn_lib_checksum_func_currentenvironment() != 63403) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nym_vpn_lib_checksum_func_fetchaccountlinks() != 52598) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nym_vpn_lib_checksum_func_fetchenvironment() != 34561) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nym_vpn_lib_checksum_func_fetchsystemmessages() != 3367) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nym_vpn_lib_checksum_func_forgetaccount() != 31212) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nym_vpn_lib_checksum_func_getaccountstate() != 12813) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nym_vpn_lib_checksum_func_getgatewaycountries() != 34915) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nym_vpn_lib_checksum_func_getlowlatencyentrycountry() != 10827) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nym_vpn_lib_checksum_func_initenvironment() != 50720) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nym_vpn_lib_checksum_func_initenvironmentasync() != 36435) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nym_vpn_lib_checksum_func_initlogger() != 45606) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nym_vpn_lib_checksum_func_isaccountmnemonicstored() != 32917) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nym_vpn_lib_checksum_func_removeaccountmnemonic() != 51019) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nym_vpn_lib_checksum_func_resetdeviceidentity() != 48847) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nym_vpn_lib_checksum_func_shutdown() != 58295) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nym_vpn_lib_checksum_func_startvpn() != 55890) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nym_vpn_lib_checksum_func_stopvpn() != 59823) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nym_vpn_lib_checksum_func_storeaccountmnemonic() != 55674) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nym_vpn_lib_checksum_func_updateaccountstate() != 33999) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nym_vpn_lib_checksum_method_osdefaultpathobserver_on_default_path_change() != 43452) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nym_vpn_lib_checksum_method_ostunprovider_set_tunnel_network_settings() != 45546) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nym_vpn_lib_checksum_method_ostunprovider_set_default_path_observer() != 6896) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nym_vpn_lib_checksum_method_tunnelstatuslistener_on_event() != 60728) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitOSDefaultPathObserver()
    uniffiCallbackInitOSTunProvider()
    uniffiCallbackInitTunnelStatusListener()
    return InitializationResult.ok
}

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all