// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: vpn.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Nym_Vpn_ConnectionStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case statusUnspecified // = 0
  case unknown // = 1
  case notConnected // = 2
  case connecting // = 3
  case connected // = 4
  case disconnecting // = 5
  case connectionFailed // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .statusUnspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .statusUnspecified
    case 1: self = .unknown
    case 2: self = .notConnected
    case 3: self = .connecting
    case 4: self = .connected
    case 5: self = .disconnecting
    case 6: self = .connectionFailed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .statusUnspecified: return 0
    case .unknown: return 1
    case .notConnected: return 2
    case .connecting: return 3
    case .connected: return 4
    case .disconnecting: return 5
    case .connectionFailed: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Nym_Vpn_ConnectionStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Nym_Vpn_ConnectionStatus] = [
    .statusUnspecified,
    .unknown,
    .notConnected,
    .connecting,
    .connected,
    .disconnecting,
    .connectionFailed,
  ]
}

#endif  // swift(>=4.2)

struct Nym_Vpn_Empty {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Represents the identity of a gateway
struct Nym_Vpn_Gateway {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Represents a nym-address of the form id.enc@gateway
struct Nym_Vpn_Address {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nymAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_Location {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var twoLetterIsoCountryCode: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_EntryNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entryNodeEnum: Nym_Vpn_EntryNode.OneOf_EntryNodeEnum? = nil

  var gateway: Nym_Vpn_Gateway {
    get {
      if case .gateway(let v)? = entryNodeEnum {return v}
      return Nym_Vpn_Gateway()
    }
    set {entryNodeEnum = .gateway(newValue)}
  }

  var location: Nym_Vpn_Location {
    get {
      if case .location(let v)? = entryNodeEnum {return v}
      return Nym_Vpn_Location()
    }
    set {entryNodeEnum = .location(newValue)}
  }

  var randomLowLatency: Nym_Vpn_Empty {
    get {
      if case .randomLowLatency(let v)? = entryNodeEnum {return v}
      return Nym_Vpn_Empty()
    }
    set {entryNodeEnum = .randomLowLatency(newValue)}
  }

  var random: Nym_Vpn_Empty {
    get {
      if case .random(let v)? = entryNodeEnum {return v}
      return Nym_Vpn_Empty()
    }
    set {entryNodeEnum = .random(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_EntryNodeEnum: Equatable {
    case gateway(Nym_Vpn_Gateway)
    case location(Nym_Vpn_Location)
    case randomLowLatency(Nym_Vpn_Empty)
    case random(Nym_Vpn_Empty)

  #if !swift(>=4.1)
    static func ==(lhs: Nym_Vpn_EntryNode.OneOf_EntryNodeEnum, rhs: Nym_Vpn_EntryNode.OneOf_EntryNodeEnum) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.gateway, .gateway): return {
        guard case .gateway(let l) = lhs, case .gateway(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.location, .location): return {
        guard case .location(let l) = lhs, case .location(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.randomLowLatency, .randomLowLatency): return {
        guard case .randomLowLatency(let l) = lhs, case .randomLowLatency(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.random, .random): return {
        guard case .random(let l) = lhs, case .random(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Nym_Vpn_ExitNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var exitNodeEnum: Nym_Vpn_ExitNode.OneOf_ExitNodeEnum? = nil

  var address: Nym_Vpn_Address {
    get {
      if case .address(let v)? = exitNodeEnum {return v}
      return Nym_Vpn_Address()
    }
    set {exitNodeEnum = .address(newValue)}
  }

  var gateway: Nym_Vpn_Gateway {
    get {
      if case .gateway(let v)? = exitNodeEnum {return v}
      return Nym_Vpn_Gateway()
    }
    set {exitNodeEnum = .gateway(newValue)}
  }

  var location: Nym_Vpn_Location {
    get {
      if case .location(let v)? = exitNodeEnum {return v}
      return Nym_Vpn_Location()
    }
    set {exitNodeEnum = .location(newValue)}
  }

  var random: Nym_Vpn_Empty {
    get {
      if case .random(let v)? = exitNodeEnum {return v}
      return Nym_Vpn_Empty()
    }
    set {exitNodeEnum = .random(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ExitNodeEnum: Equatable {
    case address(Nym_Vpn_Address)
    case gateway(Nym_Vpn_Gateway)
    case location(Nym_Vpn_Location)
    case random(Nym_Vpn_Empty)

  #if !swift(>=4.1)
    static func ==(lhs: Nym_Vpn_ExitNode.OneOf_ExitNodeEnum, rhs: Nym_Vpn_ExitNode.OneOf_ExitNodeEnum) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.address, .address): return {
        guard case .address(let l) = lhs, case .address(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.gateway, .gateway): return {
        guard case .gateway(let l) = lhs, case .gateway(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.location, .location): return {
        guard case .location(let l) = lhs, case .location(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.random, .random): return {
        guard case .random(let l) = lhs, case .random(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Nym_Vpn_MixConnectedStateDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nymAddress: Nym_Vpn_Address {
    get {return _nymAddress ?? Nym_Vpn_Address()}
    set {_nymAddress = newValue}
  }
  /// Returns true if `nymAddress` has been explicitly set.
  var hasNymAddress: Bool {return self._nymAddress != nil}
  /// Clears the value of `nymAddress`. Subsequent reads from it will return its default value.
  mutating func clearNymAddress() {self._nymAddress = nil}

  var exitIpr: Nym_Vpn_Address {
    get {return _exitIpr ?? Nym_Vpn_Address()}
    set {_exitIpr = newValue}
  }
  /// Returns true if `exitIpr` has been explicitly set.
  var hasExitIpr: Bool {return self._exitIpr != nil}
  /// Clears the value of `exitIpr`. Subsequent reads from it will return its default value.
  mutating func clearExitIpr() {self._exitIpr = nil}

  var ipv4: String = String()

  var ipv6: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _nymAddress: Nym_Vpn_Address? = nil
  fileprivate var _exitIpr: Nym_Vpn_Address? = nil
}

struct Nym_Vpn_WgConnectedStateDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entryIpv4: String = String()

  var exitIpv4: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_ConnectedStateDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var connectedStateDetails: Nym_Vpn_ConnectedStateDetails.OneOf_ConnectedStateDetails? = nil

  var mix: Nym_Vpn_MixConnectedStateDetails {
    get {
      if case .mix(let v)? = connectedStateDetails {return v}
      return Nym_Vpn_MixConnectedStateDetails()
    }
    set {connectedStateDetails = .mix(newValue)}
  }

  var wg: Nym_Vpn_WgConnectedStateDetails {
    get {
      if case .wg(let v)? = connectedStateDetails {return v}
      return Nym_Vpn_WgConnectedStateDetails()
    }
    set {connectedStateDetails = .wg(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ConnectedStateDetails: Equatable {
    case mix(Nym_Vpn_MixConnectedStateDetails)
    case wg(Nym_Vpn_WgConnectedStateDetails)

  #if !swift(>=4.1)
    static func ==(lhs: Nym_Vpn_ConnectedStateDetails.OneOf_ConnectedStateDetails, rhs: Nym_Vpn_ConnectedStateDetails.OneOf_ConnectedStateDetails) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.mix, .mix): return {
        guard case .mix(let l) = lhs, case .mix(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.wg, .wg): return {
        guard case .wg(let l) = lhs, case .wg(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Nym_Vpn_Dns {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ip: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_InfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_InfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: String = String()

  var buildTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _buildTimestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_buildTimestamp = newValue}
  }
  /// Returns true if `buildTimestamp` has been explicitly set.
  var hasBuildTimestamp: Bool {return self._buildTimestamp != nil}
  /// Clears the value of `buildTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearBuildTimestamp() {self._buildTimestamp = nil}

  var triple: String = String()

  var gitCommit: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _buildTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Nym_Vpn_Threshold {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var minPerformance: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_ConnectRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entry: Nym_Vpn_EntryNode {
    get {return _entry ?? Nym_Vpn_EntryNode()}
    set {_entry = newValue}
  }
  /// Returns true if `entry` has been explicitly set.
  var hasEntry: Bool {return self._entry != nil}
  /// Clears the value of `entry`. Subsequent reads from it will return its default value.
  mutating func clearEntry() {self._entry = nil}

  var exit: Nym_Vpn_ExitNode {
    get {return _exit ?? Nym_Vpn_ExitNode()}
    set {_exit = newValue}
  }
  /// Returns true if `exit` has been explicitly set.
  var hasExit: Bool {return self._exit != nil}
  /// Clears the value of `exit`. Subsequent reads from it will return its default value.
  mutating func clearExit() {self._exit = nil}

  var dns: Nym_Vpn_Dns {
    get {return _dns ?? Nym_Vpn_Dns()}
    set {_dns = newValue}
  }
  /// Returns true if `dns` has been explicitly set.
  var hasDns: Bool {return self._dns != nil}
  /// Clears the value of `dns`. Subsequent reads from it will return its default value.
  mutating func clearDns() {self._dns = nil}

  var disableRouting: Bool = false

  var enableTwoHop: Bool = false

  var enablePoissonRate: Bool = false

  var disableBackgroundCoverTraffic: Bool = false

  var enableCredentialsMode: Bool = false

  var minMixnodePerformance: Nym_Vpn_Threshold {
    get {return _minMixnodePerformance ?? Nym_Vpn_Threshold()}
    set {_minMixnodePerformance = newValue}
  }
  /// Returns true if `minMixnodePerformance` has been explicitly set.
  var hasMinMixnodePerformance: Bool {return self._minMixnodePerformance != nil}
  /// Clears the value of `minMixnodePerformance`. Subsequent reads from it will return its default value.
  mutating func clearMinMixnodePerformance() {self._minMixnodePerformance = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _entry: Nym_Vpn_EntryNode? = nil
  fileprivate var _exit: Nym_Vpn_ExitNode? = nil
  fileprivate var _dns: Nym_Vpn_Dns? = nil
  fileprivate var _minMixnodePerformance: Nym_Vpn_Threshold? = nil
}

struct Nym_Vpn_ConnectResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var success: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_DisconnectRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_DisconnectResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var success: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_ConnectionDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entryGateway: Nym_Vpn_Gateway {
    get {return _entryGateway ?? Nym_Vpn_Gateway()}
    set {_entryGateway = newValue}
  }
  /// Returns true if `entryGateway` has been explicitly set.
  var hasEntryGateway: Bool {return self._entryGateway != nil}
  /// Clears the value of `entryGateway`. Subsequent reads from it will return its default value.
  mutating func clearEntryGateway() {self._entryGateway = nil}

  var exitGateway: Nym_Vpn_Gateway {
    get {return _exitGateway ?? Nym_Vpn_Gateway()}
    set {_exitGateway = newValue}
  }
  /// Returns true if `exitGateway` has been explicitly set.
  var hasExitGateway: Bool {return self._exitGateway != nil}
  /// Clears the value of `exitGateway`. Subsequent reads from it will return its default value.
  mutating func clearExitGateway() {self._exitGateway = nil}

  var protocolDetails: Nym_Vpn_ConnectedStateDetails {
    get {return _protocolDetails ?? Nym_Vpn_ConnectedStateDetails()}
    set {_protocolDetails = newValue}
  }
  /// Returns true if `protocolDetails` has been explicitly set.
  var hasProtocolDetails: Bool {return self._protocolDetails != nil}
  /// Clears the value of `protocolDetails`. Subsequent reads from it will return its default value.
  mutating func clearProtocolDetails() {self._protocolDetails = nil}

  var since: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _since ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_since = newValue}
  }
  /// Returns true if `since` has been explicitly set.
  var hasSince: Bool {return self._since != nil}
  /// Clears the value of `since`. Subsequent reads from it will return its default value.
  mutating func clearSince() {self._since = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _entryGateway: Nym_Vpn_Gateway? = nil
  fileprivate var _exitGateway: Nym_Vpn_Gateway? = nil
  fileprivate var _protocolDetails: Nym_Vpn_ConnectedStateDetails? = nil
  fileprivate var _since: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Nym_Vpn_StatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_StatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Nym_Vpn_ConnectionStatus = .statusUnspecified

  var details: Nym_Vpn_ConnectionDetails {
    get {return _details ?? Nym_Vpn_ConnectionDetails()}
    set {_details = newValue}
  }
  /// Returns true if `details` has been explicitly set.
  var hasDetails: Bool {return self._details != nil}
  /// Clears the value of `details`. Subsequent reads from it will return its default value.
  mutating func clearDetails() {self._details = nil}

  var error: Nym_Vpn_Error {
    get {return _error ?? Nym_Vpn_Error()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _details: Nym_Vpn_ConnectionDetails? = nil
  fileprivate var _error: Nym_Vpn_Error? = nil
}

struct Nym_Vpn_ConnectionStateChange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Nym_Vpn_ConnectionStatus = .statusUnspecified

  var error: Nym_Vpn_Error {
    get {return _error ?? Nym_Vpn_Error()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Nym_Vpn_Error? = nil
}

struct Nym_Vpn_ConnectionStatusUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Nym_Vpn_ConnectionStatusUpdate.StatusType = .unspecified

  /// Detailed message for logging and debugging
  var message: String = String()

  /// Optional additional details
  var details: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum StatusType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unspecified // = 0

    /// Status message that is not mapped to a specific type
    case unknown // = 1

    /// Connection to entry gateway established
    /// NOTE: currently not implemented by vpnd
    case entryGatewayConnectionEstablished // = 2

    /// Connection to exit router established
    /// NOTE: currently not implemented by vpnd
    case exitRouterConnectionEstablished // = 3

    /// End-to-end tunnel established and operational
    case tunnelEndToEndConnectionEstablished // = 4

    /// Entry gateway not routing our mixnet messages
    case entryGatewayNotRoutingMixnetMessages // = 5

    /// The exit router is not responding to IPv4 traffic
    case exitRouterNotRespondingToIpv4Ping // = 6

    /// The exit router is not responding to IPv6 traffic
    case exitRouterNotRespondingToIpv6Ping // = 7

    /// The ip packet router connected to on the exit side is not routing IPv4 traffic
    case exitRouterNotRoutingIpv4Traffic // = 8

    /// The ip packet router connected to on the exit side is not routing IPv6 traffic
    case exitRouterNotRoutingIpv6Traffic // = 9

    /// The end-to-end IPv4 connection appears to be operation correctly
    case connectionOkIpv4 // = 10

    /// The end-to-end IPv6 connection appears to be operation correctly
    case connectionOkIpv6 // = 11

    /// Remaining bandwidth available
    case remainingBandwidth // = 12

    /// The user has run out of available bandwidth
    case noBandwidth // = 13
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .unknown
      case 2: self = .entryGatewayConnectionEstablished
      case 3: self = .exitRouterConnectionEstablished
      case 4: self = .tunnelEndToEndConnectionEstablished
      case 5: self = .entryGatewayNotRoutingMixnetMessages
      case 6: self = .exitRouterNotRespondingToIpv4Ping
      case 7: self = .exitRouterNotRespondingToIpv6Ping
      case 8: self = .exitRouterNotRoutingIpv4Traffic
      case 9: self = .exitRouterNotRoutingIpv6Traffic
      case 10: self = .connectionOkIpv4
      case 11: self = .connectionOkIpv6
      case 12: self = .remainingBandwidth
      case 13: self = .noBandwidth
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .unknown: return 1
      case .entryGatewayConnectionEstablished: return 2
      case .exitRouterConnectionEstablished: return 3
      case .tunnelEndToEndConnectionEstablished: return 4
      case .entryGatewayNotRoutingMixnetMessages: return 5
      case .exitRouterNotRespondingToIpv4Ping: return 6
      case .exitRouterNotRespondingToIpv6Ping: return 7
      case .exitRouterNotRoutingIpv4Traffic: return 8
      case .exitRouterNotRoutingIpv6Traffic: return 9
      case .connectionOkIpv4: return 10
      case .connectionOkIpv6: return 11
      case .remainingBandwidth: return 12
      case .noBandwidth: return 13
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Nym_Vpn_ConnectionStatusUpdate.StatusType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Nym_Vpn_ConnectionStatusUpdate.StatusType] = [
    .unspecified,
    .unknown,
    .entryGatewayConnectionEstablished,
    .exitRouterConnectionEstablished,
    .tunnelEndToEndConnectionEstablished,
    .entryGatewayNotRoutingMixnetMessages,
    .exitRouterNotRespondingToIpv4Ping,
    .exitRouterNotRespondingToIpv6Ping,
    .exitRouterNotRoutingIpv4Traffic,
    .exitRouterNotRoutingIpv6Traffic,
    .connectionOkIpv4,
    .connectionOkIpv6,
    .remainingBandwidth,
    .noBandwidth,
  ]
}

#endif  // swift(>=4.2)

struct Nym_Vpn_Error {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Nym_Vpn_Error.ErrorType = .unspecified

  /// Detailed error message for logging and debuggning
  var message: String = String()

  /// Optional additional details
  var details: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ErrorType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unspecified // = 0

    /// An error that was not explicitly handled by the vpn service. This should
    /// not happen but it will while we iterate on mapping out all possible
    /// error that can happen
    case unhandled // = 1

    /// If the credential storage does not contain any valid credentials when
    /// connecting
    case noValidCredentials // = 2

    /// Generic connection timeout. This could happen  in a number of contexts,
    /// and the provided details needs to be investigated to determine what went
    /// wrong
    case timeout // = 6

    /// Timeout starting the mixnet client
    case mixnetTimeout // = 7

    /// Failed to setup the mixnet storage paths
    case mixnetStoragePaths // = 19

    /// Failed to create a mixnet client with default storage setup
    case mixnetDefaultStorage // = 20

    /// Failed to build the mixnet client instance
    case mixnetBuildClient // = 21

    /// Failed to connect to the mixnet
    case mixnetConnect // = 22

    /// Failed to connect to the mixnet entry gateway
    case mixnetEntryGateway // = 23

    /// Looking up gateways can fail in a number of ways.
    case gatewayDirectory // = 8

    /// Failing to lookup gateways
    case gatewayDirectoryLookupGateways // = 9

    /// Failing to lookup gateway identity
    case gatewayDirectoryLookupGatewayIdentity // = 10

    /// Failing to lookup the IPR address
    case gatewayDirectoryLookupRouterAddress // = 11

    /// Failing to lookup the gateway IP
    case gatewayDirectoryLookupIp // = 12

    /// Failing to lookup the entry gateway
    case gatewayDirectoryEntry // = 13

    /// Entry gateway identity not found
    case gatewayDirectoryEntryID // = 24

    /// Failing to lookup the entry gateway for a given location
    case gatewayDirectoryEntryLocation // = 14

    /// Failing to lookup the exit gateway
    case gatewayDirectoryExit // = 15

    /// Failing to lookup the exit gateway for a given location
    case gatewayDirectoryExitLocation // = 16

    /// Invalid configuration attempted, with the same entry and exit gateway
    case gatewayDirectorySameEntryAndExitGw // = 17

    /// Client ran out of allocated bandwidth
    case outOfBandwidth // = 18
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .unhandled
      case 2: self = .noValidCredentials
      case 6: self = .timeout
      case 7: self = .mixnetTimeout
      case 8: self = .gatewayDirectory
      case 9: self = .gatewayDirectoryLookupGateways
      case 10: self = .gatewayDirectoryLookupGatewayIdentity
      case 11: self = .gatewayDirectoryLookupRouterAddress
      case 12: self = .gatewayDirectoryLookupIp
      case 13: self = .gatewayDirectoryEntry
      case 14: self = .gatewayDirectoryEntryLocation
      case 15: self = .gatewayDirectoryExit
      case 16: self = .gatewayDirectoryExitLocation
      case 17: self = .gatewayDirectorySameEntryAndExitGw
      case 18: self = .outOfBandwidth
      case 19: self = .mixnetStoragePaths
      case 20: self = .mixnetDefaultStorage
      case 21: self = .mixnetBuildClient
      case 22: self = .mixnetConnect
      case 23: self = .mixnetEntryGateway
      case 24: self = .gatewayDirectoryEntryID
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .unhandled: return 1
      case .noValidCredentials: return 2
      case .timeout: return 6
      case .mixnetTimeout: return 7
      case .gatewayDirectory: return 8
      case .gatewayDirectoryLookupGateways: return 9
      case .gatewayDirectoryLookupGatewayIdentity: return 10
      case .gatewayDirectoryLookupRouterAddress: return 11
      case .gatewayDirectoryLookupIp: return 12
      case .gatewayDirectoryEntry: return 13
      case .gatewayDirectoryEntryLocation: return 14
      case .gatewayDirectoryExit: return 15
      case .gatewayDirectoryExitLocation: return 16
      case .gatewayDirectorySameEntryAndExitGw: return 17
      case .outOfBandwidth: return 18
      case .mixnetStoragePaths: return 19
      case .mixnetDefaultStorage: return 20
      case .mixnetBuildClient: return 21
      case .mixnetConnect: return 22
      case .mixnetEntryGateway: return 23
      case .gatewayDirectoryEntryID: return 24
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Nym_Vpn_Error.ErrorType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Nym_Vpn_Error.ErrorType] = [
    .unspecified,
    .unhandled,
    .noValidCredentials,
    .timeout,
    .mixnetTimeout,
    .mixnetStoragePaths,
    .mixnetDefaultStorage,
    .mixnetBuildClient,
    .mixnetConnect,
    .mixnetEntryGateway,
    .gatewayDirectory,
    .gatewayDirectoryLookupGateways,
    .gatewayDirectoryLookupGatewayIdentity,
    .gatewayDirectoryLookupRouterAddress,
    .gatewayDirectoryLookupIp,
    .gatewayDirectoryEntry,
    .gatewayDirectoryEntryID,
    .gatewayDirectoryEntryLocation,
    .gatewayDirectoryExit,
    .gatewayDirectoryExitLocation,
    .gatewayDirectorySameEntryAndExitGw,
    .outOfBandwidth,
  ]
}

#endif  // swift(>=4.2)

struct Nym_Vpn_ImportUserCredentialRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var credential: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_ImportUserCredentialResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var success: Bool = false

  var error: Nym_Vpn_ImportError {
    get {return _error ?? Nym_Vpn_ImportError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var expiry: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expiry ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expiry = newValue}
  }
  /// Returns true if `expiry` has been explicitly set.
  var hasExpiry: Bool {return self._expiry != nil}
  /// Clears the value of `expiry`. Subsequent reads from it will return its default value.
  mutating func clearExpiry() {self._expiry = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Nym_Vpn_ImportError? = nil
  fileprivate var _expiry: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Nym_Vpn_ImportError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Nym_Vpn_ImportError.ImportErrorType = .unspecified

  /// Detailed error message for logging and debugging
  var message: String = String()

  /// Optional additional details
  var details: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ImportErrorType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unspecified // = 0

    /// Credential import is not supported while the vpn is already connected
    case vpnRunning // = 1

    /// Importing the same credential twice will return an error
    case credentialAlreadyImported // = 2

    /// If the credential storage fails in some way. It's very likely due to a
    /// permission error.
    case storageError // = 3

    /// If the provided credential fails to deserialize. This is probably due to
    /// incorrect credential, but it could also be due to other internal reasons
    case deserializationFailure // = 4

    /// Credentials have a date when they expire
    case credentialExpired // = 5
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .vpnRunning
      case 2: self = .credentialAlreadyImported
      case 3: self = .storageError
      case 4: self = .deserializationFailure
      case 5: self = .credentialExpired
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .vpnRunning: return 1
      case .credentialAlreadyImported: return 2
      case .storageError: return 3
      case .deserializationFailure: return 4
      case .credentialExpired: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Nym_Vpn_ImportError.ImportErrorType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Nym_Vpn_ImportError.ImportErrorType] = [
    .unspecified,
    .vpnRunning,
    .credentialAlreadyImported,
    .storageError,
    .deserializationFailure,
    .credentialExpired,
  ]
}

#endif  // swift(>=4.2)

struct Nym_Vpn_AsEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var canConnect: Bool = false

  var canRoute: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_AsExit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var canConnect: Bool = false

  var canRouteIpV4: Bool = false

  var canRouteIpV6: Bool = false

  var canRouteIpExternalV4: Bool = false

  var canRouteIpExternalV6: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_ProbeOutcome {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var asEntry: Nym_Vpn_AsEntry {
    get {return _asEntry ?? Nym_Vpn_AsEntry()}
    set {_asEntry = newValue}
  }
  /// Returns true if `asEntry` has been explicitly set.
  var hasAsEntry: Bool {return self._asEntry != nil}
  /// Clears the value of `asEntry`. Subsequent reads from it will return its default value.
  mutating func clearAsEntry() {self._asEntry = nil}

  var asExit: Nym_Vpn_AsExit {
    get {return _asExit ?? Nym_Vpn_AsExit()}
    set {_asExit = newValue}
  }
  /// Returns true if `asExit` has been explicitly set.
  var hasAsExit: Bool {return self._asExit != nil}
  /// Clears the value of `asExit`. Subsequent reads from it will return its default value.
  mutating func clearAsExit() {self._asExit = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _asEntry: Nym_Vpn_AsEntry? = nil
  fileprivate var _asExit: Nym_Vpn_AsExit? = nil
}

struct Nym_Vpn_Probe {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lastUpdatedUtc: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastUpdatedUtc ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastUpdatedUtc = newValue}
  }
  /// Returns true if `lastUpdatedUtc` has been explicitly set.
  var hasLastUpdatedUtc: Bool {return self._lastUpdatedUtc != nil}
  /// Clears the value of `lastUpdatedUtc`. Subsequent reads from it will return its default value.
  mutating func clearLastUpdatedUtc() {self._lastUpdatedUtc = nil}

  var outcome: Nym_Vpn_ProbeOutcome {
    get {return _outcome ?? Nym_Vpn_ProbeOutcome()}
    set {_outcome = newValue}
  }
  /// Returns true if `outcome` has been explicitly set.
  var hasOutcome: Bool {return self._outcome != nil}
  /// Clears the value of `outcome`. Subsequent reads from it will return its default value.
  mutating func clearOutcome() {self._outcome = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _lastUpdatedUtc: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _outcome: Nym_Vpn_ProbeOutcome? = nil
}

struct Nym_Vpn_EntryGateway {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Nym_Vpn_Gateway {
    get {return _id ?? Nym_Vpn_Gateway()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var location: Nym_Vpn_Location {
    get {return _location ?? Nym_Vpn_Location()}
    set {_location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  var hasLocation: Bool {return self._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  mutating func clearLocation() {self._location = nil}

  var lastProbe: Nym_Vpn_Probe {
    get {return _lastProbe ?? Nym_Vpn_Probe()}
    set {_lastProbe = newValue}
  }
  /// Returns true if `lastProbe` has been explicitly set.
  var hasLastProbe: Bool {return self._lastProbe != nil}
  /// Clears the value of `lastProbe`. Subsequent reads from it will return its default value.
  mutating func clearLastProbe() {self._lastProbe = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: Nym_Vpn_Gateway? = nil
  fileprivate var _location: Nym_Vpn_Location? = nil
  fileprivate var _lastProbe: Nym_Vpn_Probe? = nil
}

struct Nym_Vpn_ListEntryGatewaysRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_ListEntryGatewaysResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gateways: [Nym_Vpn_EntryGateway] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_ExitGateway {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Nym_Vpn_Gateway {
    get {return _id ?? Nym_Vpn_Gateway()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var location: Nym_Vpn_Location {
    get {return _location ?? Nym_Vpn_Location()}
    set {_location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  var hasLocation: Bool {return self._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  mutating func clearLocation() {self._location = nil}

  var lastProbe: Nym_Vpn_Probe {
    get {return _lastProbe ?? Nym_Vpn_Probe()}
    set {_lastProbe = newValue}
  }
  /// Returns true if `lastProbe` has been explicitly set.
  var hasLastProbe: Bool {return self._lastProbe != nil}
  /// Clears the value of `lastProbe`. Subsequent reads from it will return its default value.
  mutating func clearLastProbe() {self._lastProbe = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: Nym_Vpn_Gateway? = nil
  fileprivate var _location: Nym_Vpn_Location? = nil
  fileprivate var _lastProbe: Nym_Vpn_Probe? = nil
}

struct Nym_Vpn_ListExitGatewaysRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_ListExitGatewaysResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gateways: [Nym_Vpn_ExitGateway] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_ListEntryCountriesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_ListEntryCountriesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var countries: [Nym_Vpn_Location] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_ListExitCountriesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_ListExitCountriesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var countries: [Nym_Vpn_Location] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_StoreAccountRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mnemonic: String = String()

  var nonce: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_StoreAccountResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var success: Bool = false

  var error: Nym_Vpn_StoreAccountError {
    get {return _error ?? Nym_Vpn_StoreAccountError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Nym_Vpn_StoreAccountError? = nil
}

struct Nym_Vpn_StoreAccountError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Nym_Vpn_StoreAccountError.StoreAccountErrorType = .storeAccountErrorUnspecified

  /// Detailed error message for logging and debugging
  var message: String = String()

  /// Optional additional details
  var details: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum StoreAccountErrorType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case storeAccountErrorUnspecified // = 0

    /// The provided mnemonic was not able to be parsed
    case invalidMnemonic // = 1

    /// General error from the storage backend
    case storage // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .storeAccountErrorUnspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .storeAccountErrorUnspecified
      case 1: self = .invalidMnemonic
      case 2: self = .storage
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .storeAccountErrorUnspecified: return 0
      case .invalidMnemonic: return 1
      case .storage: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Nym_Vpn_StoreAccountError.StoreAccountErrorType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Nym_Vpn_StoreAccountError.StoreAccountErrorType] = [
    .storeAccountErrorUnspecified,
    .invalidMnemonic,
    .storage,
  ]
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension Nym_Vpn_ConnectionStatus: @unchecked Sendable {}
extension Nym_Vpn_Empty: @unchecked Sendable {}
extension Nym_Vpn_Gateway: @unchecked Sendable {}
extension Nym_Vpn_Address: @unchecked Sendable {}
extension Nym_Vpn_Location: @unchecked Sendable {}
extension Nym_Vpn_EntryNode: @unchecked Sendable {}
extension Nym_Vpn_EntryNode.OneOf_EntryNodeEnum: @unchecked Sendable {}
extension Nym_Vpn_ExitNode: @unchecked Sendable {}
extension Nym_Vpn_ExitNode.OneOf_ExitNodeEnum: @unchecked Sendable {}
extension Nym_Vpn_MixConnectedStateDetails: @unchecked Sendable {}
extension Nym_Vpn_WgConnectedStateDetails: @unchecked Sendable {}
extension Nym_Vpn_ConnectedStateDetails: @unchecked Sendable {}
extension Nym_Vpn_ConnectedStateDetails.OneOf_ConnectedStateDetails: @unchecked Sendable {}
extension Nym_Vpn_Dns: @unchecked Sendable {}
extension Nym_Vpn_InfoRequest: @unchecked Sendable {}
extension Nym_Vpn_InfoResponse: @unchecked Sendable {}
extension Nym_Vpn_Threshold: @unchecked Sendable {}
extension Nym_Vpn_ConnectRequest: @unchecked Sendable {}
extension Nym_Vpn_ConnectResponse: @unchecked Sendable {}
extension Nym_Vpn_DisconnectRequest: @unchecked Sendable {}
extension Nym_Vpn_DisconnectResponse: @unchecked Sendable {}
extension Nym_Vpn_ConnectionDetails: @unchecked Sendable {}
extension Nym_Vpn_StatusRequest: @unchecked Sendable {}
extension Nym_Vpn_StatusResponse: @unchecked Sendable {}
extension Nym_Vpn_ConnectionStateChange: @unchecked Sendable {}
extension Nym_Vpn_ConnectionStatusUpdate: @unchecked Sendable {}
extension Nym_Vpn_ConnectionStatusUpdate.StatusType: @unchecked Sendable {}
extension Nym_Vpn_Error: @unchecked Sendable {}
extension Nym_Vpn_Error.ErrorType: @unchecked Sendable {}
extension Nym_Vpn_ImportUserCredentialRequest: @unchecked Sendable {}
extension Nym_Vpn_ImportUserCredentialResponse: @unchecked Sendable {}
extension Nym_Vpn_ImportError: @unchecked Sendable {}
extension Nym_Vpn_ImportError.ImportErrorType: @unchecked Sendable {}
extension Nym_Vpn_AsEntry: @unchecked Sendable {}
extension Nym_Vpn_AsExit: @unchecked Sendable {}
extension Nym_Vpn_ProbeOutcome: @unchecked Sendable {}
extension Nym_Vpn_Probe: @unchecked Sendable {}
extension Nym_Vpn_EntryGateway: @unchecked Sendable {}
extension Nym_Vpn_ListEntryGatewaysRequest: @unchecked Sendable {}
extension Nym_Vpn_ListEntryGatewaysResponse: @unchecked Sendable {}
extension Nym_Vpn_ExitGateway: @unchecked Sendable {}
extension Nym_Vpn_ListExitGatewaysRequest: @unchecked Sendable {}
extension Nym_Vpn_ListExitGatewaysResponse: @unchecked Sendable {}
extension Nym_Vpn_ListEntryCountriesRequest: @unchecked Sendable {}
extension Nym_Vpn_ListEntryCountriesResponse: @unchecked Sendable {}
extension Nym_Vpn_ListExitCountriesRequest: @unchecked Sendable {}
extension Nym_Vpn_ListExitCountriesResponse: @unchecked Sendable {}
extension Nym_Vpn_StoreAccountRequest: @unchecked Sendable {}
extension Nym_Vpn_StoreAccountResponse: @unchecked Sendable {}
extension Nym_Vpn_StoreAccountError: @unchecked Sendable {}
extension Nym_Vpn_StoreAccountError.StoreAccountErrorType: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "nym.vpn"

extension Nym_Vpn_ConnectionStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNSPECIFIED"),
    1: .same(proto: "UNKNOWN"),
    2: .same(proto: "NOT_CONNECTED"),
    3: .same(proto: "CONNECTING"),
    4: .same(proto: "CONNECTED"),
    5: .same(proto: "DISCONNECTING"),
    6: .same(proto: "CONNECTION_FAILED"),
  ]
}

extension Nym_Vpn_Empty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Empty"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_Empty, rhs: Nym_Vpn_Empty) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_Gateway: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Gateway"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_Gateway, rhs: Nym_Vpn_Gateway) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_Address: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Address"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "nym_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.nymAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nymAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.nymAddress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_Address, rhs: Nym_Vpn_Address) -> Bool {
    if lhs.nymAddress != rhs.nymAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_Location: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Location"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "two_letter_iso_country_code"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.twoLetterIsoCountryCode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.twoLetterIsoCountryCode.isEmpty {
      try visitor.visitSingularStringField(value: self.twoLetterIsoCountryCode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_Location, rhs: Nym_Vpn_Location) -> Bool {
    if lhs.twoLetterIsoCountryCode != rhs.twoLetterIsoCountryCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_EntryNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EntryNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gateway"),
    2: .same(proto: "location"),
    3: .standard(proto: "random_low_latency"),
    4: .same(proto: "random"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Nym_Vpn_Gateway?
        var hadOneofValue = false
        if let current = self.entryNodeEnum {
          hadOneofValue = true
          if case .gateway(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.entryNodeEnum = .gateway(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_Location?
        var hadOneofValue = false
        if let current = self.entryNodeEnum {
          hadOneofValue = true
          if case .location(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.entryNodeEnum = .location(v)
        }
      }()
      case 3: try {
        var v: Nym_Vpn_Empty?
        var hadOneofValue = false
        if let current = self.entryNodeEnum {
          hadOneofValue = true
          if case .randomLowLatency(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.entryNodeEnum = .randomLowLatency(v)
        }
      }()
      case 4: try {
        var v: Nym_Vpn_Empty?
        var hadOneofValue = false
        if let current = self.entryNodeEnum {
          hadOneofValue = true
          if case .random(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.entryNodeEnum = .random(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.entryNodeEnum {
    case .gateway?: try {
      guard case .gateway(let v)? = self.entryNodeEnum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .location?: try {
      guard case .location(let v)? = self.entryNodeEnum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .randomLowLatency?: try {
      guard case .randomLowLatency(let v)? = self.entryNodeEnum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .random?: try {
      guard case .random(let v)? = self.entryNodeEnum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_EntryNode, rhs: Nym_Vpn_EntryNode) -> Bool {
    if lhs.entryNodeEnum != rhs.entryNodeEnum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ExitNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExitNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "gateway"),
    3: .same(proto: "location"),
    4: .same(proto: "random"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Nym_Vpn_Address?
        var hadOneofValue = false
        if let current = self.exitNodeEnum {
          hadOneofValue = true
          if case .address(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.exitNodeEnum = .address(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_Gateway?
        var hadOneofValue = false
        if let current = self.exitNodeEnum {
          hadOneofValue = true
          if case .gateway(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.exitNodeEnum = .gateway(v)
        }
      }()
      case 3: try {
        var v: Nym_Vpn_Location?
        var hadOneofValue = false
        if let current = self.exitNodeEnum {
          hadOneofValue = true
          if case .location(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.exitNodeEnum = .location(v)
        }
      }()
      case 4: try {
        var v: Nym_Vpn_Empty?
        var hadOneofValue = false
        if let current = self.exitNodeEnum {
          hadOneofValue = true
          if case .random(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.exitNodeEnum = .random(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.exitNodeEnum {
    case .address?: try {
      guard case .address(let v)? = self.exitNodeEnum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .gateway?: try {
      guard case .gateway(let v)? = self.exitNodeEnum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .location?: try {
      guard case .location(let v)? = self.exitNodeEnum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .random?: try {
      guard case .random(let v)? = self.exitNodeEnum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ExitNode, rhs: Nym_Vpn_ExitNode) -> Bool {
    if lhs.exitNodeEnum != rhs.exitNodeEnum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_MixConnectedStateDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MixConnectedStateDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "nym_address"),
    2: .standard(proto: "exit_ipr"),
    3: .same(proto: "ipv4"),
    4: .same(proto: "ipv6"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._nymAddress) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._exitIpr) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ipv4) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.ipv6) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nymAddress {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._exitIpr {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.ipv4.isEmpty {
      try visitor.visitSingularStringField(value: self.ipv4, fieldNumber: 3)
    }
    if !self.ipv6.isEmpty {
      try visitor.visitSingularStringField(value: self.ipv6, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_MixConnectedStateDetails, rhs: Nym_Vpn_MixConnectedStateDetails) -> Bool {
    if lhs._nymAddress != rhs._nymAddress {return false}
    if lhs._exitIpr != rhs._exitIpr {return false}
    if lhs.ipv4 != rhs.ipv4 {return false}
    if lhs.ipv6 != rhs.ipv6 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_WgConnectedStateDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WgConnectedStateDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "entry_ipv4"),
    2: .standard(proto: "exit_ipv4"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.entryIpv4) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.exitIpv4) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entryIpv4.isEmpty {
      try visitor.visitSingularStringField(value: self.entryIpv4, fieldNumber: 1)
    }
    if !self.exitIpv4.isEmpty {
      try visitor.visitSingularStringField(value: self.exitIpv4, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_WgConnectedStateDetails, rhs: Nym_Vpn_WgConnectedStateDetails) -> Bool {
    if lhs.entryIpv4 != rhs.entryIpv4 {return false}
    if lhs.exitIpv4 != rhs.exitIpv4 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ConnectedStateDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectedStateDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mix"),
    2: .same(proto: "wg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Nym_Vpn_MixConnectedStateDetails?
        var hadOneofValue = false
        if let current = self.connectedStateDetails {
          hadOneofValue = true
          if case .mix(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.connectedStateDetails = .mix(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_WgConnectedStateDetails?
        var hadOneofValue = false
        if let current = self.connectedStateDetails {
          hadOneofValue = true
          if case .wg(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.connectedStateDetails = .wg(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.connectedStateDetails {
    case .mix?: try {
      guard case .mix(let v)? = self.connectedStateDetails else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .wg?: try {
      guard case .wg(let v)? = self.connectedStateDetails else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ConnectedStateDetails, rhs: Nym_Vpn_ConnectedStateDetails) -> Bool {
    if lhs.connectedStateDetails != rhs.connectedStateDetails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_Dns: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Dns"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ip"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ip) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ip.isEmpty {
      try visitor.visitSingularStringField(value: self.ip, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_Dns, rhs: Nym_Vpn_Dns) -> Bool {
    if lhs.ip != rhs.ip {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_InfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InfoRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_InfoRequest, rhs: Nym_Vpn_InfoRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_InfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .standard(proto: "build_timestamp"),
    3: .same(proto: "triple"),
    4: .standard(proto: "git_commit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._buildTimestamp) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.triple) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.gitCommit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 1)
    }
    try { if let v = self._buildTimestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.triple.isEmpty {
      try visitor.visitSingularStringField(value: self.triple, fieldNumber: 3)
    }
    if !self.gitCommit.isEmpty {
      try visitor.visitSingularStringField(value: self.gitCommit, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_InfoResponse, rhs: Nym_Vpn_InfoResponse) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs._buildTimestamp != rhs._buildTimestamp {return false}
    if lhs.triple != rhs.triple {return false}
    if lhs.gitCommit != rhs.gitCommit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_Threshold: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Threshold"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_performance"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.minPerformance) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.minPerformance != 0 {
      try visitor.visitSingularUInt32Field(value: self.minPerformance, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_Threshold, rhs: Nym_Vpn_Threshold) -> Bool {
    if lhs.minPerformance != rhs.minPerformance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ConnectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entry"),
    2: .same(proto: "exit"),
    3: .same(proto: "dns"),
    4: .standard(proto: "disable_routing"),
    5: .standard(proto: "enable_two_hop"),
    6: .standard(proto: "enable_poisson_rate"),
    7: .standard(proto: "disable_background_cover_traffic"),
    8: .standard(proto: "enable_credentials_mode"),
    9: .standard(proto: "min_mixnode_performance"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._entry) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._exit) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._dns) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.disableRouting) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.enableTwoHop) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.enablePoissonRate) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.disableBackgroundCoverTraffic) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.enableCredentialsMode) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._minMixnodePerformance) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._entry {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._exit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._dns {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.disableRouting != false {
      try visitor.visitSingularBoolField(value: self.disableRouting, fieldNumber: 4)
    }
    if self.enableTwoHop != false {
      try visitor.visitSingularBoolField(value: self.enableTwoHop, fieldNumber: 5)
    }
    if self.enablePoissonRate != false {
      try visitor.visitSingularBoolField(value: self.enablePoissonRate, fieldNumber: 6)
    }
    if self.disableBackgroundCoverTraffic != false {
      try visitor.visitSingularBoolField(value: self.disableBackgroundCoverTraffic, fieldNumber: 7)
    }
    if self.enableCredentialsMode != false {
      try visitor.visitSingularBoolField(value: self.enableCredentialsMode, fieldNumber: 8)
    }
    try { if let v = self._minMixnodePerformance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ConnectRequest, rhs: Nym_Vpn_ConnectRequest) -> Bool {
    if lhs._entry != rhs._entry {return false}
    if lhs._exit != rhs._exit {return false}
    if lhs._dns != rhs._dns {return false}
    if lhs.disableRouting != rhs.disableRouting {return false}
    if lhs.enableTwoHop != rhs.enableTwoHop {return false}
    if lhs.enablePoissonRate != rhs.enablePoissonRate {return false}
    if lhs.disableBackgroundCoverTraffic != rhs.disableBackgroundCoverTraffic {return false}
    if lhs.enableCredentialsMode != rhs.enableCredentialsMode {return false}
    if lhs._minMixnodePerformance != rhs._minMixnodePerformance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ConnectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ConnectResponse, rhs: Nym_Vpn_ConnectResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_DisconnectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisconnectRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_DisconnectRequest, rhs: Nym_Vpn_DisconnectRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_DisconnectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisconnectResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_DisconnectResponse, rhs: Nym_Vpn_DisconnectResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ConnectionDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectionDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "entry_gateway"),
    2: .standard(proto: "exit_gateway"),
    3: .standard(proto: "protocol_details"),
    4: .same(proto: "since"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._entryGateway) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._exitGateway) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._protocolDetails) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._since) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._entryGateway {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._exitGateway {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._protocolDetails {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._since {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ConnectionDetails, rhs: Nym_Vpn_ConnectionDetails) -> Bool {
    if lhs._entryGateway != rhs._entryGateway {return false}
    if lhs._exitGateway != rhs._exitGateway {return false}
    if lhs._protocolDetails != rhs._protocolDetails {return false}
    if lhs._since != rhs._since {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_StatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StatusRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_StatusRequest, rhs: Nym_Vpn_StatusRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_StatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StatusResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "details"),
    3: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.status != .statusUnspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_StatusResponse, rhs: Nym_Vpn_StatusResponse) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs._details != rhs._details {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ConnectionStateChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectionStateChange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.status != .statusUnspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ConnectionStateChange, rhs: Nym_Vpn_ConnectionStateChange) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ConnectionStatusUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectionStatusUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .same(proto: "message"),
    3: .same(proto: "details"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.details) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.kind != .unspecified {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.details.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.details, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ConnectionStatusUpdate, rhs: Nym_Vpn_ConnectionStatusUpdate) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.message != rhs.message {return false}
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ConnectionStatusUpdate.StatusType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_TYPE_UNSPECIFIED"),
    1: .same(proto: "UNKNOWN"),
    2: .same(proto: "ENTRY_GATEWAY_CONNECTION_ESTABLISHED"),
    3: .same(proto: "EXIT_ROUTER_CONNECTION_ESTABLISHED"),
    4: .same(proto: "TUNNEL_END_TO_END_CONNECTION_ESTABLISHED"),
    5: .same(proto: "ENTRY_GATEWAY_NOT_ROUTING_MIXNET_MESSAGES"),
    6: .same(proto: "EXIT_ROUTER_NOT_RESPONDING_TO_IPV4_PING"),
    7: .same(proto: "EXIT_ROUTER_NOT_RESPONDING_TO_IPV6_PING"),
    8: .same(proto: "EXIT_ROUTER_NOT_ROUTING_IPV4_TRAFFIC"),
    9: .same(proto: "EXIT_ROUTER_NOT_ROUTING_IPV6_TRAFFIC"),
    10: .same(proto: "CONNECTION_OK_IPV4"),
    11: .same(proto: "CONNECTION_OK_IPV6"),
    12: .same(proto: "REMAINING_BANDWIDTH"),
    13: .same(proto: "NO_BANDWIDTH"),
  ]
}

extension Nym_Vpn_Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Error"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .same(proto: "message"),
    3: .same(proto: "details"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.details) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.kind != .unspecified {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.details.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.details, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_Error, rhs: Nym_Vpn_Error) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.message != rhs.message {return false}
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_Error.ErrorType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ERROR_TYPE_UNSPECIFIED"),
    1: .same(proto: "UNHANDLED"),
    2: .same(proto: "NO_VALID_CREDENTIALS"),
    6: .same(proto: "TIMEOUT"),
    7: .same(proto: "MIXNET_TIMEOUT"),
    8: .same(proto: "GATEWAY_DIRECTORY"),
    9: .same(proto: "GATEWAY_DIRECTORY_LOOKUP_GATEWAYS"),
    10: .same(proto: "GATEWAY_DIRECTORY_LOOKUP_GATEWAY_IDENTITY"),
    11: .same(proto: "GATEWAY_DIRECTORY_LOOKUP_ROUTER_ADDRESS"),
    12: .same(proto: "GATEWAY_DIRECTORY_LOOKUP_IP"),
    13: .same(proto: "GATEWAY_DIRECTORY_ENTRY"),
    14: .same(proto: "GATEWAY_DIRECTORY_ENTRY_LOCATION"),
    15: .same(proto: "GATEWAY_DIRECTORY_EXIT"),
    16: .same(proto: "GATEWAY_DIRECTORY_EXIT_LOCATION"),
    17: .same(proto: "GATEWAY_DIRECTORY_SAME_ENTRY_AND_EXIT_GW"),
    18: .same(proto: "OUT_OF_BANDWIDTH"),
    19: .same(proto: "MIXNET_STORAGE_PATHS"),
    20: .same(proto: "MIXNET_DEFAULT_STORAGE"),
    21: .same(proto: "MIXNET_BUILD_CLIENT"),
    22: .same(proto: "MIXNET_CONNECT"),
    23: .same(proto: "MIXNET_ENTRY_GATEWAY"),
    24: .same(proto: "GATEWAY_DIRECTORY_ENTRY_ID"),
  ]
}

extension Nym_Vpn_ImportUserCredentialRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImportUserCredentialRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "credential"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.credential) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.credential.isEmpty {
      try visitor.visitSingularBytesField(value: self.credential, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ImportUserCredentialRequest, rhs: Nym_Vpn_ImportUserCredentialRequest) -> Bool {
    if lhs.credential != rhs.credential {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ImportUserCredentialResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImportUserCredentialResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "error"),
    3: .same(proto: "expiry"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._expiry) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._expiry {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ImportUserCredentialResponse, rhs: Nym_Vpn_ImportUserCredentialResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs._error != rhs._error {return false}
    if lhs._expiry != rhs._expiry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ImportError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImportError"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .same(proto: "message"),
    3: .same(proto: "details"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.details) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.kind != .unspecified {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.details.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.details, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ImportError, rhs: Nym_Vpn_ImportError) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.message != rhs.message {return false}
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ImportError.ImportErrorType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IMPORT_ERROR_TYPE_UNSPECIFIED"),
    1: .same(proto: "VPN_RUNNING"),
    2: .same(proto: "CREDENTIAL_ALREADY_IMPORTED"),
    3: .same(proto: "STORAGE_ERROR"),
    4: .same(proto: "DESERIALIZATION_FAILURE"),
    5: .same(proto: "CREDENTIAL_EXPIRED"),
  ]
}

extension Nym_Vpn_AsEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AsEntry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "can_connect"),
    2: .standard(proto: "can_route"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.canConnect) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.canRoute) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.canConnect != false {
      try visitor.visitSingularBoolField(value: self.canConnect, fieldNumber: 1)
    }
    if self.canRoute != false {
      try visitor.visitSingularBoolField(value: self.canRoute, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_AsEntry, rhs: Nym_Vpn_AsEntry) -> Bool {
    if lhs.canConnect != rhs.canConnect {return false}
    if lhs.canRoute != rhs.canRoute {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_AsExit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AsExit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "can_connect"),
    2: .standard(proto: "can_route_ip_v4"),
    3: .standard(proto: "can_route_ip_v6"),
    4: .standard(proto: "can_route_ip_external_v4"),
    5: .standard(proto: "can_route_ip_external_v6"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.canConnect) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.canRouteIpV4) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.canRouteIpV6) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.canRouteIpExternalV4) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.canRouteIpExternalV6) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.canConnect != false {
      try visitor.visitSingularBoolField(value: self.canConnect, fieldNumber: 1)
    }
    if self.canRouteIpV4 != false {
      try visitor.visitSingularBoolField(value: self.canRouteIpV4, fieldNumber: 2)
    }
    if self.canRouteIpV6 != false {
      try visitor.visitSingularBoolField(value: self.canRouteIpV6, fieldNumber: 3)
    }
    if self.canRouteIpExternalV4 != false {
      try visitor.visitSingularBoolField(value: self.canRouteIpExternalV4, fieldNumber: 4)
    }
    if self.canRouteIpExternalV6 != false {
      try visitor.visitSingularBoolField(value: self.canRouteIpExternalV6, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_AsExit, rhs: Nym_Vpn_AsExit) -> Bool {
    if lhs.canConnect != rhs.canConnect {return false}
    if lhs.canRouteIpV4 != rhs.canRouteIpV4 {return false}
    if lhs.canRouteIpV6 != rhs.canRouteIpV6 {return false}
    if lhs.canRouteIpExternalV4 != rhs.canRouteIpExternalV4 {return false}
    if lhs.canRouteIpExternalV6 != rhs.canRouteIpExternalV6 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ProbeOutcome: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProbeOutcome"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "as_entry"),
    2: .standard(proto: "as_exit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asEntry) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._asExit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asEntry {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._asExit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ProbeOutcome, rhs: Nym_Vpn_ProbeOutcome) -> Bool {
    if lhs._asEntry != rhs._asEntry {return false}
    if lhs._asExit != rhs._asExit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_Probe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Probe"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "last_updated_utc"),
    2: .same(proto: "outcome"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._lastUpdatedUtc) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._outcome) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._lastUpdatedUtc {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._outcome {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_Probe, rhs: Nym_Vpn_Probe) -> Bool {
    if lhs._lastUpdatedUtc != rhs._lastUpdatedUtc {return false}
    if lhs._outcome != rhs._outcome {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_EntryGateway: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EntryGateway"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "location"),
    3: .standard(proto: "last_probe"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._location) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._lastProbe) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._location {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._lastProbe {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_EntryGateway, rhs: Nym_Vpn_EntryGateway) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._location != rhs._location {return false}
    if lhs._lastProbe != rhs._lastProbe {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ListEntryGatewaysRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListEntryGatewaysRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ListEntryGatewaysRequest, rhs: Nym_Vpn_ListEntryGatewaysRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ListEntryGatewaysResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListEntryGatewaysResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gateways"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.gateways) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gateways.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.gateways, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ListEntryGatewaysResponse, rhs: Nym_Vpn_ListEntryGatewaysResponse) -> Bool {
    if lhs.gateways != rhs.gateways {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ExitGateway: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExitGateway"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "location"),
    3: .standard(proto: "last_probe"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._location) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._lastProbe) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._location {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._lastProbe {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ExitGateway, rhs: Nym_Vpn_ExitGateway) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._location != rhs._location {return false}
    if lhs._lastProbe != rhs._lastProbe {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ListExitGatewaysRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListExitGatewaysRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ListExitGatewaysRequest, rhs: Nym_Vpn_ListExitGatewaysRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ListExitGatewaysResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListExitGatewaysResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gateways"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.gateways) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gateways.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.gateways, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ListExitGatewaysResponse, rhs: Nym_Vpn_ListExitGatewaysResponse) -> Bool {
    if lhs.gateways != rhs.gateways {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ListEntryCountriesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListEntryCountriesRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ListEntryCountriesRequest, rhs: Nym_Vpn_ListEntryCountriesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ListEntryCountriesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListEntryCountriesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "countries"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.countries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.countries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.countries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ListEntryCountriesResponse, rhs: Nym_Vpn_ListEntryCountriesResponse) -> Bool {
    if lhs.countries != rhs.countries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ListExitCountriesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListExitCountriesRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ListExitCountriesRequest, rhs: Nym_Vpn_ListExitCountriesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ListExitCountriesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListExitCountriesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "countries"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.countries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.countries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.countries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ListExitCountriesResponse, rhs: Nym_Vpn_ListExitCountriesResponse) -> Bool {
    if lhs.countries != rhs.countries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_StoreAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StoreAccountRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mnemonic"),
    2: .same(proto: "nonce"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mnemonic) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.nonce) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mnemonic.isEmpty {
      try visitor.visitSingularStringField(value: self.mnemonic, fieldNumber: 1)
    }
    if self.nonce != 0 {
      try visitor.visitSingularUInt32Field(value: self.nonce, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_StoreAccountRequest, rhs: Nym_Vpn_StoreAccountRequest) -> Bool {
    if lhs.mnemonic != rhs.mnemonic {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_StoreAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StoreAccountResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_StoreAccountResponse, rhs: Nym_Vpn_StoreAccountResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_StoreAccountError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StoreAccountError"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .same(proto: "message"),
    3: .same(proto: "details"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.details) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.kind != .storeAccountErrorUnspecified {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.details.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.details, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_StoreAccountError, rhs: Nym_Vpn_StoreAccountError) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.message != rhs.message {return false}
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_StoreAccountError.StoreAccountErrorType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STORE_ACCOUNT_ERROR_UNSPECIFIED"),
    1: .same(proto: "INVALID_MNEMONIC"),
    2: .same(proto: "STORAGE"),
  ]
}
