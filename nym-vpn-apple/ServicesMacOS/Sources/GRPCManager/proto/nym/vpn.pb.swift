// swiftlint:disable all
// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: vpn.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

enum Nym_Vpn_ConnectionStatus: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case statusUnspecified // = 0
    case unknown // = 1
    case notConnected // = 2
    case connecting // = 3
    case connected // = 4
    case disconnecting // = 5
    case connectionFailed // = 6
    case UNRECOGNIZED(Int)

    init() {
        self = .statusUnspecified
    }

    init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .statusUnspecified
        case 1: self = .unknown
        case 2: self = .notConnected
        case 3: self = .connecting
        case 4: self = .connected
        case 5: self = .disconnecting
        case 6: self = .connectionFailed
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    var rawValue: Int {
        switch self {
        case .statusUnspecified: return 0
        case .unknown: return 1
        case .notConnected: return 2
        case .connecting: return 3
        case .connected: return 4
        case .disconnecting: return 5
        case .connectionFailed: return 6
        case .UNRECOGNIZED(let i): return i
        }
    }

}

#if swift(>=4.2)

extension Nym_Vpn_ConnectionStatus: CaseIterable {
    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Nym_Vpn_ConnectionStatus] = [
        .statusUnspecified,
        .unknown,
        .notConnected,
        .connecting,
        .connected,
        .disconnecting,
        .connectionFailed,
    ]
}

#endif  // swift(>=4.2)

struct Nym_Vpn_Empty {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// Represents the identity of a gateway
struct Nym_Vpn_Gateway {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// Represents a nym-address of the form id.enc@gateway
struct Nym_Vpn_Address {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var nymAddress: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Nym_Vpn_Location {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var twoLetterIsoCountryCode: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Nym_Vpn_EntryNode {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var entryNodeEnum: Nym_Vpn_EntryNode.OneOf_EntryNodeEnum? = nil

    var gateway: Nym_Vpn_Gateway {
        get {
            if case .gateway(let v)? = entryNodeEnum {return v}
            return Nym_Vpn_Gateway()
        }
        set {entryNodeEnum = .gateway(newValue)}
    }

    var location: Nym_Vpn_Location {
        get {
            if case .location(let v)? = entryNodeEnum {return v}
            return Nym_Vpn_Location()
        }
        set {entryNodeEnum = .location(newValue)}
    }

    var randomLowLatency: Nym_Vpn_Empty {
        get {
            if case .randomLowLatency(let v)? = entryNodeEnum {return v}
            return Nym_Vpn_Empty()
        }
        set {entryNodeEnum = .randomLowLatency(newValue)}
    }

    var random: Nym_Vpn_Empty {
        get {
            if case .random(let v)? = entryNodeEnum {return v}
            return Nym_Vpn_Empty()
        }
        set {entryNodeEnum = .random(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_EntryNodeEnum: Equatable {
        case gateway(Nym_Vpn_Gateway)
        case location(Nym_Vpn_Location)
        case randomLowLatency(Nym_Vpn_Empty)
        case random(Nym_Vpn_Empty)

#if !swift(>=4.1)
        static func ==(lhs: Nym_Vpn_EntryNode.OneOf_EntryNodeEnum, rhs: Nym_Vpn_EntryNode.OneOf_EntryNodeEnum) -> Bool {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch (lhs, rhs) {
            case (.gateway, .gateway): return {
                guard case .gateway(let l) = lhs, case .gateway(let r) = rhs else { preconditionFailure() }
                return l == r
            }()
            case (.location, .location): return {
                guard case .location(let l) = lhs, case .location(let r) = rhs else { preconditionFailure() }
                return l == r
            }()
            case (.randomLowLatency, .randomLowLatency): return {
                guard case .randomLowLatency(let l) = lhs, case .randomLowLatency(let r) = rhs else { preconditionFailure() }
                return l == r
            }()
            case (.random, .random): return {
                guard case .random(let l) = lhs, case .random(let r) = rhs else { preconditionFailure() }
                return l == r
            }()
            default: return false
            }
        }
#endif
    }

    init() {}
}

struct Nym_Vpn_ExitNode {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var exitNodeEnum: Nym_Vpn_ExitNode.OneOf_ExitNodeEnum? = nil

    var address: Nym_Vpn_Address {
        get {
            if case .address(let v)? = exitNodeEnum {return v}
            return Nym_Vpn_Address()
        }
        set {exitNodeEnum = .address(newValue)}
    }

    var gateway: Nym_Vpn_Gateway {
        get {
            if case .gateway(let v)? = exitNodeEnum {return v}
            return Nym_Vpn_Gateway()
        }
        set {exitNodeEnum = .gateway(newValue)}
    }

    var location: Nym_Vpn_Location {
        get {
            if case .location(let v)? = exitNodeEnum {return v}
            return Nym_Vpn_Location()
        }
        set {exitNodeEnum = .location(newValue)}
    }

    var random: Nym_Vpn_Empty {
        get {
            if case .random(let v)? = exitNodeEnum {return v}
            return Nym_Vpn_Empty()
        }
        set {exitNodeEnum = .random(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_ExitNodeEnum: Equatable {
        case address(Nym_Vpn_Address)
        case gateway(Nym_Vpn_Gateway)
        case location(Nym_Vpn_Location)
        case random(Nym_Vpn_Empty)

#if !swift(>=4.1)
        static func ==(lhs: Nym_Vpn_ExitNode.OneOf_ExitNodeEnum, rhs: Nym_Vpn_ExitNode.OneOf_ExitNodeEnum) -> Bool {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch (lhs, rhs) {
            case (.address, .address): return {
                guard case .address(let l) = lhs, case .address(let r) = rhs else { preconditionFailure() }
                return l == r
            }()
            case (.gateway, .gateway): return {
                guard case .gateway(let l) = lhs, case .gateway(let r) = rhs else { preconditionFailure() }
                return l == r
            }()
            case (.location, .location): return {
                guard case .location(let l) = lhs, case .location(let r) = rhs else { preconditionFailure() }
                return l == r
            }()
            case (.random, .random): return {
                guard case .random(let l) = lhs, case .random(let r) = rhs else { preconditionFailure() }
                return l == r
            }()
            default: return false
            }
        }
#endif
    }

    init() {}
}

struct Nym_Vpn_Dns {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var ip: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Nym_Vpn_ConnectRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var entry: Nym_Vpn_EntryNode {
        get {return _entry ?? Nym_Vpn_EntryNode()}
        set {_entry = newValue}
    }
    /// Returns true if `entry` has been explicitly set.
    var hasEntry: Bool {return self._entry != nil}
    /// Clears the value of `entry`. Subsequent reads from it will return its default value.
    mutating func clearEntry() {self._entry = nil}

    var exit: Nym_Vpn_ExitNode {
        get {return _exit ?? Nym_Vpn_ExitNode()}
        set {_exit = newValue}
    }
    /// Returns true if `exit` has been explicitly set.
    var hasExit: Bool {return self._exit != nil}
    /// Clears the value of `exit`. Subsequent reads from it will return its default value.
    mutating func clearExit() {self._exit = nil}

    var dns: Nym_Vpn_Dns {
        get {return _dns ?? Nym_Vpn_Dns()}
        set {_dns = newValue}
    }
    /// Returns true if `dns` has been explicitly set.
    var hasDns: Bool {return self._dns != nil}
    /// Clears the value of `dns`. Subsequent reads from it will return its default value.
    mutating func clearDns() {self._dns = nil}

    var disableRouting: Bool = false

    var enableTwoHop: Bool = false

    var enablePoissonRate: Bool = false

    var disableBackgroundCoverTraffic: Bool = false

    var enableCredentialsMode: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _entry: Nym_Vpn_EntryNode? = nil
    fileprivate var _exit: Nym_Vpn_ExitNode? = nil
    fileprivate var _dns: Nym_Vpn_Dns? = nil
}

struct Nym_Vpn_ConnectResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var success: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Nym_Vpn_DisconnectRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Nym_Vpn_DisconnectResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var success: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Nym_Vpn_ConnectionDetails {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var entryGateway: String = String()

    var since: SwiftProtobuf.Google_Protobuf_Timestamp {
        get {return _since ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
        set {_since = newValue}
    }
    /// Returns true if `since` has been explicitly set.
    var hasSince: Bool {return self._since != nil}
    /// Clears the value of `since`. Subsequent reads from it will return its default value.
    mutating func clearSince() {self._since = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _since: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Nym_Vpn_StatusRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Nym_Vpn_StatusResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var status: Nym_Vpn_ConnectionStatus = .statusUnspecified

    var details: Nym_Vpn_ConnectionDetails {
        get {return _details ?? Nym_Vpn_ConnectionDetails()}
        set {_details = newValue}
    }
    /// Returns true if `details` has been explicitly set.
    var hasDetails: Bool {return self._details != nil}
    /// Clears the value of `details`. Subsequent reads from it will return its default value.
    mutating func clearDetails() {self._details = nil}

    var error: Nym_Vpn_Error {
        get {return _error ?? Nym_Vpn_Error()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    mutating func clearError() {self._error = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _details: Nym_Vpn_ConnectionDetails? = nil
    fileprivate var _error: Nym_Vpn_Error? = nil
}

struct Nym_Vpn_ConnectionStateChange {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var status: Nym_Vpn_ConnectionStatus = .statusUnspecified

    var error: Nym_Vpn_Error {
        get {return _error ?? Nym_Vpn_Error()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    mutating func clearError() {self._error = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _error: Nym_Vpn_Error? = nil
}

struct Nym_Vpn_ConnectionStatusUpdate {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var message: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Nym_Vpn_Error {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var kind: Nym_Vpn_Error.ErrorType = .unspecified

    /// Detailed error message for logging and debuggning
    var message: String = String()

    /// Optional additional details
    var details: Dictionary<String,String> = [:]

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum ErrorType: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case unspecified // = 0

        /// An error that was not explicitly handled by the vpn service. This should
        /// not happend but it will while we interate on mapping out all possible
        /// error that can happen
        case unhandled // = 1
        case noValidCredentials // = 2

        /// Connection timeout. This could happen  in a number of contexts, and the
        /// provided details needs to be investigated to determine what went wrong
        case timeout // = 6

        /// Looking up gateways can fail in a number of ways.
        case gatewayDirectory // = 8
        case UNRECOGNIZED(Int)

        init() {
            self = .unspecified
        }

        init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unspecified
            case 1: self = .unhandled
            case 2: self = .noValidCredentials
            case 6: self = .timeout
            case 8: self = .gatewayDirectory
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        var rawValue: Int {
            switch self {
            case .unspecified: return 0
            case .unhandled: return 1
            case .noValidCredentials: return 2
            case .timeout: return 6
            case .gatewayDirectory: return 8
            case .UNRECOGNIZED(let i): return i
            }
        }

    }

    init() {}
}

#if swift(>=4.2)

extension Nym_Vpn_Error.ErrorType: CaseIterable {
    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Nym_Vpn_Error.ErrorType] = [
        .unspecified,
        .unhandled,
        .noValidCredentials,
        .timeout,
        .gatewayDirectory,
    ]
}

#endif  // swift(>=4.2)

struct Nym_Vpn_ImportUserCredentialRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var credential: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Nym_Vpn_ImportUserCredentialResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var success: Bool = false

    var error: Nym_Vpn_ImportError {
        get {return _error ?? Nym_Vpn_ImportError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    mutating func clearError() {self._error = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _error: Nym_Vpn_ImportError? = nil
}

struct Nym_Vpn_ImportError {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var kind: Nym_Vpn_ImportError.ImportErrorType = .unspecified

    /// Detailed error message for logging and debugging
    var message: String = String()

    /// Optional additional details
    var details: Dictionary<String,String> = [:]

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum ImportErrorType: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case unspecified // = 0

        /// Credential import is not supported while the vpn is already connected
        case vpnRunning // = 1

        /// Importing the same credential twice will return an error
        case credentialAlreadyImported // = 2

        /// If the credential storage fails in some way. It's very likely due to a
        /// permission error.
        case storageError // = 3

        /// If the provided credential fails to deserialize. This is probably due to
        /// incorrect credential, but it could also be due to other internal reasons
        case deserializationFailure // = 4

        /// Credentials have a date when they expire
        case credentialExpired // = 5
        case UNRECOGNIZED(Int)

        init() {
            self = .unspecified
        }

        init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unspecified
            case 1: self = .vpnRunning
            case 2: self = .credentialAlreadyImported
            case 3: self = .storageError
            case 4: self = .deserializationFailure
            case 5: self = .credentialExpired
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        var rawValue: Int {
            switch self {
            case .unspecified: return 0
            case .vpnRunning: return 1
            case .credentialAlreadyImported: return 2
            case .storageError: return 3
            case .deserializationFailure: return 4
            case .credentialExpired: return 5
            case .UNRECOGNIZED(let i): return i
            }
        }

    }

    init() {}
}

#if swift(>=4.2)

extension Nym_Vpn_ImportError.ImportErrorType: CaseIterable {
    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Nym_Vpn_ImportError.ImportErrorType] = [
        .unspecified,
        .vpnRunning,
        .credentialAlreadyImported,
        .storageError,
        .deserializationFailure,
        .credentialExpired,
    ]
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension Nym_Vpn_ConnectionStatus: @unchecked Sendable {}
extension Nym_Vpn_Empty: @unchecked Sendable {}
extension Nym_Vpn_Gateway: @unchecked Sendable {}
extension Nym_Vpn_Address: @unchecked Sendable {}
extension Nym_Vpn_Location: @unchecked Sendable {}
extension Nym_Vpn_EntryNode: @unchecked Sendable {}
extension Nym_Vpn_EntryNode.OneOf_EntryNodeEnum: @unchecked Sendable {}
extension Nym_Vpn_ExitNode: @unchecked Sendable {}
extension Nym_Vpn_ExitNode.OneOf_ExitNodeEnum: @unchecked Sendable {}
extension Nym_Vpn_Dns: @unchecked Sendable {}
extension Nym_Vpn_ConnectRequest: @unchecked Sendable {}
extension Nym_Vpn_ConnectResponse: @unchecked Sendable {}
extension Nym_Vpn_DisconnectRequest: @unchecked Sendable {}
extension Nym_Vpn_DisconnectResponse: @unchecked Sendable {}
extension Nym_Vpn_ConnectionDetails: @unchecked Sendable {}
extension Nym_Vpn_StatusRequest: @unchecked Sendable {}
extension Nym_Vpn_StatusResponse: @unchecked Sendable {}
extension Nym_Vpn_ConnectionStateChange: @unchecked Sendable {}
extension Nym_Vpn_ConnectionStatusUpdate: @unchecked Sendable {}
extension Nym_Vpn_Error: @unchecked Sendable {}
extension Nym_Vpn_Error.ErrorType: @unchecked Sendable {}
extension Nym_Vpn_ImportUserCredentialRequest: @unchecked Sendable {}
extension Nym_Vpn_ImportUserCredentialResponse: @unchecked Sendable {}
extension Nym_Vpn_ImportError: @unchecked Sendable {}
extension Nym_Vpn_ImportError.ImportErrorType: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "nym.vpn"

extension Nym_Vpn_ConnectionStatus: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "STATUS_UNSPECIFIED"),
        1: .same(proto: "UNKNOWN"),
        2: .same(proto: "NOT_CONNECTED"),
        3: .same(proto: "CONNECTING"),
        4: .same(proto: "CONNECTED"),
        5: .same(proto: "DISCONNECTING"),
        6: .same(proto: "CONNECTION_FAILED"),
    ]
}

extension Nym_Vpn_Empty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Empty"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Nym_Vpn_Empty, rhs: Nym_Vpn_Empty) -> Bool {
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Nym_Vpn_Gateway: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Gateway"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.id.isEmpty {
            try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Nym_Vpn_Gateway, rhs: Nym_Vpn_Gateway) -> Bool {
        if lhs.id != rhs.id {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Nym_Vpn_Address: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Address"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "nym_address"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.nymAddress) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.nymAddress.isEmpty {
            try visitor.visitSingularStringField(value: self.nymAddress, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Nym_Vpn_Address, rhs: Nym_Vpn_Address) -> Bool {
        if lhs.nymAddress != rhs.nymAddress {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Nym_Vpn_Location: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Location"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "two_letter_iso_country_code"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.twoLetterIsoCountryCode) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.twoLetterIsoCountryCode.isEmpty {
            try visitor.visitSingularStringField(value: self.twoLetterIsoCountryCode, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Nym_Vpn_Location, rhs: Nym_Vpn_Location) -> Bool {
        if lhs.twoLetterIsoCountryCode != rhs.twoLetterIsoCountryCode {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Nym_Vpn_EntryNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".EntryNode"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "gateway"),
        2: .same(proto: "location"),
        3: .standard(proto: "random_low_latency"),
        4: .same(proto: "random"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                var v: Nym_Vpn_Gateway?
                var hadOneofValue = false
                if let current = self.entryNodeEnum {
                    hadOneofValue = true
                    if case .gateway(let m) = current {v = m}
                }
                try decoder.decodeSingularMessageField(value: &v)
                if let v = v {
                    if hadOneofValue {try decoder.handleConflictingOneOf()}
                    self.entryNodeEnum = .gateway(v)
                }
            }()
            case 2: try {
                var v: Nym_Vpn_Location?
                var hadOneofValue = false
                if let current = self.entryNodeEnum {
                    hadOneofValue = true
                    if case .location(let m) = current {v = m}
                }
                try decoder.decodeSingularMessageField(value: &v)
                if let v = v {
                    if hadOneofValue {try decoder.handleConflictingOneOf()}
                    self.entryNodeEnum = .location(v)
                }
            }()
            case 3: try {
                var v: Nym_Vpn_Empty?
                var hadOneofValue = false
                if let current = self.entryNodeEnum {
                    hadOneofValue = true
                    if case .randomLowLatency(let m) = current {v = m}
                }
                try decoder.decodeSingularMessageField(value: &v)
                if let v = v {
                    if hadOneofValue {try decoder.handleConflictingOneOf()}
                    self.entryNodeEnum = .randomLowLatency(v)
                }
            }()
            case 4: try {
                var v: Nym_Vpn_Empty?
                var hadOneofValue = false
                if let current = self.entryNodeEnum {
                    hadOneofValue = true
                    if case .random(let m) = current {v = m}
                }
                try decoder.decodeSingularMessageField(value: &v)
                if let v = v {
                    if hadOneofValue {try decoder.handleConflictingOneOf()}
                    self.entryNodeEnum = .random(v)
                }
            }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch self.entryNodeEnum {
        case .gateway?: try {
            guard case .gateway(let v)? = self.entryNodeEnum else { preconditionFailure() }
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }()
        case .location?: try {
            guard case .location(let v)? = self.entryNodeEnum else { preconditionFailure() }
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        }()
        case .randomLowLatency?: try {
            guard case .randomLowLatency(let v)? = self.entryNodeEnum else { preconditionFailure() }
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        }()
        case .random?: try {
            guard case .random(let v)? = self.entryNodeEnum else { preconditionFailure() }
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Nym_Vpn_EntryNode, rhs: Nym_Vpn_EntryNode) -> Bool {
        if lhs.entryNodeEnum != rhs.entryNodeEnum {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Nym_Vpn_ExitNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ExitNode"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "address"),
        2: .same(proto: "gateway"),
        3: .same(proto: "location"),
        4: .same(proto: "random"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                var v: Nym_Vpn_Address?
                var hadOneofValue = false
                if let current = self.exitNodeEnum {
                    hadOneofValue = true
                    if case .address(let m) = current {v = m}
                }
                try decoder.decodeSingularMessageField(value: &v)
                if let v = v {
                    if hadOneofValue {try decoder.handleConflictingOneOf()}
                    self.exitNodeEnum = .address(v)
                }
            }()
            case 2: try {
                var v: Nym_Vpn_Gateway?
                var hadOneofValue = false
                if let current = self.exitNodeEnum {
                    hadOneofValue = true
                    if case .gateway(let m) = current {v = m}
                }
                try decoder.decodeSingularMessageField(value: &v)
                if let v = v {
                    if hadOneofValue {try decoder.handleConflictingOneOf()}
                    self.exitNodeEnum = .gateway(v)
                }
            }()
            case 3: try {
                var v: Nym_Vpn_Location?
                var hadOneofValue = false
                if let current = self.exitNodeEnum {
                    hadOneofValue = true
                    if case .location(let m) = current {v = m}
                }
                try decoder.decodeSingularMessageField(value: &v)
                if let v = v {
                    if hadOneofValue {try decoder.handleConflictingOneOf()}
                    self.exitNodeEnum = .location(v)
                }
            }()
            case 4: try {
                var v: Nym_Vpn_Empty?
                var hadOneofValue = false
                if let current = self.exitNodeEnum {
                    hadOneofValue = true
                    if case .random(let m) = current {v = m}
                }
                try decoder.decodeSingularMessageField(value: &v)
                if let v = v {
                    if hadOneofValue {try decoder.handleConflictingOneOf()}
                    self.exitNodeEnum = .random(v)
                }
            }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch self.exitNodeEnum {
        case .address?: try {
            guard case .address(let v)? = self.exitNodeEnum else { preconditionFailure() }
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }()
        case .gateway?: try {
            guard case .gateway(let v)? = self.exitNodeEnum else { preconditionFailure() }
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        }()
        case .location?: try {
            guard case .location(let v)? = self.exitNodeEnum else { preconditionFailure() }
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        }()
        case .random?: try {
            guard case .random(let v)? = self.exitNodeEnum else { preconditionFailure() }
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Nym_Vpn_ExitNode, rhs: Nym_Vpn_ExitNode) -> Bool {
        if lhs.exitNodeEnum != rhs.exitNodeEnum {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Nym_Vpn_Dns: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Dns"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "ip"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.ip) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.ip.isEmpty {
            try visitor.visitSingularStringField(value: self.ip, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Nym_Vpn_Dns, rhs: Nym_Vpn_Dns) -> Bool {
        if lhs.ip != rhs.ip {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Nym_Vpn_ConnectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ConnectRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "entry"),
        2: .same(proto: "exit"),
        3: .same(proto: "dns"),
        4: .standard(proto: "disable_routing"),
        5: .standard(proto: "enable_two_hop"),
        6: .standard(proto: "enable_poisson_rate"),
        7: .standard(proto: "disable_background_cover_traffic"),
        8: .standard(proto: "enable_credentials_mode"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._entry) }()
            case 2: try { try decoder.decodeSingularMessageField(value: &self._exit) }()
            case 3: try { try decoder.decodeSingularMessageField(value: &self._dns) }()
            case 4: try { try decoder.decodeSingularBoolField(value: &self.disableRouting) }()
            case 5: try { try decoder.decodeSingularBoolField(value: &self.enableTwoHop) }()
            case 6: try { try decoder.decodeSingularBoolField(value: &self.enablePoissonRate) }()
            case 7: try { try decoder.decodeSingularBoolField(value: &self.disableBackgroundCoverTraffic) }()
            case 8: try { try decoder.decodeSingularBoolField(value: &self.enableCredentialsMode) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._entry {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._exit {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try { if let v = self._dns {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        if self.disableRouting != false {
            try visitor.visitSingularBoolField(value: self.disableRouting, fieldNumber: 4)
        }
        if self.enableTwoHop != false {
            try visitor.visitSingularBoolField(value: self.enableTwoHop, fieldNumber: 5)
        }
        if self.enablePoissonRate != false {
            try visitor.visitSingularBoolField(value: self.enablePoissonRate, fieldNumber: 6)
        }
        if self.disableBackgroundCoverTraffic != false {
            try visitor.visitSingularBoolField(value: self.disableBackgroundCoverTraffic, fieldNumber: 7)
        }
        if self.enableCredentialsMode != false {
            try visitor.visitSingularBoolField(value: self.enableCredentialsMode, fieldNumber: 8)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Nym_Vpn_ConnectRequest, rhs: Nym_Vpn_ConnectRequest) -> Bool {
        if lhs._entry != rhs._entry {return false}
        if lhs._exit != rhs._exit {return false}
        if lhs._dns != rhs._dns {return false}
        if lhs.disableRouting != rhs.disableRouting {return false}
        if lhs.enableTwoHop != rhs.enableTwoHop {return false}
        if lhs.enablePoissonRate != rhs.enablePoissonRate {return false}
        if lhs.disableBackgroundCoverTraffic != rhs.disableBackgroundCoverTraffic {return false}
        if lhs.enableCredentialsMode != rhs.enableCredentialsMode {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Nym_Vpn_ConnectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ConnectResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "success"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if self.success != false {
            try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Nym_Vpn_ConnectResponse, rhs: Nym_Vpn_ConnectResponse) -> Bool {
        if lhs.success != rhs.success {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Nym_Vpn_DisconnectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DisconnectRequest"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Nym_Vpn_DisconnectRequest, rhs: Nym_Vpn_DisconnectRequest) -> Bool {
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Nym_Vpn_DisconnectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DisconnectResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "success"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if self.success != false {
            try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Nym_Vpn_DisconnectResponse, rhs: Nym_Vpn_DisconnectResponse) -> Bool {
        if lhs.success != rhs.success {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Nym_Vpn_ConnectionDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ConnectionDetails"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "entry_gateway"),
        2: .same(proto: "since"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.entryGateway) }()
            case 2: try { try decoder.decodeSingularMessageField(value: &self._since) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !self.entryGateway.isEmpty {
            try visitor.visitSingularStringField(value: self.entryGateway, fieldNumber: 1)
        }
        try { if let v = self._since {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Nym_Vpn_ConnectionDetails, rhs: Nym_Vpn_ConnectionDetails) -> Bool {
        if lhs.entryGateway != rhs.entryGateway {return false}
        if lhs._since != rhs._since {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Nym_Vpn_StatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".StatusRequest"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Nym_Vpn_StatusRequest, rhs: Nym_Vpn_StatusRequest) -> Bool {
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Nym_Vpn_StatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".StatusResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "status"),
        2: .same(proto: "details"),
        3: .same(proto: "error"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
            case 2: try { try decoder.decodeSingularMessageField(value: &self._details) }()
            case 3: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if self.status != .statusUnspecified {
            try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
        }
        try { if let v = self._details {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Nym_Vpn_StatusResponse, rhs: Nym_Vpn_StatusResponse) -> Bool {
        if lhs.status != rhs.status {return false}
        if lhs._details != rhs._details {return false}
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Nym_Vpn_ConnectionStateChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ConnectionStateChange"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "status"),
        2: .same(proto: "error"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
            case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if self.status != .statusUnspecified {
            try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
        }
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Nym_Vpn_ConnectionStateChange, rhs: Nym_Vpn_ConnectionStateChange) -> Bool {
        if lhs.status != rhs.status {return false}
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Nym_Vpn_ConnectionStatusUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ConnectionStatusUpdate"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "message"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.message.isEmpty {
            try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Nym_Vpn_ConnectionStatusUpdate, rhs: Nym_Vpn_ConnectionStatusUpdate) -> Bool {
        if lhs.message != rhs.message {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Nym_Vpn_Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Error"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "kind"),
        2: .same(proto: "message"),
        3: .same(proto: "details"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
            case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.details) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if self.kind != .unspecified {
            try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
        }
        if !self.message.isEmpty {
            try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
        }
        if !self.details.isEmpty {
            try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.details, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Nym_Vpn_Error, rhs: Nym_Vpn_Error) -> Bool {
        if lhs.kind != rhs.kind {return false}
        if lhs.message != rhs.message {return false}
        if lhs.details != rhs.details {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Nym_Vpn_Error.ErrorType: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "ERROR_TYPE_UNSPECIFIED"),
        1: .same(proto: "UNHANDLED"),
        2: .same(proto: "NO_VALID_CREDENTIALS"),
        6: .same(proto: "TIMEOUT"),
        8: .same(proto: "GATEWAY_DIRECTORY"),
    ]
}

extension Nym_Vpn_ImportUserCredentialRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ImportUserCredentialRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "credential"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularBytesField(value: &self.credential) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.credential.isEmpty {
            try visitor.visitSingularBytesField(value: self.credential, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Nym_Vpn_ImportUserCredentialRequest, rhs: Nym_Vpn_ImportUserCredentialRequest) -> Bool {
        if lhs.credential != rhs.credential {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Nym_Vpn_ImportUserCredentialResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ImportUserCredentialResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "success"),
        2: .same(proto: "error"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
            case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if self.success != false {
            try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
        }
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Nym_Vpn_ImportUserCredentialResponse, rhs: Nym_Vpn_ImportUserCredentialResponse) -> Bool {
        if lhs.success != rhs.success {return false}
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Nym_Vpn_ImportError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ImportError"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "kind"),
        2: .same(proto: "message"),
        3: .same(proto: "details"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
            case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.details) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if self.kind != .unspecified {
            try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
        }
        if !self.message.isEmpty {
            try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
        }
        if !self.details.isEmpty {
            try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.details, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func ==(lhs: Nym_Vpn_ImportError, rhs: Nym_Vpn_ImportError) -> Bool {
        if lhs.kind != rhs.kind {return false}
        if lhs.message != rhs.message {return false}
        if lhs.details != rhs.details {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Nym_Vpn_ImportError.ImportErrorType: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "IMPORT_ERROR_TYPE_UNSPECIFIED"),
        1: .same(proto: "VPN_RUNNING"),
        2: .same(proto: "CREDENTIAL_ALREADY_IMPORTED"),
        3: .same(proto: "STORAGE_ERROR"),
        4: .same(proto: "DESERIALIZATION_FAILURE"),
        5: .same(proto: "CREDENTIAL_EXPIRED"),
    ]
}
// swiftlint:enable all
