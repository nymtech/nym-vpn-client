// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: vpn.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Nym_Vpn_ConnectionStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case statusUnspecified // = 0
  case unknown // = 1
  case notConnected // = 2
  case connecting // = 3
  case connected // = 4
  case disconnecting // = 5
  case connectionFailed // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .statusUnspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .statusUnspecified
    case 1: self = .unknown
    case 2: self = .notConnected
    case 3: self = .connecting
    case 4: self = .connected
    case 5: self = .disconnecting
    case 6: self = .connectionFailed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .statusUnspecified: return 0
    case .unknown: return 1
    case .notConnected: return 2
    case .connecting: return 3
    case .connected: return 4
    case .disconnecting: return 5
    case .connectionFailed: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Nym_Vpn_ConnectionStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Nym_Vpn_ConnectionStatus] = [
    .statusUnspecified,
    .unknown,
    .notConnected,
    .connecting,
    .connected,
    .disconnecting,
    .connectionFailed,
  ]
}

#endif  // swift(>=4.2)

enum Nym_Vpn_GatewayType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case mixnetEntry // = 1
  case mixnetExit // = 2
  case wg // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .mixnetEntry
    case 2: self = .mixnetExit
    case 3: self = .wg
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .mixnetEntry: return 1
    case .mixnetExit: return 2
    case .wg: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Nym_Vpn_GatewayType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Nym_Vpn_GatewayType] = [
    .unspecified,
    .mixnetEntry,
    .mixnetExit,
    .wg,
  ]
}

#endif  // swift(>=4.2)

enum Nym_Vpn_MnemonicState: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case notStored // = 1
  case stored // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .notStored
    case 2: self = .stored
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .notStored: return 1
    case .stored: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Nym_Vpn_MnemonicState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Nym_Vpn_MnemonicState] = [
    .unspecified,
    .notStored,
    .stored,
  ]
}

#endif  // swift(>=4.2)

enum Nym_Vpn_AccountState: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case notRegistered // = 1
  case inactive // = 2
  case active // = 3
  case deleteMe // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .notRegistered
    case 2: self = .inactive
    case 3: self = .active
    case 4: self = .deleteMe
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .notRegistered: return 1
    case .inactive: return 2
    case .active: return 3
    case .deleteMe: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Nym_Vpn_AccountState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Nym_Vpn_AccountState] = [
    .unspecified,
    .notRegistered,
    .inactive,
    .active,
    .deleteMe,
  ]
}

#endif  // swift(>=4.2)

enum Nym_Vpn_SubscriptionState: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case notRegistered // = 1
  case pending // = 2
  case active // = 3
  case complete // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .notRegistered
    case 2: self = .pending
    case 3: self = .active
    case 4: self = .complete
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .notRegistered: return 1
    case .pending: return 2
    case .active: return 3
    case .complete: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Nym_Vpn_SubscriptionState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Nym_Vpn_SubscriptionState] = [
    .unspecified,
    .notRegistered,
    .pending,
    .active,
    .complete,
  ]
}

#endif  // swift(>=4.2)

enum Nym_Vpn_DeviceState: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case notRegistered // = 1
  case inactive // = 2
  case active // = 3
  case deleteMe // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .notRegistered
    case 2: self = .inactive
    case 3: self = .active
    case 4: self = .deleteMe
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .notRegistered: return 1
    case .inactive: return 2
    case .active: return 3
    case .deleteMe: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Nym_Vpn_DeviceState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Nym_Vpn_DeviceState] = [
    .unspecified,
    .notRegistered,
    .inactive,
    .active,
    .deleteMe,
  ]
}

#endif  // swift(>=4.2)

struct Nym_Vpn_Empty {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Represents the identity of a gateway
struct Nym_Vpn_Gateway {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Represents a nym-address of the form id.enc@gateway
struct Nym_Vpn_Address {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nymAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_Location {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var twoLetterIsoCountryCode: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_EntryNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entryNodeEnum: Nym_Vpn_EntryNode.OneOf_EntryNodeEnum? = nil

  var gateway: Nym_Vpn_Gateway {
    get {
      if case .gateway(let v)? = entryNodeEnum {return v}
      return Nym_Vpn_Gateway()
    }
    set {entryNodeEnum = .gateway(newValue)}
  }

  var location: Nym_Vpn_Location {
    get {
      if case .location(let v)? = entryNodeEnum {return v}
      return Nym_Vpn_Location()
    }
    set {entryNodeEnum = .location(newValue)}
  }

  var randomLowLatency: Nym_Vpn_Empty {
    get {
      if case .randomLowLatency(let v)? = entryNodeEnum {return v}
      return Nym_Vpn_Empty()
    }
    set {entryNodeEnum = .randomLowLatency(newValue)}
  }

  var random: Nym_Vpn_Empty {
    get {
      if case .random(let v)? = entryNodeEnum {return v}
      return Nym_Vpn_Empty()
    }
    set {entryNodeEnum = .random(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_EntryNodeEnum: Equatable {
    case gateway(Nym_Vpn_Gateway)
    case location(Nym_Vpn_Location)
    case randomLowLatency(Nym_Vpn_Empty)
    case random(Nym_Vpn_Empty)

  #if !swift(>=4.1)
    static func ==(lhs: Nym_Vpn_EntryNode.OneOf_EntryNodeEnum, rhs: Nym_Vpn_EntryNode.OneOf_EntryNodeEnum) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.gateway, .gateway): return {
        guard case .gateway(let l) = lhs, case .gateway(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.location, .location): return {
        guard case .location(let l) = lhs, case .location(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.randomLowLatency, .randomLowLatency): return {
        guard case .randomLowLatency(let l) = lhs, case .randomLowLatency(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.random, .random): return {
        guard case .random(let l) = lhs, case .random(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Nym_Vpn_ExitNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var exitNodeEnum: Nym_Vpn_ExitNode.OneOf_ExitNodeEnum? = nil

  var address: Nym_Vpn_Address {
    get {
      if case .address(let v)? = exitNodeEnum {return v}
      return Nym_Vpn_Address()
    }
    set {exitNodeEnum = .address(newValue)}
  }

  var gateway: Nym_Vpn_Gateway {
    get {
      if case .gateway(let v)? = exitNodeEnum {return v}
      return Nym_Vpn_Gateway()
    }
    set {exitNodeEnum = .gateway(newValue)}
  }

  var location: Nym_Vpn_Location {
    get {
      if case .location(let v)? = exitNodeEnum {return v}
      return Nym_Vpn_Location()
    }
    set {exitNodeEnum = .location(newValue)}
  }

  var random: Nym_Vpn_Empty {
    get {
      if case .random(let v)? = exitNodeEnum {return v}
      return Nym_Vpn_Empty()
    }
    set {exitNodeEnum = .random(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ExitNodeEnum: Equatable {
    case address(Nym_Vpn_Address)
    case gateway(Nym_Vpn_Gateway)
    case location(Nym_Vpn_Location)
    case random(Nym_Vpn_Empty)

  #if !swift(>=4.1)
    static func ==(lhs: Nym_Vpn_ExitNode.OneOf_ExitNodeEnum, rhs: Nym_Vpn_ExitNode.OneOf_ExitNodeEnum) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.address, .address): return {
        guard case .address(let l) = lhs, case .address(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.gateway, .gateway): return {
        guard case .gateway(let l) = lhs, case .gateway(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.location, .location): return {
        guard case .location(let l) = lhs, case .location(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.random, .random): return {
        guard case .random(let l) = lhs, case .random(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Nym_Vpn_MixConnectedStateDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nymAddress: Nym_Vpn_Address {
    get {return _nymAddress ?? Nym_Vpn_Address()}
    set {_nymAddress = newValue}
  }
  /// Returns true if `nymAddress` has been explicitly set.
  var hasNymAddress: Bool {return self._nymAddress != nil}
  /// Clears the value of `nymAddress`. Subsequent reads from it will return its default value.
  mutating func clearNymAddress() {self._nymAddress = nil}

  var exitIpr: Nym_Vpn_Address {
    get {return _exitIpr ?? Nym_Vpn_Address()}
    set {_exitIpr = newValue}
  }
  /// Returns true if `exitIpr` has been explicitly set.
  var hasExitIpr: Bool {return self._exitIpr != nil}
  /// Clears the value of `exitIpr`. Subsequent reads from it will return its default value.
  mutating func clearExitIpr() {self._exitIpr = nil}

  var ipv4: String = String()

  var ipv6: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _nymAddress: Nym_Vpn_Address? = nil
  fileprivate var _exitIpr: Nym_Vpn_Address? = nil
}

struct Nym_Vpn_WgConnectedStateDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entryIpv4: String = String()

  var exitIpv4: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_ConnectedStateDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var connectedStateDetails: Nym_Vpn_ConnectedStateDetails.OneOf_ConnectedStateDetails? = nil

  var mix: Nym_Vpn_MixConnectedStateDetails {
    get {
      if case .mix(let v)? = connectedStateDetails {return v}
      return Nym_Vpn_MixConnectedStateDetails()
    }
    set {connectedStateDetails = .mix(newValue)}
  }

  var wg: Nym_Vpn_WgConnectedStateDetails {
    get {
      if case .wg(let v)? = connectedStateDetails {return v}
      return Nym_Vpn_WgConnectedStateDetails()
    }
    set {connectedStateDetails = .wg(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ConnectedStateDetails: Equatable {
    case mix(Nym_Vpn_MixConnectedStateDetails)
    case wg(Nym_Vpn_WgConnectedStateDetails)

  #if !swift(>=4.1)
    static func ==(lhs: Nym_Vpn_ConnectedStateDetails.OneOf_ConnectedStateDetails, rhs: Nym_Vpn_ConnectedStateDetails.OneOf_ConnectedStateDetails) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.mix, .mix): return {
        guard case .mix(let l) = lhs, case .mix(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.wg, .wg): return {
        guard case .wg(let l) = lhs, case .wg(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Nym_Vpn_Dns {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ip: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_Url {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var url: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Inspired by
/// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/User-Agent
/// Forward slashes '/' are not valid
struct Nym_Vpn_UserAgent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Example:
  ///    nym-vpn-app
  ///    nym-vpnd
  ///    nym-vpn-cli
  var application: String = String()

  /// Format: version[-optional] [(daemon version[-optional])]
  /// Example:
  ///    0.1.8
  ///    0.1.8-debug (0.1.6)
  ///    0.2.1-fdroid
  var version: String = String()

  /// Format: OS; OS version; CPU
  /// Example:
  ///    Windows NT 6.1; Win64; x64
  ///    Macintosh; Intel Mac OS X 14.6.1
  ///    iPad; U; CPU OS 3_2 like Mac OS X; en-us
  var platform: String = String()

  /// Format: git hash [(daemon git hash)]
  /// Commit hash should be at least 7 characters long
  /// Example:
  ///    4h9fk59 (4kdufle)
  ///    4h9fk59
  var gitCommit: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_DenomDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var base: String = String()

  var display: String = String()

  var displayExponent: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_ChainDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bech32AccountPrefix: String = String()

  var mixDenom: Nym_Vpn_DenomDetails {
    get {return _mixDenom ?? Nym_Vpn_DenomDetails()}
    set {_mixDenom = newValue}
  }
  /// Returns true if `mixDenom` has been explicitly set.
  var hasMixDenom: Bool {return self._mixDenom != nil}
  /// Clears the value of `mixDenom`. Subsequent reads from it will return its default value.
  mutating func clearMixDenom() {self._mixDenom = nil}

  var stakeDenom: Nym_Vpn_DenomDetails {
    get {return _stakeDenom ?? Nym_Vpn_DenomDetails()}
    set {_stakeDenom = newValue}
  }
  /// Returns true if `stakeDenom` has been explicitly set.
  var hasStakeDenom: Bool {return self._stakeDenom != nil}
  /// Clears the value of `stakeDenom`. Subsequent reads from it will return its default value.
  mutating func clearStakeDenom() {self._stakeDenom = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mixDenom: Nym_Vpn_DenomDetails? = nil
  fileprivate var _stakeDenom: Nym_Vpn_DenomDetails? = nil
}

struct Nym_Vpn_NymContracts {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mixnetContractAddress: String {
    get {return _mixnetContractAddress ?? String()}
    set {_mixnetContractAddress = newValue}
  }
  /// Returns true if `mixnetContractAddress` has been explicitly set.
  var hasMixnetContractAddress: Bool {return self._mixnetContractAddress != nil}
  /// Clears the value of `mixnetContractAddress`. Subsequent reads from it will return its default value.
  mutating func clearMixnetContractAddress() {self._mixnetContractAddress = nil}

  var vestingContractAddress: String {
    get {return _vestingContractAddress ?? String()}
    set {_vestingContractAddress = newValue}
  }
  /// Returns true if `vestingContractAddress` has been explicitly set.
  var hasVestingContractAddress: Bool {return self._vestingContractAddress != nil}
  /// Clears the value of `vestingContractAddress`. Subsequent reads from it will return its default value.
  mutating func clearVestingContractAddress() {self._vestingContractAddress = nil}

  var ecashContractAddress: String {
    get {return _ecashContractAddress ?? String()}
    set {_ecashContractAddress = newValue}
  }
  /// Returns true if `ecashContractAddress` has been explicitly set.
  var hasEcashContractAddress: Bool {return self._ecashContractAddress != nil}
  /// Clears the value of `ecashContractAddress`. Subsequent reads from it will return its default value.
  mutating func clearEcashContractAddress() {self._ecashContractAddress = nil}

  var groupContractAddress: String {
    get {return _groupContractAddress ?? String()}
    set {_groupContractAddress = newValue}
  }
  /// Returns true if `groupContractAddress` has been explicitly set.
  var hasGroupContractAddress: Bool {return self._groupContractAddress != nil}
  /// Clears the value of `groupContractAddress`. Subsequent reads from it will return its default value.
  mutating func clearGroupContractAddress() {self._groupContractAddress = nil}

  var multisigContractAddress: String {
    get {return _multisigContractAddress ?? String()}
    set {_multisigContractAddress = newValue}
  }
  /// Returns true if `multisigContractAddress` has been explicitly set.
  var hasMultisigContractAddress: Bool {return self._multisigContractAddress != nil}
  /// Clears the value of `multisigContractAddress`. Subsequent reads from it will return its default value.
  mutating func clearMultisigContractAddress() {self._multisigContractAddress = nil}

  var coconutDkgContractAddress: String {
    get {return _coconutDkgContractAddress ?? String()}
    set {_coconutDkgContractAddress = newValue}
  }
  /// Returns true if `coconutDkgContractAddress` has been explicitly set.
  var hasCoconutDkgContractAddress: Bool {return self._coconutDkgContractAddress != nil}
  /// Clears the value of `coconutDkgContractAddress`. Subsequent reads from it will return its default value.
  mutating func clearCoconutDkgContractAddress() {self._coconutDkgContractAddress = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mixnetContractAddress: String? = nil
  fileprivate var _vestingContractAddress: String? = nil
  fileprivate var _ecashContractAddress: String? = nil
  fileprivate var _groupContractAddress: String? = nil
  fileprivate var _multisigContractAddress: String? = nil
  fileprivate var _coconutDkgContractAddress: String? = nil
}

struct Nym_Vpn_NymNetworkDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var networkName: String = String()

  var chainDetails: Nym_Vpn_ChainDetails {
    get {return _chainDetails ?? Nym_Vpn_ChainDetails()}
    set {_chainDetails = newValue}
  }
  /// Returns true if `chainDetails` has been explicitly set.
  var hasChainDetails: Bool {return self._chainDetails != nil}
  /// Clears the value of `chainDetails`. Subsequent reads from it will return its default value.
  mutating func clearChainDetails() {self._chainDetails = nil}

  var endpoints: [Nym_Vpn_ValidatorDetails] = []

  var contracts: Nym_Vpn_NymContracts {
    get {return _contracts ?? Nym_Vpn_NymContracts()}
    set {_contracts = newValue}
  }
  /// Returns true if `contracts` has been explicitly set.
  var hasContracts: Bool {return self._contracts != nil}
  /// Clears the value of `contracts`. Subsequent reads from it will return its default value.
  mutating func clearContracts() {self._contracts = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _chainDetails: Nym_Vpn_ChainDetails? = nil
  fileprivate var _contracts: Nym_Vpn_NymContracts? = nil
}

struct Nym_Vpn_NymVpnNetworkDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nymVpnApiURL: Nym_Vpn_Url {
    get {return _nymVpnApiURL ?? Nym_Vpn_Url()}
    set {_nymVpnApiURL = newValue}
  }
  /// Returns true if `nymVpnApiURL` has been explicitly set.
  var hasNymVpnApiURL: Bool {return self._nymVpnApiURL != nil}
  /// Clears the value of `nymVpnApiURL`. Subsequent reads from it will return its default value.
  mutating func clearNymVpnApiURL() {self._nymVpnApiURL = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _nymVpnApiURL: Nym_Vpn_Url? = nil
}

struct Nym_Vpn_ValidatorDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nyxdURL: Nym_Vpn_Url {
    get {return _nyxdURL ?? Nym_Vpn_Url()}
    set {_nyxdURL = newValue}
  }
  /// Returns true if `nyxdURL` has been explicitly set.
  var hasNyxdURL: Bool {return self._nyxdURL != nil}
  /// Clears the value of `nyxdURL`. Subsequent reads from it will return its default value.
  mutating func clearNyxdURL() {self._nyxdURL = nil}

  var websocketURL: Nym_Vpn_Url {
    get {return _websocketURL ?? Nym_Vpn_Url()}
    set {_websocketURL = newValue}
  }
  /// Returns true if `websocketURL` has been explicitly set.
  var hasWebsocketURL: Bool {return self._websocketURL != nil}
  /// Clears the value of `websocketURL`. Subsequent reads from it will return its default value.
  mutating func clearWebsocketURL() {self._websocketURL = nil}

  var apiURL: Nym_Vpn_Url {
    get {return _apiURL ?? Nym_Vpn_Url()}
    set {_apiURL = newValue}
  }
  /// Returns true if `apiURL` has been explicitly set.
  var hasApiURL: Bool {return self._apiURL != nil}
  /// Clears the value of `apiURL`. Subsequent reads from it will return its default value.
  mutating func clearApiURL() {self._apiURL = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _nyxdURL: Nym_Vpn_Url? = nil
  fileprivate var _websocketURL: Nym_Vpn_Url? = nil
  fileprivate var _apiURL: Nym_Vpn_Url? = nil
}

struct Nym_Vpn_InfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_InfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: String {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  var buildTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._buildTimestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._buildTimestamp = newValue}
  }
  /// Returns true if `buildTimestamp` has been explicitly set.
  var hasBuildTimestamp: Bool {return _storage._buildTimestamp != nil}
  /// Clears the value of `buildTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearBuildTimestamp() {_uniqueStorage()._buildTimestamp = nil}

  var triple: String {
    get {return _storage._triple}
    set {_uniqueStorage()._triple = newValue}
  }

  var platform: String {
    get {return _storage._platform}
    set {_uniqueStorage()._platform = newValue}
  }

  var gitCommit: String {
    get {return _storage._gitCommit}
    set {_uniqueStorage()._gitCommit = newValue}
  }

  var nymNetwork: Nym_Vpn_NymNetworkDetails {
    get {return _storage._nymNetwork ?? Nym_Vpn_NymNetworkDetails()}
    set {_uniqueStorage()._nymNetwork = newValue}
  }
  /// Returns true if `nymNetwork` has been explicitly set.
  var hasNymNetwork: Bool {return _storage._nymNetwork != nil}
  /// Clears the value of `nymNetwork`. Subsequent reads from it will return its default value.
  mutating func clearNymNetwork() {_uniqueStorage()._nymNetwork = nil}

  var nymVpnNetwork: Nym_Vpn_NymVpnNetworkDetails {
    get {return _storage._nymVpnNetwork ?? Nym_Vpn_NymVpnNetworkDetails()}
    set {_uniqueStorage()._nymVpnNetwork = newValue}
  }
  /// Returns true if `nymVpnNetwork` has been explicitly set.
  var hasNymVpnNetwork: Bool {return _storage._nymVpnNetwork != nil}
  /// Clears the value of `nymVpnNetwork`. Subsequent reads from it will return its default value.
  mutating func clearNymVpnNetwork() {_uniqueStorage()._nymVpnNetwork = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Nym_Vpn_SetNetworkRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var network: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_SetNetworkResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var error: Nym_Vpn_SetNetworkRequestError {
    get {return _error ?? Nym_Vpn_SetNetworkRequestError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Nym_Vpn_SetNetworkRequestError? = nil
}

struct Nym_Vpn_SetNetworkRequestError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Nym_Vpn_SetNetworkRequestError.SetNetworkRequestErrorType = .unspecified

  /// Internal message for logging and debugging
  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum SetNetworkRequestErrorType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unspecified // = 0

    /// Unspecified internal error
    case `internal` // = 1

    /// The network name provided is not valid
    case invalidNetworkName // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .internal
      case 2: self = .invalidNetworkName
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .internal: return 1
      case .invalidNetworkName: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Nym_Vpn_SetNetworkRequestError.SetNetworkRequestErrorType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Nym_Vpn_SetNetworkRequestError.SetNetworkRequestErrorType] = [
    .unspecified,
    .internal,
    .invalidNetworkName,
  ]
}

#endif  // swift(>=4.2)

struct Nym_Vpn_Threshold {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var minPerformance: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_ConnectRequestError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Nym_Vpn_ConnectRequestError.ConnectRequestErrorType = .unspecified

  /// Internal message for logging and debugging
  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ConnectRequestErrorType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unspecified // = 0

    /// Unspecified internal error
    case `internal` // = 1

    /// No account recovery phrase stored
    case noAccountStored // = 2

    /// The account is not active
    case accountNotActive // = 3

    /// The account does not have an active subscription
    case noActiveSubscription // = 4

    /// The device is not registered
    case deviceNotRegistered // = 5

    /// The device is not active
    /// NOTE: in the future we will try to re-active an inactive device on
    /// connect
    case deviceNotActive // = 6
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .internal
      case 2: self = .noAccountStored
      case 3: self = .accountNotActive
      case 4: self = .noActiveSubscription
      case 5: self = .deviceNotRegistered
      case 6: self = .deviceNotActive
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .internal: return 1
      case .noAccountStored: return 2
      case .accountNotActive: return 3
      case .noActiveSubscription: return 4
      case .deviceNotRegistered: return 5
      case .deviceNotActive: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Nym_Vpn_ConnectRequestError.ConnectRequestErrorType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Nym_Vpn_ConnectRequestError.ConnectRequestErrorType] = [
    .unspecified,
    .internal,
    .noAccountStored,
    .accountNotActive,
    .noActiveSubscription,
    .deviceNotRegistered,
    .deviceNotActive,
  ]
}

#endif  // swift(>=4.2)

struct Nym_Vpn_ConnectRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entry: Nym_Vpn_EntryNode {
    get {return _entry ?? Nym_Vpn_EntryNode()}
    set {_entry = newValue}
  }
  /// Returns true if `entry` has been explicitly set.
  var hasEntry: Bool {return self._entry != nil}
  /// Clears the value of `entry`. Subsequent reads from it will return its default value.
  mutating func clearEntry() {self._entry = nil}

  var exit: Nym_Vpn_ExitNode {
    get {return _exit ?? Nym_Vpn_ExitNode()}
    set {_exit = newValue}
  }
  /// Returns true if `exit` has been explicitly set.
  var hasExit: Bool {return self._exit != nil}
  /// Clears the value of `exit`. Subsequent reads from it will return its default value.
  mutating func clearExit() {self._exit = nil}

  var dns: Nym_Vpn_Dns {
    get {return _dns ?? Nym_Vpn_Dns()}
    set {_dns = newValue}
  }
  /// Returns true if `dns` has been explicitly set.
  var hasDns: Bool {return self._dns != nil}
  /// Clears the value of `dns`. Subsequent reads from it will return its default value.
  mutating func clearDns() {self._dns = nil}

  var disableRouting: Bool = false

  var enableTwoHop: Bool = false

  var disablePoissonRate: Bool = false

  var disableBackgroundCoverTraffic: Bool = false

  var enableCredentialsMode: Bool = false

  var userAgent: Nym_Vpn_UserAgent {
    get {return _userAgent ?? Nym_Vpn_UserAgent()}
    set {_userAgent = newValue}
  }
  /// Returns true if `userAgent` has been explicitly set.
  var hasUserAgent: Bool {return self._userAgent != nil}
  /// Clears the value of `userAgent`. Subsequent reads from it will return its default value.
  mutating func clearUserAgent() {self._userAgent = nil}

  /// Optional thresholds
  var minMixnodePerformance: Nym_Vpn_Threshold {
    get {return _minMixnodePerformance ?? Nym_Vpn_Threshold()}
    set {_minMixnodePerformance = newValue}
  }
  /// Returns true if `minMixnodePerformance` has been explicitly set.
  var hasMinMixnodePerformance: Bool {return self._minMixnodePerformance != nil}
  /// Clears the value of `minMixnodePerformance`. Subsequent reads from it will return its default value.
  mutating func clearMinMixnodePerformance() {self._minMixnodePerformance = nil}

  var minGatewayMixnetPerformance: Nym_Vpn_Threshold {
    get {return _minGatewayMixnetPerformance ?? Nym_Vpn_Threshold()}
    set {_minGatewayMixnetPerformance = newValue}
  }
  /// Returns true if `minGatewayMixnetPerformance` has been explicitly set.
  var hasMinGatewayMixnetPerformance: Bool {return self._minGatewayMixnetPerformance != nil}
  /// Clears the value of `minGatewayMixnetPerformance`. Subsequent reads from it will return its default value.
  mutating func clearMinGatewayMixnetPerformance() {self._minGatewayMixnetPerformance = nil}

  var minGatewayVpnPerformance: Nym_Vpn_Threshold {
    get {return _minGatewayVpnPerformance ?? Nym_Vpn_Threshold()}
    set {_minGatewayVpnPerformance = newValue}
  }
  /// Returns true if `minGatewayVpnPerformance` has been explicitly set.
  var hasMinGatewayVpnPerformance: Bool {return self._minGatewayVpnPerformance != nil}
  /// Clears the value of `minGatewayVpnPerformance`. Subsequent reads from it will return its default value.
  mutating func clearMinGatewayVpnPerformance() {self._minGatewayVpnPerformance = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _entry: Nym_Vpn_EntryNode? = nil
  fileprivate var _exit: Nym_Vpn_ExitNode? = nil
  fileprivate var _dns: Nym_Vpn_Dns? = nil
  fileprivate var _userAgent: Nym_Vpn_UserAgent? = nil
  fileprivate var _minMixnodePerformance: Nym_Vpn_Threshold? = nil
  fileprivate var _minGatewayMixnetPerformance: Nym_Vpn_Threshold? = nil
  fileprivate var _minGatewayVpnPerformance: Nym_Vpn_Threshold? = nil
}

struct Nym_Vpn_ConnectResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// TODO: consider simplifying by removing the bool
  var success: Bool = false

  var error: Nym_Vpn_ConnectRequestError {
    get {return _error ?? Nym_Vpn_ConnectRequestError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Nym_Vpn_ConnectRequestError? = nil
}

struct Nym_Vpn_DisconnectRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_DisconnectResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var success: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_ConnectionDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entryGateway: Nym_Vpn_Gateway {
    get {return _entryGateway ?? Nym_Vpn_Gateway()}
    set {_entryGateway = newValue}
  }
  /// Returns true if `entryGateway` has been explicitly set.
  var hasEntryGateway: Bool {return self._entryGateway != nil}
  /// Clears the value of `entryGateway`. Subsequent reads from it will return its default value.
  mutating func clearEntryGateway() {self._entryGateway = nil}

  var exitGateway: Nym_Vpn_Gateway {
    get {return _exitGateway ?? Nym_Vpn_Gateway()}
    set {_exitGateway = newValue}
  }
  /// Returns true if `exitGateway` has been explicitly set.
  var hasExitGateway: Bool {return self._exitGateway != nil}
  /// Clears the value of `exitGateway`. Subsequent reads from it will return its default value.
  mutating func clearExitGateway() {self._exitGateway = nil}

  var protocolDetails: Nym_Vpn_ConnectedStateDetails {
    get {return _protocolDetails ?? Nym_Vpn_ConnectedStateDetails()}
    set {_protocolDetails = newValue}
  }
  /// Returns true if `protocolDetails` has been explicitly set.
  var hasProtocolDetails: Bool {return self._protocolDetails != nil}
  /// Clears the value of `protocolDetails`. Subsequent reads from it will return its default value.
  mutating func clearProtocolDetails() {self._protocolDetails = nil}

  var since: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _since ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_since = newValue}
  }
  /// Returns true if `since` has been explicitly set.
  var hasSince: Bool {return self._since != nil}
  /// Clears the value of `since`. Subsequent reads from it will return its default value.
  mutating func clearSince() {self._since = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _entryGateway: Nym_Vpn_Gateway? = nil
  fileprivate var _exitGateway: Nym_Vpn_Gateway? = nil
  fileprivate var _protocolDetails: Nym_Vpn_ConnectedStateDetails? = nil
  fileprivate var _since: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Nym_Vpn_StatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_StatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Nym_Vpn_ConnectionStatus = .statusUnspecified

  var details: Nym_Vpn_ConnectionDetails {
    get {return _details ?? Nym_Vpn_ConnectionDetails()}
    set {_details = newValue}
  }
  /// Returns true if `details` has been explicitly set.
  var hasDetails: Bool {return self._details != nil}
  /// Clears the value of `details`. Subsequent reads from it will return its default value.
  mutating func clearDetails() {self._details = nil}

  var error: Nym_Vpn_Error {
    get {return _error ?? Nym_Vpn_Error()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _details: Nym_Vpn_ConnectionDetails? = nil
  fileprivate var _error: Nym_Vpn_Error? = nil
}

struct Nym_Vpn_ConnectionStateChange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Nym_Vpn_ConnectionStatus = .statusUnspecified

  var error: Nym_Vpn_Error {
    get {return _error ?? Nym_Vpn_Error()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Nym_Vpn_Error? = nil
}

struct Nym_Vpn_ConnectionStatusUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Nym_Vpn_ConnectionStatusUpdate.StatusType = .unspecified

  /// Detailed message for logging and debugging
  var message: String = String()

  /// Optional additional details
  var details: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum StatusType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unspecified // = 0

    /// Status message that is not mapped to a specific type
    case unknown // = 1

    /// Connection to entry gateway established
    /// NOTE: currently not implemented by vpnd
    case entryGatewayConnectionEstablished // = 2

    /// Connection to exit router established
    /// NOTE: currently not implemented by vpnd
    case exitRouterConnectionEstablished // = 3

    /// End-to-end tunnel established and operational
    case tunnelEndToEndConnectionEstablished // = 4

    /// Entry gateway not routing our mixnet messages
    case entryGatewayNotRoutingMixnetMessages // = 5

    /// The exit router is not responding to IPv4 traffic
    case exitRouterNotRespondingToIpv4Ping // = 6

    /// The exit router is not responding to IPv6 traffic
    case exitRouterNotRespondingToIpv6Ping // = 7

    /// The ip packet router connected to on the exit side is not routing IPv4 traffic
    case exitRouterNotRoutingIpv4Traffic // = 8

    /// The ip packet router connected to on the exit side is not routing IPv6 traffic
    case exitRouterNotRoutingIpv6Traffic // = 9

    /// The end-to-end IPv4 connection appears to be operation correctly
    case connectionOkIpv4 // = 10

    /// The end-to-end IPv6 connection appears to be operation correctly
    case connectionOkIpv6 // = 11

    /// Remaining bandwidth available
    case remainingBandwidth // = 12

    /// The user has run out of available bandwidth
    case noBandwidth // = 13

    /// Wireguard tunnel errors sent through the status channel. This error case
    /// will go away in the future.
    case wgTunnelError // = 14
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .unknown
      case 2: self = .entryGatewayConnectionEstablished
      case 3: self = .exitRouterConnectionEstablished
      case 4: self = .tunnelEndToEndConnectionEstablished
      case 5: self = .entryGatewayNotRoutingMixnetMessages
      case 6: self = .exitRouterNotRespondingToIpv4Ping
      case 7: self = .exitRouterNotRespondingToIpv6Ping
      case 8: self = .exitRouterNotRoutingIpv4Traffic
      case 9: self = .exitRouterNotRoutingIpv6Traffic
      case 10: self = .connectionOkIpv4
      case 11: self = .connectionOkIpv6
      case 12: self = .remainingBandwidth
      case 13: self = .noBandwidth
      case 14: self = .wgTunnelError
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .unknown: return 1
      case .entryGatewayConnectionEstablished: return 2
      case .exitRouterConnectionEstablished: return 3
      case .tunnelEndToEndConnectionEstablished: return 4
      case .entryGatewayNotRoutingMixnetMessages: return 5
      case .exitRouterNotRespondingToIpv4Ping: return 6
      case .exitRouterNotRespondingToIpv6Ping: return 7
      case .exitRouterNotRoutingIpv4Traffic: return 8
      case .exitRouterNotRoutingIpv6Traffic: return 9
      case .connectionOkIpv4: return 10
      case .connectionOkIpv6: return 11
      case .remainingBandwidth: return 12
      case .noBandwidth: return 13
      case .wgTunnelError: return 14
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Nym_Vpn_ConnectionStatusUpdate.StatusType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Nym_Vpn_ConnectionStatusUpdate.StatusType] = [
    .unspecified,
    .unknown,
    .entryGatewayConnectionEstablished,
    .exitRouterConnectionEstablished,
    .tunnelEndToEndConnectionEstablished,
    .entryGatewayNotRoutingMixnetMessages,
    .exitRouterNotRespondingToIpv4Ping,
    .exitRouterNotRespondingToIpv6Ping,
    .exitRouterNotRoutingIpv4Traffic,
    .exitRouterNotRoutingIpv6Traffic,
    .connectionOkIpv4,
    .connectionOkIpv6,
    .remainingBandwidth,
    .noBandwidth,
    .wgTunnelError,
  ]
}

#endif  // swift(>=4.2)

/// TODO: consider rename this to something like `ConnectionError`, to
/// distinguish from all other types of errors.
struct Nym_Vpn_Error {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Nym_Vpn_Error.ErrorType = .unspecified

  /// Detailed error message for logging and debugging
  var message: String = String()

  /// Optional additional details
  var details: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ErrorType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unspecified // = 0

    /// An error that was not explicitly handled by the vpn service. This should
    /// not happen but it will while we iterate on mapping out all possible
    /// errors
    case unhandled // = 1

    /// The vpn exiting with an error that isn't handled by the automatic
    /// conversion. If this happens it's a bug.
    case unhandledExit // = 49

    /// An internal error that indicates a programmer error and should not
    /// happen. If it did an invariant was probably broken at some point.
    case `internal` // = 33

    /// If the credential storage does not contain any valid credentials when
    /// connecting
    case noValidCredentials // = 2

    /// Generic connection timeout. This could happen  in a number of contexts,
    /// and the provided details needs to be investigated to determine what went
    /// wrong
    case timeout // = 6

    /// Timeout starting the mixnet client
    case mixnetTimeout // = 7

    /// Failed to setup the mixnet storage paths
    case mixnetStoragePaths // = 19

    /// Failed to create a mixnet client with default storage setup
    case mixnetDefaultStorage // = 20

    /// Failed to build the mixnet client instance
    case mixnetBuildClient // = 21

    /// Failed to connect to the mixnet
    case mixnetConnect // = 22

    /// Failed to connect to the mixnet entry gateway
    case mixnetEntryGateway // = 23

    /// Failed to connect to the IPR
    case iprFailedToConnect // = 25

    /// Failed to connect to one of the authenticators
    case authenticatorFailedToConnect // = 34

    /// Failed to connect to the authenticator, timeout waiting for the connect
    /// response
    case authenticatorConnectTimeout // = 35

    /// Failed to connect to the authenticator, the response was invalid
    case authenticatorInvalidResponse // = 36

    /// Failed to verify the registration data provided by the authenticator
    case authenticatorRegistrationDataVerification // = 37

    /// Failed to parse the socket addr provided by the authenticator when
    /// setting up the wireguard configuration
    case authenticatorEntryGatewaySocketAddr // = 38

    /// Failed to parse the IPv4 provided by the authenticator when setting up
    /// the wireguard configuration
    case authenticatorEntryGatewayIpv4 // = 39

    /// The authenticator responded with a response tagged with a version we
    /// can't understand.
    case authenticatorWrongVersion // = 40

    /// The authenticator, or someone else, responded with a reply that we can't
    /// read.
    case authenticatorMalformedReply // = 41

    /// Not authenticator address found for the gateway(s) we're trying to use
    case authenticatorAddressNotFound // = 47

    /// Authentication with the authenticators was not possible, as we we don't
    /// have addresses for them. This is likely an internal programming error.
    case authenticatorAuthenticationNotPossible // = 48

    /// Looking up gateways can fail in a number of ways.
    case gatewayDirectory // = 8

    /// Failing to lookup gateways
    case gatewayDirectoryLookupGateways // = 9

    /// Failing to lookup gateway identity
    case gatewayDirectoryLookupGatewayIdentity // = 10

    /// Failing to lookup the IPR address
    case gatewayDirectoryLookupRouterAddress // = 11

    /// Failing to lookup the gateway IP
    case gatewayDirectoryLookupIp // = 12

    /// Failing to lookup the entry gateway
    case gatewayDirectoryEntry // = 13

    /// Entry gateway identity not found
    case gatewayDirectoryEntryID // = 24

    /// Failing to lookup the entry gateway for a given location
    case gatewayDirectoryEntryLocation // = 14

    /// Failing to lookup the exit gateway
    case gatewayDirectoryExit // = 15

    /// Failing to lookup the exit gateway for a given location
    case gatewayDirectoryExitLocation // = 16

    /// Invalid configuration attempted, with the same entry and exit gateway
    case gatewayDirectorySameEntryAndExitGw // = 17

    /// Client ran out of allocated bandwidth
    case outOfBandwidth // = 18

    /// The user has no available bandwidth to setup tunnel
    case outOfBandwidthWhenSettingUpTunnel // = 26

    /// Failed to bring up the wg interface up
    case bringInterfaceUp // = 27

    /// Failed to init firewall subsystem
    case firewallInit // = 28

    /// Failed to reset the firewall policy
    case firewallResetPolicy // = 29

    /// Failed to init the DNS subsystem
    case dnsInit // = 30

    /// Failed to set DNS
    case dnsSet // = 31

    /// Failed to find the default network interface
    case findDefaultInterface // = 32

    /// Failed to add ipv6 default route to capture ipv6 traffic
    case addIpv6Route // = 42

    /// General failure for the tun device
    case tun // = 43

    /// General failure for routing
    case routing // = 44

    /// General failure setting up the wireguard configuration
    case wireguardConfig // = 45

    /// General failure for the mixnet connection monitor
    case mixnetConnectionMonitor // = 46
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .unhandled
      case 2: self = .noValidCredentials
      case 6: self = .timeout
      case 7: self = .mixnetTimeout
      case 8: self = .gatewayDirectory
      case 9: self = .gatewayDirectoryLookupGateways
      case 10: self = .gatewayDirectoryLookupGatewayIdentity
      case 11: self = .gatewayDirectoryLookupRouterAddress
      case 12: self = .gatewayDirectoryLookupIp
      case 13: self = .gatewayDirectoryEntry
      case 14: self = .gatewayDirectoryEntryLocation
      case 15: self = .gatewayDirectoryExit
      case 16: self = .gatewayDirectoryExitLocation
      case 17: self = .gatewayDirectorySameEntryAndExitGw
      case 18: self = .outOfBandwidth
      case 19: self = .mixnetStoragePaths
      case 20: self = .mixnetDefaultStorage
      case 21: self = .mixnetBuildClient
      case 22: self = .mixnetConnect
      case 23: self = .mixnetEntryGateway
      case 24: self = .gatewayDirectoryEntryID
      case 25: self = .iprFailedToConnect
      case 26: self = .outOfBandwidthWhenSettingUpTunnel
      case 27: self = .bringInterfaceUp
      case 28: self = .firewallInit
      case 29: self = .firewallResetPolicy
      case 30: self = .dnsInit
      case 31: self = .dnsSet
      case 32: self = .findDefaultInterface
      case 33: self = .internal
      case 34: self = .authenticatorFailedToConnect
      case 35: self = .authenticatorConnectTimeout
      case 36: self = .authenticatorInvalidResponse
      case 37: self = .authenticatorRegistrationDataVerification
      case 38: self = .authenticatorEntryGatewaySocketAddr
      case 39: self = .authenticatorEntryGatewayIpv4
      case 40: self = .authenticatorWrongVersion
      case 41: self = .authenticatorMalformedReply
      case 42: self = .addIpv6Route
      case 43: self = .tun
      case 44: self = .routing
      case 45: self = .wireguardConfig
      case 46: self = .mixnetConnectionMonitor
      case 47: self = .authenticatorAddressNotFound
      case 48: self = .authenticatorAuthenticationNotPossible
      case 49: self = .unhandledExit
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .unhandled: return 1
      case .noValidCredentials: return 2
      case .timeout: return 6
      case .mixnetTimeout: return 7
      case .gatewayDirectory: return 8
      case .gatewayDirectoryLookupGateways: return 9
      case .gatewayDirectoryLookupGatewayIdentity: return 10
      case .gatewayDirectoryLookupRouterAddress: return 11
      case .gatewayDirectoryLookupIp: return 12
      case .gatewayDirectoryEntry: return 13
      case .gatewayDirectoryEntryLocation: return 14
      case .gatewayDirectoryExit: return 15
      case .gatewayDirectoryExitLocation: return 16
      case .gatewayDirectorySameEntryAndExitGw: return 17
      case .outOfBandwidth: return 18
      case .mixnetStoragePaths: return 19
      case .mixnetDefaultStorage: return 20
      case .mixnetBuildClient: return 21
      case .mixnetConnect: return 22
      case .mixnetEntryGateway: return 23
      case .gatewayDirectoryEntryID: return 24
      case .iprFailedToConnect: return 25
      case .outOfBandwidthWhenSettingUpTunnel: return 26
      case .bringInterfaceUp: return 27
      case .firewallInit: return 28
      case .firewallResetPolicy: return 29
      case .dnsInit: return 30
      case .dnsSet: return 31
      case .findDefaultInterface: return 32
      case .internal: return 33
      case .authenticatorFailedToConnect: return 34
      case .authenticatorConnectTimeout: return 35
      case .authenticatorInvalidResponse: return 36
      case .authenticatorRegistrationDataVerification: return 37
      case .authenticatorEntryGatewaySocketAddr: return 38
      case .authenticatorEntryGatewayIpv4: return 39
      case .authenticatorWrongVersion: return 40
      case .authenticatorMalformedReply: return 41
      case .addIpv6Route: return 42
      case .tun: return 43
      case .routing: return 44
      case .wireguardConfig: return 45
      case .mixnetConnectionMonitor: return 46
      case .authenticatorAddressNotFound: return 47
      case .authenticatorAuthenticationNotPossible: return 48
      case .unhandledExit: return 49
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Nym_Vpn_Error.ErrorType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Nym_Vpn_Error.ErrorType] = [
    .unspecified,
    .unhandled,
    .unhandledExit,
    .internal,
    .noValidCredentials,
    .timeout,
    .mixnetTimeout,
    .mixnetStoragePaths,
    .mixnetDefaultStorage,
    .mixnetBuildClient,
    .mixnetConnect,
    .mixnetEntryGateway,
    .iprFailedToConnect,
    .authenticatorFailedToConnect,
    .authenticatorConnectTimeout,
    .authenticatorInvalidResponse,
    .authenticatorRegistrationDataVerification,
    .authenticatorEntryGatewaySocketAddr,
    .authenticatorEntryGatewayIpv4,
    .authenticatorWrongVersion,
    .authenticatorMalformedReply,
    .authenticatorAddressNotFound,
    .authenticatorAuthenticationNotPossible,
    .gatewayDirectory,
    .gatewayDirectoryLookupGateways,
    .gatewayDirectoryLookupGatewayIdentity,
    .gatewayDirectoryLookupRouterAddress,
    .gatewayDirectoryLookupIp,
    .gatewayDirectoryEntry,
    .gatewayDirectoryEntryID,
    .gatewayDirectoryEntryLocation,
    .gatewayDirectoryExit,
    .gatewayDirectoryExitLocation,
    .gatewayDirectorySameEntryAndExitGw,
    .outOfBandwidth,
    .outOfBandwidthWhenSettingUpTunnel,
    .bringInterfaceUp,
    .firewallInit,
    .firewallResetPolicy,
    .dnsInit,
    .dnsSet,
    .findDefaultInterface,
    .addIpv6Route,
    .tun,
    .routing,
    .wireguardConfig,
    .mixnetConnectionMonitor,
  ]
}

#endif  // swift(>=4.2)

struct Nym_Vpn_AsEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var canConnect: Bool = false

  var canRoute: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_AsExit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var canConnect: Bool = false

  var canRouteIpV4: Bool = false

  var canRouteIpV6: Bool = false

  var canRouteIpExternalV4: Bool = false

  var canRouteIpExternalV6: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_WgProbeResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var canRegister: Bool = false

  var canHandshake: Bool = false

  var canResolveDns: Bool = false

  var pingHostsPerformance: Float = 0

  var pingIpsPerformance: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_ProbeOutcome {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var asEntry: Nym_Vpn_AsEntry {
    get {return _asEntry ?? Nym_Vpn_AsEntry()}
    set {_asEntry = newValue}
  }
  /// Returns true if `asEntry` has been explicitly set.
  var hasAsEntry: Bool {return self._asEntry != nil}
  /// Clears the value of `asEntry`. Subsequent reads from it will return its default value.
  mutating func clearAsEntry() {self._asEntry = nil}

  var asExit: Nym_Vpn_AsExit {
    get {return _asExit ?? Nym_Vpn_AsExit()}
    set {_asExit = newValue}
  }
  /// Returns true if `asExit` has been explicitly set.
  var hasAsExit: Bool {return self._asExit != nil}
  /// Clears the value of `asExit`. Subsequent reads from it will return its default value.
  mutating func clearAsExit() {self._asExit = nil}

  var wg: Nym_Vpn_WgProbeResult {
    get {return _wg ?? Nym_Vpn_WgProbeResult()}
    set {_wg = newValue}
  }
  /// Returns true if `wg` has been explicitly set.
  var hasWg: Bool {return self._wg != nil}
  /// Clears the value of `wg`. Subsequent reads from it will return its default value.
  mutating func clearWg() {self._wg = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _asEntry: Nym_Vpn_AsEntry? = nil
  fileprivate var _asExit: Nym_Vpn_AsExit? = nil
  fileprivate var _wg: Nym_Vpn_WgProbeResult? = nil
}

struct Nym_Vpn_Probe {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lastUpdatedUtc: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastUpdatedUtc ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastUpdatedUtc = newValue}
  }
  /// Returns true if `lastUpdatedUtc` has been explicitly set.
  var hasLastUpdatedUtc: Bool {return self._lastUpdatedUtc != nil}
  /// Clears the value of `lastUpdatedUtc`. Subsequent reads from it will return its default value.
  mutating func clearLastUpdatedUtc() {self._lastUpdatedUtc = nil}

  var outcome: Nym_Vpn_ProbeOutcome {
    get {return _outcome ?? Nym_Vpn_ProbeOutcome()}
    set {_outcome = newValue}
  }
  /// Returns true if `outcome` has been explicitly set.
  var hasOutcome: Bool {return self._outcome != nil}
  /// Clears the value of `outcome`. Subsequent reads from it will return its default value.
  mutating func clearOutcome() {self._outcome = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _lastUpdatedUtc: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _outcome: Nym_Vpn_ProbeOutcome? = nil
}

struct Nym_Vpn_GatewayResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Nym_Vpn_Gateway {
    get {return _id ?? Nym_Vpn_Gateway()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var location: Nym_Vpn_Location {
    get {return _location ?? Nym_Vpn_Location()}
    set {_location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  var hasLocation: Bool {return self._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  mutating func clearLocation() {self._location = nil}

  var lastProbe: Nym_Vpn_Probe {
    get {return _lastProbe ?? Nym_Vpn_Probe()}
    set {_lastProbe = newValue}
  }
  /// Returns true if `lastProbe` has been explicitly set.
  var hasLastProbe: Bool {return self._lastProbe != nil}
  /// Clears the value of `lastProbe`. Subsequent reads from it will return its default value.
  mutating func clearLastProbe() {self._lastProbe = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: Nym_Vpn_Gateway? = nil
  fileprivate var _location: Nym_Vpn_Location? = nil
  fileprivate var _lastProbe: Nym_Vpn_Probe? = nil
}

struct Nym_Vpn_ListGatewaysRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Nym_Vpn_GatewayType = .unspecified

  var userAgent: Nym_Vpn_UserAgent {
    get {return _userAgent ?? Nym_Vpn_UserAgent()}
    set {_userAgent = newValue}
  }
  /// Returns true if `userAgent` has been explicitly set.
  var hasUserAgent: Bool {return self._userAgent != nil}
  /// Clears the value of `userAgent`. Subsequent reads from it will return its default value.
  mutating func clearUserAgent() {self._userAgent = nil}

  /// Optional thresholds
  var minMixnetPerformance: Nym_Vpn_Threshold {
    get {return _minMixnetPerformance ?? Nym_Vpn_Threshold()}
    set {_minMixnetPerformance = newValue}
  }
  /// Returns true if `minMixnetPerformance` has been explicitly set.
  var hasMinMixnetPerformance: Bool {return self._minMixnetPerformance != nil}
  /// Clears the value of `minMixnetPerformance`. Subsequent reads from it will return its default value.
  mutating func clearMinMixnetPerformance() {self._minMixnetPerformance = nil}

  var minVpnPerformance: Nym_Vpn_Threshold {
    get {return _minVpnPerformance ?? Nym_Vpn_Threshold()}
    set {_minVpnPerformance = newValue}
  }
  /// Returns true if `minVpnPerformance` has been explicitly set.
  var hasMinVpnPerformance: Bool {return self._minVpnPerformance != nil}
  /// Clears the value of `minVpnPerformance`. Subsequent reads from it will return its default value.
  mutating func clearMinVpnPerformance() {self._minVpnPerformance = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _userAgent: Nym_Vpn_UserAgent? = nil
  fileprivate var _minMixnetPerformance: Nym_Vpn_Threshold? = nil
  fileprivate var _minVpnPerformance: Nym_Vpn_Threshold? = nil
}

struct Nym_Vpn_ListGatewaysResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gateways: [Nym_Vpn_GatewayResponse] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_ListCountriesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Nym_Vpn_GatewayType = .unspecified

  var userAgent: Nym_Vpn_UserAgent {
    get {return _userAgent ?? Nym_Vpn_UserAgent()}
    set {_userAgent = newValue}
  }
  /// Returns true if `userAgent` has been explicitly set.
  var hasUserAgent: Bool {return self._userAgent != nil}
  /// Clears the value of `userAgent`. Subsequent reads from it will return its default value.
  mutating func clearUserAgent() {self._userAgent = nil}

  /// Optional thresholds
  var minMixnetPerformance: Nym_Vpn_Threshold {
    get {return _minMixnetPerformance ?? Nym_Vpn_Threshold()}
    set {_minMixnetPerformance = newValue}
  }
  /// Returns true if `minMixnetPerformance` has been explicitly set.
  var hasMinMixnetPerformance: Bool {return self._minMixnetPerformance != nil}
  /// Clears the value of `minMixnetPerformance`. Subsequent reads from it will return its default value.
  mutating func clearMinMixnetPerformance() {self._minMixnetPerformance = nil}

  var minVpnPerformance: Nym_Vpn_Threshold {
    get {return _minVpnPerformance ?? Nym_Vpn_Threshold()}
    set {_minVpnPerformance = newValue}
  }
  /// Returns true if `minVpnPerformance` has been explicitly set.
  var hasMinVpnPerformance: Bool {return self._minVpnPerformance != nil}
  /// Clears the value of `minVpnPerformance`. Subsequent reads from it will return its default value.
  mutating func clearMinVpnPerformance() {self._minVpnPerformance = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _userAgent: Nym_Vpn_UserAgent? = nil
  fileprivate var _minMixnetPerformance: Nym_Vpn_Threshold? = nil
  fileprivate var _minVpnPerformance: Nym_Vpn_Threshold? = nil
}

struct Nym_Vpn_ListCountriesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var countries: [Nym_Vpn_Location] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_StoreAccountRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mnemonic: String = String()

  var nonce: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_StoreAccountResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var success: Bool = false

  var error: Nym_Vpn_AccountError {
    get {return _error ?? Nym_Vpn_AccountError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Nym_Vpn_AccountError? = nil
}

struct Nym_Vpn_IsAccountStoredRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_IsAccountStoredResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var resp: Nym_Vpn_IsAccountStoredResponse.OneOf_Resp? = nil

  var isStored: Bool {
    get {
      if case .isStored(let v)? = resp {return v}
      return false
    }
    set {resp = .isStored(newValue)}
  }

  var error: Nym_Vpn_AccountError {
    get {
      if case .error(let v)? = resp {return v}
      return Nym_Vpn_AccountError()
    }
    set {resp = .error(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Resp: Equatable {
    case isStored(Bool)
    case error(Nym_Vpn_AccountError)

  #if !swift(>=4.1)
    static func ==(lhs: Nym_Vpn_IsAccountStoredResponse.OneOf_Resp, rhs: Nym_Vpn_IsAccountStoredResponse.OneOf_Resp) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.isStored, .isStored): return {
        guard case .isStored(let l) = lhs, case .isStored(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Nym_Vpn_RemoveAccountRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_RemoveAccountResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var success: Bool = false

  var error: Nym_Vpn_AccountError {
    get {return _error ?? Nym_Vpn_AccountError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Nym_Vpn_AccountError? = nil
}

struct Nym_Vpn_GetAccountIdentityRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_GetAccountIdentityResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Nym_Vpn_GetAccountIdentityResponse.OneOf_ID? = nil

  var accountIdentity: String {
    get {
      if case .accountIdentity(let v)? = id {return v}
      return String()
    }
    set {id = .accountIdentity(newValue)}
  }

  var error: Nym_Vpn_AccountError {
    get {
      if case .error(let v)? = id {return v}
      return Nym_Vpn_AccountError()
    }
    set {id = .error(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ID: Equatable {
    case accountIdentity(String)
    case error(Nym_Vpn_AccountError)

  #if !swift(>=4.1)
    static func ==(lhs: Nym_Vpn_GetAccountIdentityResponse.OneOf_ID, rhs: Nym_Vpn_GetAccountIdentityResponse.OneOf_ID) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.accountIdentity, .accountIdentity): return {
        guard case .accountIdentity(let l) = lhs, case .accountIdentity(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Nym_Vpn_AccountSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mnemonic: Nym_Vpn_MnemonicState {
    get {return _mnemonic ?? .unspecified}
    set {_mnemonic = newValue}
  }
  /// Returns true if `mnemonic` has been explicitly set.
  var hasMnemonic: Bool {return self._mnemonic != nil}
  /// Clears the value of `mnemonic`. Subsequent reads from it will return its default value.
  mutating func clearMnemonic() {self._mnemonic = nil}

  var account: Nym_Vpn_AccountState {
    get {return _account ?? .unspecified}
    set {_account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  var hasAccount: Bool {return self._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  mutating func clearAccount() {self._account = nil}

  var subscription: Nym_Vpn_SubscriptionState {
    get {return _subscription ?? .unspecified}
    set {_subscription = newValue}
  }
  /// Returns true if `subscription` has been explicitly set.
  var hasSubscription: Bool {return self._subscription != nil}
  /// Clears the value of `subscription`. Subsequent reads from it will return its default value.
  mutating func clearSubscription() {self._subscription = nil}

  var device: Nym_Vpn_DeviceState {
    get {return _device ?? .unspecified}
    set {_device = newValue}
  }
  /// Returns true if `device` has been explicitly set.
  var hasDevice: Bool {return self._device != nil}
  /// Clears the value of `device`. Subsequent reads from it will return its default value.
  mutating func clearDevice() {self._device = nil}

  var pendingZkNym: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mnemonic: Nym_Vpn_MnemonicState? = nil
  fileprivate var _account: Nym_Vpn_AccountState? = nil
  fileprivate var _subscription: Nym_Vpn_SubscriptionState? = nil
  fileprivate var _device: Nym_Vpn_DeviceState? = nil
}

struct Nym_Vpn_GetAccountStateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_GetAccountStateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: Nym_Vpn_GetAccountStateResponse.OneOf_Result? = nil

  var accountSummary: Nym_Vpn_AccountSummary {
    get {
      if case .accountSummary(let v)? = result {return v}
      return Nym_Vpn_AccountSummary()
    }
    set {result = .accountSummary(newValue)}
  }

  var error: Nym_Vpn_AccountError {
    get {
      if case .error(let v)? = result {return v}
      return Nym_Vpn_AccountError()
    }
    set {result = .error(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Result: Equatable {
    case accountSummary(Nym_Vpn_AccountSummary)
    case error(Nym_Vpn_AccountError)

  #if !swift(>=4.1)
    static func ==(lhs: Nym_Vpn_GetAccountStateResponse.OneOf_Result, rhs: Nym_Vpn_GetAccountStateResponse.OneOf_Result) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.accountSummary, .accountSummary): return {
        guard case .accountSummary(let l) = lhs, case .accountSummary(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Nym_Vpn_RefreshAccountStateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_RefreshAccountStateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_FetchRawAccountSummaryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_FetchRawAccountSummaryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var json: String = String()

  var error: Nym_Vpn_AccountError {
    get {return _error ?? Nym_Vpn_AccountError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Nym_Vpn_AccountError? = nil
}

struct Nym_Vpn_FetchRawDevicesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_FetchRawDevicesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var json: String = String()

  var error: Nym_Vpn_AccountError {
    get {return _error ?? Nym_Vpn_AccountError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Nym_Vpn_AccountError? = nil
}

struct Nym_Vpn_ResetDeviceIdentityRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 32 byte seed, [u8; 32]
  var seed: Data {
    get {return _seed ?? Data()}
    set {_seed = newValue}
  }
  /// Returns true if `seed` has been explicitly set.
  var hasSeed: Bool {return self._seed != nil}
  /// Clears the value of `seed`. Subsequent reads from it will return its default value.
  mutating func clearSeed() {self._seed = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _seed: Data? = nil
}

struct Nym_Vpn_ResetDeviceIdentityResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var success: Bool = false

  var error: Nym_Vpn_AccountError {
    get {return _error ?? Nym_Vpn_AccountError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Nym_Vpn_AccountError? = nil
}

struct Nym_Vpn_GetDeviceIdentityRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_GetDeviceIdentityResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Nym_Vpn_GetDeviceIdentityResponse.OneOf_ID? = nil

  var deviceIdentity: String {
    get {
      if case .deviceIdentity(let v)? = id {return v}
      return String()
    }
    set {id = .deviceIdentity(newValue)}
  }

  var error: Nym_Vpn_AccountError {
    get {
      if case .error(let v)? = id {return v}
      return Nym_Vpn_AccountError()
    }
    set {id = .error(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ID: Equatable {
    case deviceIdentity(String)
    case error(Nym_Vpn_AccountError)

  #if !swift(>=4.1)
    static func ==(lhs: Nym_Vpn_GetDeviceIdentityResponse.OneOf_ID, rhs: Nym_Vpn_GetDeviceIdentityResponse.OneOf_ID) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.deviceIdentity, .deviceIdentity): return {
        guard case .deviceIdentity(let l) = lhs, case .deviceIdentity(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Nym_Vpn_RegisterDeviceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_RegisterDeviceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var json: String = String()

  var error: Nym_Vpn_AccountError {
    get {return _error ?? Nym_Vpn_AccountError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Nym_Vpn_AccountError? = nil
}

struct Nym_Vpn_RequestZkNymRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_RequestZkNymResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var json: String = String()

  var error: Nym_Vpn_AccountError {
    get {return _error ?? Nym_Vpn_AccountError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Nym_Vpn_AccountError? = nil
}

struct Nym_Vpn_GetDeviceZkNymsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_GetDeviceZkNymsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var json: String = String()

  var error: Nym_Vpn_AccountError {
    get {return _error ?? Nym_Vpn_AccountError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Nym_Vpn_AccountError? = nil
}

struct Nym_Vpn_IsReadyToConnectRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_IsReadyToConnectResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Nym_Vpn_IsReadyToConnectResponse.IsReadyToConnectResponseType = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum IsReadyToConnectResponseType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unspecified // = 0

    /// We are ready to attempt to connect
    case ready // = 1

    /// No account recovery phrase stored
    case noAccountStored // = 2

    /// The account is not active
    case accountNotActive // = 3

    /// The account does not have an active subscripion
    case noActiveSubscription // = 4

    /// The device is not registered
    case deviceNotRegistered // = 5

    /// The device is not active
    /// NOTE: in the future we will try to re-active an inactive device on
    /// connect
    case deviceNotActive // = 6
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .ready
      case 2: self = .noAccountStored
      case 3: self = .accountNotActive
      case 4: self = .noActiveSubscription
      case 5: self = .deviceNotRegistered
      case 6: self = .deviceNotActive
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .ready: return 1
      case .noAccountStored: return 2
      case .accountNotActive: return 3
      case .noActiveSubscription: return 4
      case .deviceNotRegistered: return 5
      case .deviceNotActive: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Nym_Vpn_IsReadyToConnectResponse.IsReadyToConnectResponseType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Nym_Vpn_IsReadyToConnectResponse.IsReadyToConnectResponseType] = [
    .unspecified,
    .ready,
    .noAccountStored,
    .accountNotActive,
    .noActiveSubscription,
    .deviceNotRegistered,
    .deviceNotActive,
  ]
}

#endif  // swift(>=4.2)

struct Nym_Vpn_AccountError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Nym_Vpn_AccountError.AccountErrorType = .storeAccountErrorUnspecified

  /// Detailed error message for logging and debugging
  var message: String = String()

  /// Optional additional details
  var details: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum AccountErrorType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case storeAccountErrorUnspecified // = 0

    /// The provided mnemonic was not able to be parsed
    case invalidMnemonic // = 1

    /// General error from the storage backend
    case storage // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .storeAccountErrorUnspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .storeAccountErrorUnspecified
      case 1: self = .invalidMnemonic
      case 2: self = .storage
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .storeAccountErrorUnspecified: return 0
      case .invalidMnemonic: return 1
      case .storage: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Nym_Vpn_AccountError.AccountErrorType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Nym_Vpn_AccountError.AccountErrorType] = [
    .storeAccountErrorUnspecified,
    .invalidMnemonic,
    .storage,
  ]
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension Nym_Vpn_ConnectionStatus: @unchecked Sendable {}
extension Nym_Vpn_GatewayType: @unchecked Sendable {}
extension Nym_Vpn_MnemonicState: @unchecked Sendable {}
extension Nym_Vpn_AccountState: @unchecked Sendable {}
extension Nym_Vpn_SubscriptionState: @unchecked Sendable {}
extension Nym_Vpn_DeviceState: @unchecked Sendable {}
extension Nym_Vpn_Empty: @unchecked Sendable {}
extension Nym_Vpn_Gateway: @unchecked Sendable {}
extension Nym_Vpn_Address: @unchecked Sendable {}
extension Nym_Vpn_Location: @unchecked Sendable {}
extension Nym_Vpn_EntryNode: @unchecked Sendable {}
extension Nym_Vpn_EntryNode.OneOf_EntryNodeEnum: @unchecked Sendable {}
extension Nym_Vpn_ExitNode: @unchecked Sendable {}
extension Nym_Vpn_ExitNode.OneOf_ExitNodeEnum: @unchecked Sendable {}
extension Nym_Vpn_MixConnectedStateDetails: @unchecked Sendable {}
extension Nym_Vpn_WgConnectedStateDetails: @unchecked Sendable {}
extension Nym_Vpn_ConnectedStateDetails: @unchecked Sendable {}
extension Nym_Vpn_ConnectedStateDetails.OneOf_ConnectedStateDetails: @unchecked Sendable {}
extension Nym_Vpn_Dns: @unchecked Sendable {}
extension Nym_Vpn_Url: @unchecked Sendable {}
extension Nym_Vpn_UserAgent: @unchecked Sendable {}
extension Nym_Vpn_DenomDetails: @unchecked Sendable {}
extension Nym_Vpn_ChainDetails: @unchecked Sendable {}
extension Nym_Vpn_NymContracts: @unchecked Sendable {}
extension Nym_Vpn_NymNetworkDetails: @unchecked Sendable {}
extension Nym_Vpn_NymVpnNetworkDetails: @unchecked Sendable {}
extension Nym_Vpn_ValidatorDetails: @unchecked Sendable {}
extension Nym_Vpn_InfoRequest: @unchecked Sendable {}
extension Nym_Vpn_InfoResponse: @unchecked Sendable {}
extension Nym_Vpn_SetNetworkRequest: @unchecked Sendable {}
extension Nym_Vpn_SetNetworkResponse: @unchecked Sendable {}
extension Nym_Vpn_SetNetworkRequestError: @unchecked Sendable {}
extension Nym_Vpn_SetNetworkRequestError.SetNetworkRequestErrorType: @unchecked Sendable {}
extension Nym_Vpn_Threshold: @unchecked Sendable {}
extension Nym_Vpn_ConnectRequestError: @unchecked Sendable {}
extension Nym_Vpn_ConnectRequestError.ConnectRequestErrorType: @unchecked Sendable {}
extension Nym_Vpn_ConnectRequest: @unchecked Sendable {}
extension Nym_Vpn_ConnectResponse: @unchecked Sendable {}
extension Nym_Vpn_DisconnectRequest: @unchecked Sendable {}
extension Nym_Vpn_DisconnectResponse: @unchecked Sendable {}
extension Nym_Vpn_ConnectionDetails: @unchecked Sendable {}
extension Nym_Vpn_StatusRequest: @unchecked Sendable {}
extension Nym_Vpn_StatusResponse: @unchecked Sendable {}
extension Nym_Vpn_ConnectionStateChange: @unchecked Sendable {}
extension Nym_Vpn_ConnectionStatusUpdate: @unchecked Sendable {}
extension Nym_Vpn_ConnectionStatusUpdate.StatusType: @unchecked Sendable {}
extension Nym_Vpn_Error: @unchecked Sendable {}
extension Nym_Vpn_Error.ErrorType: @unchecked Sendable {}
extension Nym_Vpn_AsEntry: @unchecked Sendable {}
extension Nym_Vpn_AsExit: @unchecked Sendable {}
extension Nym_Vpn_WgProbeResult: @unchecked Sendable {}
extension Nym_Vpn_ProbeOutcome: @unchecked Sendable {}
extension Nym_Vpn_Probe: @unchecked Sendable {}
extension Nym_Vpn_GatewayResponse: @unchecked Sendable {}
extension Nym_Vpn_ListGatewaysRequest: @unchecked Sendable {}
extension Nym_Vpn_ListGatewaysResponse: @unchecked Sendable {}
extension Nym_Vpn_ListCountriesRequest: @unchecked Sendable {}
extension Nym_Vpn_ListCountriesResponse: @unchecked Sendable {}
extension Nym_Vpn_StoreAccountRequest: @unchecked Sendable {}
extension Nym_Vpn_StoreAccountResponse: @unchecked Sendable {}
extension Nym_Vpn_IsAccountStoredRequest: @unchecked Sendable {}
extension Nym_Vpn_IsAccountStoredResponse: @unchecked Sendable {}
extension Nym_Vpn_IsAccountStoredResponse.OneOf_Resp: @unchecked Sendable {}
extension Nym_Vpn_RemoveAccountRequest: @unchecked Sendable {}
extension Nym_Vpn_RemoveAccountResponse: @unchecked Sendable {}
extension Nym_Vpn_GetAccountIdentityRequest: @unchecked Sendable {}
extension Nym_Vpn_GetAccountIdentityResponse: @unchecked Sendable {}
extension Nym_Vpn_GetAccountIdentityResponse.OneOf_ID: @unchecked Sendable {}
extension Nym_Vpn_AccountSummary: @unchecked Sendable {}
extension Nym_Vpn_GetAccountStateRequest: @unchecked Sendable {}
extension Nym_Vpn_GetAccountStateResponse: @unchecked Sendable {}
extension Nym_Vpn_GetAccountStateResponse.OneOf_Result: @unchecked Sendable {}
extension Nym_Vpn_RefreshAccountStateRequest: @unchecked Sendable {}
extension Nym_Vpn_RefreshAccountStateResponse: @unchecked Sendable {}
extension Nym_Vpn_FetchRawAccountSummaryRequest: @unchecked Sendable {}
extension Nym_Vpn_FetchRawAccountSummaryResponse: @unchecked Sendable {}
extension Nym_Vpn_FetchRawDevicesRequest: @unchecked Sendable {}
extension Nym_Vpn_FetchRawDevicesResponse: @unchecked Sendable {}
extension Nym_Vpn_ResetDeviceIdentityRequest: @unchecked Sendable {}
extension Nym_Vpn_ResetDeviceIdentityResponse: @unchecked Sendable {}
extension Nym_Vpn_GetDeviceIdentityRequest: @unchecked Sendable {}
extension Nym_Vpn_GetDeviceIdentityResponse: @unchecked Sendable {}
extension Nym_Vpn_GetDeviceIdentityResponse.OneOf_ID: @unchecked Sendable {}
extension Nym_Vpn_RegisterDeviceRequest: @unchecked Sendable {}
extension Nym_Vpn_RegisterDeviceResponse: @unchecked Sendable {}
extension Nym_Vpn_RequestZkNymRequest: @unchecked Sendable {}
extension Nym_Vpn_RequestZkNymResponse: @unchecked Sendable {}
extension Nym_Vpn_GetDeviceZkNymsRequest: @unchecked Sendable {}
extension Nym_Vpn_GetDeviceZkNymsResponse: @unchecked Sendable {}
extension Nym_Vpn_IsReadyToConnectRequest: @unchecked Sendable {}
extension Nym_Vpn_IsReadyToConnectResponse: @unchecked Sendable {}
extension Nym_Vpn_IsReadyToConnectResponse.IsReadyToConnectResponseType: @unchecked Sendable {}
extension Nym_Vpn_AccountError: @unchecked Sendable {}
extension Nym_Vpn_AccountError.AccountErrorType: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "nym.vpn"

extension Nym_Vpn_ConnectionStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNSPECIFIED"),
    1: .same(proto: "UNKNOWN"),
    2: .same(proto: "NOT_CONNECTED"),
    3: .same(proto: "CONNECTING"),
    4: .same(proto: "CONNECTED"),
    5: .same(proto: "DISCONNECTING"),
    6: .same(proto: "CONNECTION_FAILED"),
  ]
}

extension Nym_Vpn_GatewayType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GATEWAY_TYPE_UNSPECIFIED"),
    1: .same(proto: "MIXNET_ENTRY"),
    2: .same(proto: "MIXNET_EXIT"),
    3: .same(proto: "WG"),
  ]
}

extension Nym_Vpn_MnemonicState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MNEMONIC_STATE_UNSPECIFIED"),
    1: .same(proto: "MNEMONIC_STATE_NOT_STORED"),
    2: .same(proto: "MNEMONIC_STATE_STORED"),
  ]
}

extension Nym_Vpn_AccountState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ACCOUNT_STATE_UNSPECIFIED"),
    1: .same(proto: "ACCOUNT_STATE_NOT_REGISTERED"),
    2: .same(proto: "ACCOUNT_STATE_INACTIVE"),
    3: .same(proto: "ACCOUNT_STATE_ACTIVE"),
    4: .same(proto: "ACCOUNT_STATE_DELETE_ME"),
  ]
}

extension Nym_Vpn_SubscriptionState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUBSCRIPTION_STATE_UNSPECIFIED"),
    1: .same(proto: "SUBSCRIPTION_STATE_NOT_REGISTERED"),
    2: .same(proto: "SUBSCRIPTION_STATE_PENDING"),
    3: .same(proto: "SUBSCRIPTION_STATE_ACTIVE"),
    4: .same(proto: "SUBSCRIPTION_STATE_COMPLETE"),
  ]
}

extension Nym_Vpn_DeviceState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEVICE_STATE_UNSPECIFIED"),
    1: .same(proto: "DEVICE_STATE_NOT_REGISTERED"),
    2: .same(proto: "DEVICE_STATE_INACTIVE"),
    3: .same(proto: "DEVICE_STATE_ACTIVE"),
    4: .same(proto: "DEVICE_STATE_DELETE_ME"),
  ]
}

extension Nym_Vpn_Empty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Empty"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_Empty, rhs: Nym_Vpn_Empty) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_Gateway: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Gateway"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_Gateway, rhs: Nym_Vpn_Gateway) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_Address: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Address"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "nym_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.nymAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nymAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.nymAddress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_Address, rhs: Nym_Vpn_Address) -> Bool {
    if lhs.nymAddress != rhs.nymAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_Location: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Location"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "two_letter_iso_country_code"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.twoLetterIsoCountryCode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.twoLetterIsoCountryCode.isEmpty {
      try visitor.visitSingularStringField(value: self.twoLetterIsoCountryCode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_Location, rhs: Nym_Vpn_Location) -> Bool {
    if lhs.twoLetterIsoCountryCode != rhs.twoLetterIsoCountryCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_EntryNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EntryNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gateway"),
    2: .same(proto: "location"),
    3: .standard(proto: "random_low_latency"),
    4: .same(proto: "random"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Nym_Vpn_Gateway?
        var hadOneofValue = false
        if let current = self.entryNodeEnum {
          hadOneofValue = true
          if case .gateway(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.entryNodeEnum = .gateway(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_Location?
        var hadOneofValue = false
        if let current = self.entryNodeEnum {
          hadOneofValue = true
          if case .location(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.entryNodeEnum = .location(v)
        }
      }()
      case 3: try {
        var v: Nym_Vpn_Empty?
        var hadOneofValue = false
        if let current = self.entryNodeEnum {
          hadOneofValue = true
          if case .randomLowLatency(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.entryNodeEnum = .randomLowLatency(v)
        }
      }()
      case 4: try {
        var v: Nym_Vpn_Empty?
        var hadOneofValue = false
        if let current = self.entryNodeEnum {
          hadOneofValue = true
          if case .random(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.entryNodeEnum = .random(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.entryNodeEnum {
    case .gateway?: try {
      guard case .gateway(let v)? = self.entryNodeEnum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .location?: try {
      guard case .location(let v)? = self.entryNodeEnum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .randomLowLatency?: try {
      guard case .randomLowLatency(let v)? = self.entryNodeEnum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .random?: try {
      guard case .random(let v)? = self.entryNodeEnum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_EntryNode, rhs: Nym_Vpn_EntryNode) -> Bool {
    if lhs.entryNodeEnum != rhs.entryNodeEnum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ExitNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExitNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "gateway"),
    3: .same(proto: "location"),
    4: .same(proto: "random"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Nym_Vpn_Address?
        var hadOneofValue = false
        if let current = self.exitNodeEnum {
          hadOneofValue = true
          if case .address(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.exitNodeEnum = .address(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_Gateway?
        var hadOneofValue = false
        if let current = self.exitNodeEnum {
          hadOneofValue = true
          if case .gateway(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.exitNodeEnum = .gateway(v)
        }
      }()
      case 3: try {
        var v: Nym_Vpn_Location?
        var hadOneofValue = false
        if let current = self.exitNodeEnum {
          hadOneofValue = true
          if case .location(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.exitNodeEnum = .location(v)
        }
      }()
      case 4: try {
        var v: Nym_Vpn_Empty?
        var hadOneofValue = false
        if let current = self.exitNodeEnum {
          hadOneofValue = true
          if case .random(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.exitNodeEnum = .random(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.exitNodeEnum {
    case .address?: try {
      guard case .address(let v)? = self.exitNodeEnum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .gateway?: try {
      guard case .gateway(let v)? = self.exitNodeEnum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .location?: try {
      guard case .location(let v)? = self.exitNodeEnum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .random?: try {
      guard case .random(let v)? = self.exitNodeEnum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ExitNode, rhs: Nym_Vpn_ExitNode) -> Bool {
    if lhs.exitNodeEnum != rhs.exitNodeEnum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_MixConnectedStateDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MixConnectedStateDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "nym_address"),
    2: .standard(proto: "exit_ipr"),
    3: .same(proto: "ipv4"),
    4: .same(proto: "ipv6"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._nymAddress) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._exitIpr) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ipv4) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.ipv6) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nymAddress {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._exitIpr {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.ipv4.isEmpty {
      try visitor.visitSingularStringField(value: self.ipv4, fieldNumber: 3)
    }
    if !self.ipv6.isEmpty {
      try visitor.visitSingularStringField(value: self.ipv6, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_MixConnectedStateDetails, rhs: Nym_Vpn_MixConnectedStateDetails) -> Bool {
    if lhs._nymAddress != rhs._nymAddress {return false}
    if lhs._exitIpr != rhs._exitIpr {return false}
    if lhs.ipv4 != rhs.ipv4 {return false}
    if lhs.ipv6 != rhs.ipv6 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_WgConnectedStateDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WgConnectedStateDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "entry_ipv4"),
    2: .standard(proto: "exit_ipv4"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.entryIpv4) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.exitIpv4) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entryIpv4.isEmpty {
      try visitor.visitSingularStringField(value: self.entryIpv4, fieldNumber: 1)
    }
    if !self.exitIpv4.isEmpty {
      try visitor.visitSingularStringField(value: self.exitIpv4, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_WgConnectedStateDetails, rhs: Nym_Vpn_WgConnectedStateDetails) -> Bool {
    if lhs.entryIpv4 != rhs.entryIpv4 {return false}
    if lhs.exitIpv4 != rhs.exitIpv4 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ConnectedStateDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectedStateDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mix"),
    2: .same(proto: "wg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Nym_Vpn_MixConnectedStateDetails?
        var hadOneofValue = false
        if let current = self.connectedStateDetails {
          hadOneofValue = true
          if case .mix(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.connectedStateDetails = .mix(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_WgConnectedStateDetails?
        var hadOneofValue = false
        if let current = self.connectedStateDetails {
          hadOneofValue = true
          if case .wg(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.connectedStateDetails = .wg(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.connectedStateDetails {
    case .mix?: try {
      guard case .mix(let v)? = self.connectedStateDetails else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .wg?: try {
      guard case .wg(let v)? = self.connectedStateDetails else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ConnectedStateDetails, rhs: Nym_Vpn_ConnectedStateDetails) -> Bool {
    if lhs.connectedStateDetails != rhs.connectedStateDetails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_Dns: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Dns"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ip"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ip) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ip.isEmpty {
      try visitor.visitSingularStringField(value: self.ip, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_Dns, rhs: Nym_Vpn_Dns) -> Bool {
    if lhs.ip != rhs.ip {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_Url: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Url"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_Url, rhs: Nym_Vpn_Url) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_UserAgent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserAgent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "application"),
    2: .same(proto: "version"),
    3: .same(proto: "platform"),
    4: .standard(proto: "git_commit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.application) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.platform) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.gitCommit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.application.isEmpty {
      try visitor.visitSingularStringField(value: self.application, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    if !self.platform.isEmpty {
      try visitor.visitSingularStringField(value: self.platform, fieldNumber: 3)
    }
    if !self.gitCommit.isEmpty {
      try visitor.visitSingularStringField(value: self.gitCommit, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_UserAgent, rhs: Nym_Vpn_UserAgent) -> Bool {
    if lhs.application != rhs.application {return false}
    if lhs.version != rhs.version {return false}
    if lhs.platform != rhs.platform {return false}
    if lhs.gitCommit != rhs.gitCommit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_DenomDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DenomDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "base"),
    2: .same(proto: "display"),
    3: .standard(proto: "display_exponent"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.base) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.display) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.displayExponent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.base.isEmpty {
      try visitor.visitSingularStringField(value: self.base, fieldNumber: 1)
    }
    if !self.display.isEmpty {
      try visitor.visitSingularStringField(value: self.display, fieldNumber: 2)
    }
    if self.displayExponent != 0 {
      try visitor.visitSingularUInt32Field(value: self.displayExponent, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_DenomDetails, rhs: Nym_Vpn_DenomDetails) -> Bool {
    if lhs.base != rhs.base {return false}
    if lhs.display != rhs.display {return false}
    if lhs.displayExponent != rhs.displayExponent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ChainDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChainDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bech32_account_prefix"),
    2: .standard(proto: "mix_denom"),
    3: .standard(proto: "stake_denom"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bech32AccountPrefix) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._mixDenom) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._stakeDenom) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.bech32AccountPrefix.isEmpty {
      try visitor.visitSingularStringField(value: self.bech32AccountPrefix, fieldNumber: 1)
    }
    try { if let v = self._mixDenom {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._stakeDenom {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ChainDetails, rhs: Nym_Vpn_ChainDetails) -> Bool {
    if lhs.bech32AccountPrefix != rhs.bech32AccountPrefix {return false}
    if lhs._mixDenom != rhs._mixDenom {return false}
    if lhs._stakeDenom != rhs._stakeDenom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_NymContracts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NymContracts"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "mixnet_contract_address"),
    2: .standard(proto: "vesting_contract_address"),
    3: .standard(proto: "ecash_contract_address"),
    4: .standard(proto: "group_contract_address"),
    5: .standard(proto: "multisig_contract_address"),
    6: .standard(proto: "coconut_dkg_contract_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._mixnetContractAddress) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._vestingContractAddress) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._ecashContractAddress) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._groupContractAddress) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._multisigContractAddress) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._coconutDkgContractAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mixnetContractAddress {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._vestingContractAddress {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._ecashContractAddress {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._groupContractAddress {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._multisigContractAddress {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._coconutDkgContractAddress {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_NymContracts, rhs: Nym_Vpn_NymContracts) -> Bool {
    if lhs._mixnetContractAddress != rhs._mixnetContractAddress {return false}
    if lhs._vestingContractAddress != rhs._vestingContractAddress {return false}
    if lhs._ecashContractAddress != rhs._ecashContractAddress {return false}
    if lhs._groupContractAddress != rhs._groupContractAddress {return false}
    if lhs._multisigContractAddress != rhs._multisigContractAddress {return false}
    if lhs._coconutDkgContractAddress != rhs._coconutDkgContractAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_NymNetworkDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NymNetworkDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "network_name"),
    2: .standard(proto: "chain_details"),
    3: .same(proto: "endpoints"),
    4: .same(proto: "contracts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.networkName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._chainDetails) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.endpoints) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._contracts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.networkName.isEmpty {
      try visitor.visitSingularStringField(value: self.networkName, fieldNumber: 1)
    }
    try { if let v = self._chainDetails {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.endpoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.endpoints, fieldNumber: 3)
    }
    try { if let v = self._contracts {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_NymNetworkDetails, rhs: Nym_Vpn_NymNetworkDetails) -> Bool {
    if lhs.networkName != rhs.networkName {return false}
    if lhs._chainDetails != rhs._chainDetails {return false}
    if lhs.endpoints != rhs.endpoints {return false}
    if lhs._contracts != rhs._contracts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_NymVpnNetworkDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NymVpnNetworkDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "nym_vpn_api_url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._nymVpnApiURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nymVpnApiURL {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_NymVpnNetworkDetails, rhs: Nym_Vpn_NymVpnNetworkDetails) -> Bool {
    if lhs._nymVpnApiURL != rhs._nymVpnApiURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ValidatorDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ValidatorDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "nyxd_url"),
    2: .standard(proto: "websocket_url"),
    3: .standard(proto: "api_url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._nyxdURL) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._websocketURL) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._apiURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nyxdURL {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._websocketURL {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._apiURL {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ValidatorDetails, rhs: Nym_Vpn_ValidatorDetails) -> Bool {
    if lhs._nyxdURL != rhs._nyxdURL {return false}
    if lhs._websocketURL != rhs._websocketURL {return false}
    if lhs._apiURL != rhs._apiURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_InfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InfoRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_InfoRequest, rhs: Nym_Vpn_InfoRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_InfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .standard(proto: "build_timestamp"),
    3: .same(proto: "triple"),
    4: .same(proto: "platform"),
    5: .standard(proto: "git_commit"),
    6: .standard(proto: "nym_network"),
    7: .standard(proto: "nym_vpn_network"),
  ]

  fileprivate class _StorageClass {
    var _version: String = String()
    var _buildTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _triple: String = String()
    var _platform: String = String()
    var _gitCommit: String = String()
    var _nymNetwork: Nym_Vpn_NymNetworkDetails? = nil
    var _nymVpnNetwork: Nym_Vpn_NymVpnNetworkDetails? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _version = source._version
      _buildTimestamp = source._buildTimestamp
      _triple = source._triple
      _platform = source._platform
      _gitCommit = source._gitCommit
      _nymNetwork = source._nymNetwork
      _nymVpnNetwork = source._nymVpnNetwork
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._version) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._buildTimestamp) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._triple) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._platform) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._gitCommit) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._nymNetwork) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._nymVpnNetwork) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 1)
      }
      try { if let v = _storage._buildTimestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._triple.isEmpty {
        try visitor.visitSingularStringField(value: _storage._triple, fieldNumber: 3)
      }
      if !_storage._platform.isEmpty {
        try visitor.visitSingularStringField(value: _storage._platform, fieldNumber: 4)
      }
      if !_storage._gitCommit.isEmpty {
        try visitor.visitSingularStringField(value: _storage._gitCommit, fieldNumber: 5)
      }
      try { if let v = _storage._nymNetwork {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._nymVpnNetwork {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_InfoResponse, rhs: Nym_Vpn_InfoResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._version != rhs_storage._version {return false}
        if _storage._buildTimestamp != rhs_storage._buildTimestamp {return false}
        if _storage._triple != rhs_storage._triple {return false}
        if _storage._platform != rhs_storage._platform {return false}
        if _storage._gitCommit != rhs_storage._gitCommit {return false}
        if _storage._nymNetwork != rhs_storage._nymNetwork {return false}
        if _storage._nymVpnNetwork != rhs_storage._nymVpnNetwork {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_SetNetworkRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetNetworkRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "network"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.network) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.network.isEmpty {
      try visitor.visitSingularStringField(value: self.network, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_SetNetworkRequest, rhs: Nym_Vpn_SetNetworkRequest) -> Bool {
    if lhs.network != rhs.network {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_SetNetworkResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetNetworkResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_SetNetworkResponse, rhs: Nym_Vpn_SetNetworkResponse) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_SetNetworkRequestError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetNetworkRequestError"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.kind != .unspecified {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_SetNetworkRequestError, rhs: Nym_Vpn_SetNetworkRequestError) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_SetNetworkRequestError.SetNetworkRequestErrorType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SET_NETWORK_REQUEST_ERROR_TYPE_UNSPECIFIED"),
    1: .same(proto: "INTERNAL"),
    2: .same(proto: "INVALID_NETWORK_NAME"),
  ]
}

extension Nym_Vpn_Threshold: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Threshold"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_performance"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.minPerformance) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.minPerformance != 0 {
      try visitor.visitSingularUInt32Field(value: self.minPerformance, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_Threshold, rhs: Nym_Vpn_Threshold) -> Bool {
    if lhs.minPerformance != rhs.minPerformance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ConnectRequestError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectRequestError"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.kind != .unspecified {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ConnectRequestError, rhs: Nym_Vpn_ConnectRequestError) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ConnectRequestError.ConnectRequestErrorType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONNECT_REQUEST_ERROR_TYPE_UNSPECIFIED"),
    1: .same(proto: "INTERNAL"),
    2: .same(proto: "NO_ACCOUNT_STORED"),
    3: .same(proto: "ACCOUNT_NOT_ACTIVE"),
    4: .same(proto: "NO_ACTIVE_SUBSCRIPTION"),
    5: .same(proto: "DEVICE_NOT_REGISTERED"),
    6: .same(proto: "DEVICE_NOT_ACTIVE"),
  ]
}

extension Nym_Vpn_ConnectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entry"),
    2: .same(proto: "exit"),
    3: .same(proto: "dns"),
    4: .standard(proto: "disable_routing"),
    5: .standard(proto: "enable_two_hop"),
    6: .standard(proto: "disable_poisson_rate"),
    7: .standard(proto: "disable_background_cover_traffic"),
    8: .standard(proto: "enable_credentials_mode"),
    12: .standard(proto: "user_agent"),
    9: .standard(proto: "min_mixnode_performance"),
    10: .standard(proto: "min_gateway_mixnet_performance"),
    11: .standard(proto: "min_gateway_vpn_performance"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._entry) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._exit) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._dns) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.disableRouting) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.enableTwoHop) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.disablePoissonRate) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.disableBackgroundCoverTraffic) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.enableCredentialsMode) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._minMixnodePerformance) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._minGatewayMixnetPerformance) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._minGatewayVpnPerformance) }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._userAgent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._entry {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._exit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._dns {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.disableRouting != false {
      try visitor.visitSingularBoolField(value: self.disableRouting, fieldNumber: 4)
    }
    if self.enableTwoHop != false {
      try visitor.visitSingularBoolField(value: self.enableTwoHop, fieldNumber: 5)
    }
    if self.disablePoissonRate != false {
      try visitor.visitSingularBoolField(value: self.disablePoissonRate, fieldNumber: 6)
    }
    if self.disableBackgroundCoverTraffic != false {
      try visitor.visitSingularBoolField(value: self.disableBackgroundCoverTraffic, fieldNumber: 7)
    }
    if self.enableCredentialsMode != false {
      try visitor.visitSingularBoolField(value: self.enableCredentialsMode, fieldNumber: 8)
    }
    try { if let v = self._minMixnodePerformance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._minGatewayMixnetPerformance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._minGatewayVpnPerformance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._userAgent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ConnectRequest, rhs: Nym_Vpn_ConnectRequest) -> Bool {
    if lhs._entry != rhs._entry {return false}
    if lhs._exit != rhs._exit {return false}
    if lhs._dns != rhs._dns {return false}
    if lhs.disableRouting != rhs.disableRouting {return false}
    if lhs.enableTwoHop != rhs.enableTwoHop {return false}
    if lhs.disablePoissonRate != rhs.disablePoissonRate {return false}
    if lhs.disableBackgroundCoverTraffic != rhs.disableBackgroundCoverTraffic {return false}
    if lhs.enableCredentialsMode != rhs.enableCredentialsMode {return false}
    if lhs._userAgent != rhs._userAgent {return false}
    if lhs._minMixnodePerformance != rhs._minMixnodePerformance {return false}
    if lhs._minGatewayMixnetPerformance != rhs._minGatewayMixnetPerformance {return false}
    if lhs._minGatewayVpnPerformance != rhs._minGatewayVpnPerformance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ConnectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ConnectResponse, rhs: Nym_Vpn_ConnectResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_DisconnectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisconnectRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_DisconnectRequest, rhs: Nym_Vpn_DisconnectRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_DisconnectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisconnectResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_DisconnectResponse, rhs: Nym_Vpn_DisconnectResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ConnectionDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectionDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "entry_gateway"),
    2: .standard(proto: "exit_gateway"),
    3: .standard(proto: "protocol_details"),
    4: .same(proto: "since"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._entryGateway) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._exitGateway) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._protocolDetails) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._since) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._entryGateway {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._exitGateway {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._protocolDetails {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._since {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ConnectionDetails, rhs: Nym_Vpn_ConnectionDetails) -> Bool {
    if lhs._entryGateway != rhs._entryGateway {return false}
    if lhs._exitGateway != rhs._exitGateway {return false}
    if lhs._protocolDetails != rhs._protocolDetails {return false}
    if lhs._since != rhs._since {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_StatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StatusRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_StatusRequest, rhs: Nym_Vpn_StatusRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_StatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StatusResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "details"),
    3: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.status != .statusUnspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_StatusResponse, rhs: Nym_Vpn_StatusResponse) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs._details != rhs._details {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ConnectionStateChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectionStateChange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.status != .statusUnspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ConnectionStateChange, rhs: Nym_Vpn_ConnectionStateChange) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ConnectionStatusUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectionStatusUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .same(proto: "message"),
    3: .same(proto: "details"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.details) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.kind != .unspecified {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.details.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.details, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ConnectionStatusUpdate, rhs: Nym_Vpn_ConnectionStatusUpdate) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.message != rhs.message {return false}
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ConnectionStatusUpdate.StatusType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_TYPE_UNSPECIFIED"),
    1: .same(proto: "UNKNOWN"),
    2: .same(proto: "ENTRY_GATEWAY_CONNECTION_ESTABLISHED"),
    3: .same(proto: "EXIT_ROUTER_CONNECTION_ESTABLISHED"),
    4: .same(proto: "TUNNEL_END_TO_END_CONNECTION_ESTABLISHED"),
    5: .same(proto: "ENTRY_GATEWAY_NOT_ROUTING_MIXNET_MESSAGES"),
    6: .same(proto: "EXIT_ROUTER_NOT_RESPONDING_TO_IPV4_PING"),
    7: .same(proto: "EXIT_ROUTER_NOT_RESPONDING_TO_IPV6_PING"),
    8: .same(proto: "EXIT_ROUTER_NOT_ROUTING_IPV4_TRAFFIC"),
    9: .same(proto: "EXIT_ROUTER_NOT_ROUTING_IPV6_TRAFFIC"),
    10: .same(proto: "CONNECTION_OK_IPV4"),
    11: .same(proto: "CONNECTION_OK_IPV6"),
    12: .same(proto: "REMAINING_BANDWIDTH"),
    13: .same(proto: "NO_BANDWIDTH"),
    14: .same(proto: "WG_TUNNEL_ERROR"),
  ]
}

extension Nym_Vpn_Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Error"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .same(proto: "message"),
    3: .same(proto: "details"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.details) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.kind != .unspecified {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.details.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.details, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_Error, rhs: Nym_Vpn_Error) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.message != rhs.message {return false}
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_Error.ErrorType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ERROR_TYPE_UNSPECIFIED"),
    1: .same(proto: "UNHANDLED"),
    2: .same(proto: "NO_VALID_CREDENTIALS"),
    6: .same(proto: "TIMEOUT"),
    7: .same(proto: "MIXNET_TIMEOUT"),
    8: .same(proto: "GATEWAY_DIRECTORY"),
    9: .same(proto: "GATEWAY_DIRECTORY_LOOKUP_GATEWAYS"),
    10: .same(proto: "GATEWAY_DIRECTORY_LOOKUP_GATEWAY_IDENTITY"),
    11: .same(proto: "GATEWAY_DIRECTORY_LOOKUP_ROUTER_ADDRESS"),
    12: .same(proto: "GATEWAY_DIRECTORY_LOOKUP_IP"),
    13: .same(proto: "GATEWAY_DIRECTORY_ENTRY"),
    14: .same(proto: "GATEWAY_DIRECTORY_ENTRY_LOCATION"),
    15: .same(proto: "GATEWAY_DIRECTORY_EXIT"),
    16: .same(proto: "GATEWAY_DIRECTORY_EXIT_LOCATION"),
    17: .same(proto: "GATEWAY_DIRECTORY_SAME_ENTRY_AND_EXIT_GW"),
    18: .same(proto: "OUT_OF_BANDWIDTH"),
    19: .same(proto: "MIXNET_STORAGE_PATHS"),
    20: .same(proto: "MIXNET_DEFAULT_STORAGE"),
    21: .same(proto: "MIXNET_BUILD_CLIENT"),
    22: .same(proto: "MIXNET_CONNECT"),
    23: .same(proto: "MIXNET_ENTRY_GATEWAY"),
    24: .same(proto: "GATEWAY_DIRECTORY_ENTRY_ID"),
    25: .same(proto: "IPR_FAILED_TO_CONNECT"),
    26: .same(proto: "OUT_OF_BANDWIDTH_WHEN_SETTING_UP_TUNNEL"),
    27: .same(proto: "BRING_INTERFACE_UP"),
    28: .same(proto: "FIREWALL_INIT"),
    29: .same(proto: "FIREWALL_RESET_POLICY"),
    30: .same(proto: "DNS_INIT"),
    31: .same(proto: "DNS_SET"),
    32: .same(proto: "FIND_DEFAULT_INTERFACE"),
    33: .same(proto: "INTERNAL"),
    34: .same(proto: "AUTHENTICATOR_FAILED_TO_CONNECT"),
    35: .same(proto: "AUTHENTICATOR_CONNECT_TIMEOUT"),
    36: .same(proto: "AUTHENTICATOR_INVALID_RESPONSE"),
    37: .same(proto: "AUTHENTICATOR_REGISTRATION_DATA_VERIFICATION"),
    38: .same(proto: "AUTHENTICATOR_ENTRY_GATEWAY_SOCKET_ADDR"),
    39: .same(proto: "AUTHENTICATOR_ENTRY_GATEWAY_IPV4"),
    40: .same(proto: "AUTHENTICATOR_WRONG_VERSION"),
    41: .same(proto: "AUTHENTICATOR_MALFORMED_REPLY"),
    42: .same(proto: "ADD_IPV6_ROUTE"),
    43: .same(proto: "TUN"),
    44: .same(proto: "ROUTING"),
    45: .same(proto: "WIREGUARD_CONFIG"),
    46: .same(proto: "MIXNET_CONNECTION_MONITOR"),
    47: .same(proto: "AUTHENTICATOR_ADDRESS_NOT_FOUND"),
    48: .same(proto: "AUTHENTICATOR_AUTHENTICATION_NOT_POSSIBLE"),
    49: .same(proto: "UNHANDLED_EXIT"),
  ]
}

extension Nym_Vpn_AsEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AsEntry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "can_connect"),
    2: .standard(proto: "can_route"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.canConnect) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.canRoute) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.canConnect != false {
      try visitor.visitSingularBoolField(value: self.canConnect, fieldNumber: 1)
    }
    if self.canRoute != false {
      try visitor.visitSingularBoolField(value: self.canRoute, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_AsEntry, rhs: Nym_Vpn_AsEntry) -> Bool {
    if lhs.canConnect != rhs.canConnect {return false}
    if lhs.canRoute != rhs.canRoute {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_AsExit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AsExit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "can_connect"),
    2: .standard(proto: "can_route_ip_v4"),
    3: .standard(proto: "can_route_ip_v6"),
    4: .standard(proto: "can_route_ip_external_v4"),
    5: .standard(proto: "can_route_ip_external_v6"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.canConnect) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.canRouteIpV4) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.canRouteIpV6) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.canRouteIpExternalV4) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.canRouteIpExternalV6) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.canConnect != false {
      try visitor.visitSingularBoolField(value: self.canConnect, fieldNumber: 1)
    }
    if self.canRouteIpV4 != false {
      try visitor.visitSingularBoolField(value: self.canRouteIpV4, fieldNumber: 2)
    }
    if self.canRouteIpV6 != false {
      try visitor.visitSingularBoolField(value: self.canRouteIpV6, fieldNumber: 3)
    }
    if self.canRouteIpExternalV4 != false {
      try visitor.visitSingularBoolField(value: self.canRouteIpExternalV4, fieldNumber: 4)
    }
    if self.canRouteIpExternalV6 != false {
      try visitor.visitSingularBoolField(value: self.canRouteIpExternalV6, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_AsExit, rhs: Nym_Vpn_AsExit) -> Bool {
    if lhs.canConnect != rhs.canConnect {return false}
    if lhs.canRouteIpV4 != rhs.canRouteIpV4 {return false}
    if lhs.canRouteIpV6 != rhs.canRouteIpV6 {return false}
    if lhs.canRouteIpExternalV4 != rhs.canRouteIpExternalV4 {return false}
    if lhs.canRouteIpExternalV6 != rhs.canRouteIpExternalV6 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_WgProbeResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WgProbeResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "can_register"),
    2: .standard(proto: "can_handshake"),
    3: .standard(proto: "can_resolve_dns"),
    4: .standard(proto: "ping_hosts_performance"),
    5: .standard(proto: "ping_ips_performance"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.canRegister) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.canHandshake) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.canResolveDns) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.pingHostsPerformance) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.pingIpsPerformance) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.canRegister != false {
      try visitor.visitSingularBoolField(value: self.canRegister, fieldNumber: 1)
    }
    if self.canHandshake != false {
      try visitor.visitSingularBoolField(value: self.canHandshake, fieldNumber: 2)
    }
    if self.canResolveDns != false {
      try visitor.visitSingularBoolField(value: self.canResolveDns, fieldNumber: 3)
    }
    if self.pingHostsPerformance != 0 {
      try visitor.visitSingularFloatField(value: self.pingHostsPerformance, fieldNumber: 4)
    }
    if self.pingIpsPerformance != 0 {
      try visitor.visitSingularFloatField(value: self.pingIpsPerformance, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_WgProbeResult, rhs: Nym_Vpn_WgProbeResult) -> Bool {
    if lhs.canRegister != rhs.canRegister {return false}
    if lhs.canHandshake != rhs.canHandshake {return false}
    if lhs.canResolveDns != rhs.canResolveDns {return false}
    if lhs.pingHostsPerformance != rhs.pingHostsPerformance {return false}
    if lhs.pingIpsPerformance != rhs.pingIpsPerformance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ProbeOutcome: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProbeOutcome"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "as_entry"),
    2: .standard(proto: "as_exit"),
    3: .same(proto: "wg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asEntry) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._asExit) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._wg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asEntry {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._asExit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._wg {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ProbeOutcome, rhs: Nym_Vpn_ProbeOutcome) -> Bool {
    if lhs._asEntry != rhs._asEntry {return false}
    if lhs._asExit != rhs._asExit {return false}
    if lhs._wg != rhs._wg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_Probe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Probe"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "last_updated_utc"),
    2: .same(proto: "outcome"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._lastUpdatedUtc) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._outcome) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._lastUpdatedUtc {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._outcome {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_Probe, rhs: Nym_Vpn_Probe) -> Bool {
    if lhs._lastUpdatedUtc != rhs._lastUpdatedUtc {return false}
    if lhs._outcome != rhs._outcome {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GatewayResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GatewayResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "location"),
    3: .standard(proto: "last_probe"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._location) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._lastProbe) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._location {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._lastProbe {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GatewayResponse, rhs: Nym_Vpn_GatewayResponse) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._location != rhs._location {return false}
    if lhs._lastProbe != rhs._lastProbe {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ListGatewaysRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListGatewaysRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    4: .standard(proto: "user_agent"),
    2: .standard(proto: "min_mixnet_performance"),
    3: .standard(proto: "min_vpn_performance"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._minMixnetPerformance) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._minVpnPerformance) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._userAgent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.kind != .unspecified {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
    }
    try { if let v = self._minMixnetPerformance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._minVpnPerformance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._userAgent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ListGatewaysRequest, rhs: Nym_Vpn_ListGatewaysRequest) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs._userAgent != rhs._userAgent {return false}
    if lhs._minMixnetPerformance != rhs._minMixnetPerformance {return false}
    if lhs._minVpnPerformance != rhs._minVpnPerformance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ListGatewaysResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListGatewaysResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gateways"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.gateways) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gateways.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.gateways, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ListGatewaysResponse, rhs: Nym_Vpn_ListGatewaysResponse) -> Bool {
    if lhs.gateways != rhs.gateways {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ListCountriesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListCountriesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    4: .standard(proto: "user_agent"),
    2: .standard(proto: "min_mixnet_performance"),
    3: .standard(proto: "min_vpn_performance"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._minMixnetPerformance) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._minVpnPerformance) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._userAgent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.kind != .unspecified {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
    }
    try { if let v = self._minMixnetPerformance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._minVpnPerformance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._userAgent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ListCountriesRequest, rhs: Nym_Vpn_ListCountriesRequest) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs._userAgent != rhs._userAgent {return false}
    if lhs._minMixnetPerformance != rhs._minMixnetPerformance {return false}
    if lhs._minVpnPerformance != rhs._minVpnPerformance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ListCountriesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListCountriesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "countries"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.countries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.countries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.countries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ListCountriesResponse, rhs: Nym_Vpn_ListCountriesResponse) -> Bool {
    if lhs.countries != rhs.countries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_StoreAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StoreAccountRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mnemonic"),
    2: .same(proto: "nonce"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mnemonic) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.nonce) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mnemonic.isEmpty {
      try visitor.visitSingularStringField(value: self.mnemonic, fieldNumber: 1)
    }
    if self.nonce != 0 {
      try visitor.visitSingularUInt32Field(value: self.nonce, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_StoreAccountRequest, rhs: Nym_Vpn_StoreAccountRequest) -> Bool {
    if lhs.mnemonic != rhs.mnemonic {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_StoreAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StoreAccountResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_StoreAccountResponse, rhs: Nym_Vpn_StoreAccountResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_IsAccountStoredRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IsAccountStoredRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_IsAccountStoredRequest, rhs: Nym_Vpn_IsAccountStoredRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_IsAccountStoredResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IsAccountStoredResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_stored"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.resp != nil {try decoder.handleConflictingOneOf()}
          self.resp = .isStored(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_AccountError?
        var hadOneofValue = false
        if let current = self.resp {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.resp = .error(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.resp {
    case .isStored?: try {
      guard case .isStored(let v)? = self.resp else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }()
    case .error?: try {
      guard case .error(let v)? = self.resp else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_IsAccountStoredResponse, rhs: Nym_Vpn_IsAccountStoredResponse) -> Bool {
    if lhs.resp != rhs.resp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_RemoveAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoveAccountRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_RemoveAccountRequest, rhs: Nym_Vpn_RemoveAccountRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_RemoveAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoveAccountResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_RemoveAccountResponse, rhs: Nym_Vpn_RemoveAccountResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetAccountIdentityRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAccountIdentityRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetAccountIdentityRequest, rhs: Nym_Vpn_GetAccountIdentityRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetAccountIdentityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAccountIdentityResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_identity"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.id != nil {try decoder.handleConflictingOneOf()}
          self.id = .accountIdentity(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_AccountError?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .error(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.id {
    case .accountIdentity?: try {
      guard case .accountIdentity(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .error?: try {
      guard case .error(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetAccountIdentityResponse, rhs: Nym_Vpn_GetAccountIdentityResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_AccountSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountSummary"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mnemonic"),
    2: .same(proto: "account"),
    3: .same(proto: "subscription"),
    4: .same(proto: "device"),
    5: .standard(proto: "pending_zk_nym"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._mnemonic) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._account) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._subscription) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._device) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.pendingZkNym) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mnemonic {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._account {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._subscription {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._device {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    if self.pendingZkNym != false {
      try visitor.visitSingularBoolField(value: self.pendingZkNym, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_AccountSummary, rhs: Nym_Vpn_AccountSummary) -> Bool {
    if lhs._mnemonic != rhs._mnemonic {return false}
    if lhs._account != rhs._account {return false}
    if lhs._subscription != rhs._subscription {return false}
    if lhs._device != rhs._device {return false}
    if lhs.pendingZkNym != rhs.pendingZkNym {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetAccountStateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAccountStateRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetAccountStateRequest, rhs: Nym_Vpn_GetAccountStateRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetAccountStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAccountStateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_summary"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Nym_Vpn_AccountSummary?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .accountSummary(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .accountSummary(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_AccountError?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .error(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .accountSummary?: try {
      guard case .accountSummary(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .error?: try {
      guard case .error(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetAccountStateResponse, rhs: Nym_Vpn_GetAccountStateResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_RefreshAccountStateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RefreshAccountStateRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_RefreshAccountStateRequest, rhs: Nym_Vpn_RefreshAccountStateRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_RefreshAccountStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RefreshAccountStateResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_RefreshAccountStateResponse, rhs: Nym_Vpn_RefreshAccountStateResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_FetchRawAccountSummaryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FetchRawAccountSummaryRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_FetchRawAccountSummaryRequest, rhs: Nym_Vpn_FetchRawAccountSummaryRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_FetchRawAccountSummaryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FetchRawAccountSummaryResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "json"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.json) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.json.isEmpty {
      try visitor.visitSingularStringField(value: self.json, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_FetchRawAccountSummaryResponse, rhs: Nym_Vpn_FetchRawAccountSummaryResponse) -> Bool {
    if lhs.json != rhs.json {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_FetchRawDevicesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FetchRawDevicesRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_FetchRawDevicesRequest, rhs: Nym_Vpn_FetchRawDevicesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_FetchRawDevicesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FetchRawDevicesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "json"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.json) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.json.isEmpty {
      try visitor.visitSingularStringField(value: self.json, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_FetchRawDevicesResponse, rhs: Nym_Vpn_FetchRawDevicesResponse) -> Bool {
    if lhs.json != rhs.json {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ResetDeviceIdentityRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResetDeviceIdentityRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "seed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._seed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._seed {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ResetDeviceIdentityRequest, rhs: Nym_Vpn_ResetDeviceIdentityRequest) -> Bool {
    if lhs._seed != rhs._seed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ResetDeviceIdentityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResetDeviceIdentityResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ResetDeviceIdentityResponse, rhs: Nym_Vpn_ResetDeviceIdentityResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetDeviceIdentityRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetDeviceIdentityRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetDeviceIdentityRequest, rhs: Nym_Vpn_GetDeviceIdentityRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetDeviceIdentityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetDeviceIdentityResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_identity"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.id != nil {try decoder.handleConflictingOneOf()}
          self.id = .deviceIdentity(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_AccountError?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .error(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.id {
    case .deviceIdentity?: try {
      guard case .deviceIdentity(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .error?: try {
      guard case .error(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetDeviceIdentityResponse, rhs: Nym_Vpn_GetDeviceIdentityResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_RegisterDeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegisterDeviceRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_RegisterDeviceRequest, rhs: Nym_Vpn_RegisterDeviceRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_RegisterDeviceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegisterDeviceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "json"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.json) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.json.isEmpty {
      try visitor.visitSingularStringField(value: self.json, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_RegisterDeviceResponse, rhs: Nym_Vpn_RegisterDeviceResponse) -> Bool {
    if lhs.json != rhs.json {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_RequestZkNymRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestZkNymRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_RequestZkNymRequest, rhs: Nym_Vpn_RequestZkNymRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_RequestZkNymResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestZkNymResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "json"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.json) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.json.isEmpty {
      try visitor.visitSingularStringField(value: self.json, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_RequestZkNymResponse, rhs: Nym_Vpn_RequestZkNymResponse) -> Bool {
    if lhs.json != rhs.json {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetDeviceZkNymsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetDeviceZkNymsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetDeviceZkNymsRequest, rhs: Nym_Vpn_GetDeviceZkNymsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetDeviceZkNymsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetDeviceZkNymsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "json"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.json) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.json.isEmpty {
      try visitor.visitSingularStringField(value: self.json, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetDeviceZkNymsResponse, rhs: Nym_Vpn_GetDeviceZkNymsResponse) -> Bool {
    if lhs.json != rhs.json {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_IsReadyToConnectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IsReadyToConnectRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_IsReadyToConnectRequest, rhs: Nym_Vpn_IsReadyToConnectRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_IsReadyToConnectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IsReadyToConnectResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.kind != .unspecified {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_IsReadyToConnectResponse, rhs: Nym_Vpn_IsReadyToConnectResponse) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_IsReadyToConnectResponse.IsReadyToConnectResponseType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IS_READY_TO_CONNECT_RESPONSE_TYPE_UNSPECIFIED"),
    1: .same(proto: "READY"),
    2: .same(proto: "NO_ACCOUNT_STORED"),
    3: .same(proto: "ACCOUNT_NOT_ACTIVE"),
    4: .same(proto: "NO_ACTIVE_SUBSCRIPTION"),
    5: .same(proto: "DEVICE_NOT_REGISTERED"),
    6: .same(proto: "DEVICE_NOT_ACTIVE"),
  ]
}

extension Nym_Vpn_AccountError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountError"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .same(proto: "message"),
    3: .same(proto: "details"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.details) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.kind != .storeAccountErrorUnspecified {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.details.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.details, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_AccountError, rhs: Nym_Vpn_AccountError) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.message != rhs.message {return false}
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_AccountError.AccountErrorType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STORE_ACCOUNT_ERROR_UNSPECIFIED"),
    1: .same(proto: "INVALID_MNEMONIC"),
    2: .same(proto: "STORAGE"),
  ]
}
