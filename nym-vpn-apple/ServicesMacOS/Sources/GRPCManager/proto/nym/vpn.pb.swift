// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: vpn.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Nym_Vpn_ConnectionStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case statusUnspecified // = 0
  case unknown // = 1
  case notConnected // = 2
  case connecting // = 3
  case connected // = 4
  case disconnecting // = 5
  case connectionFailed // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .statusUnspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .statusUnspecified
    case 1: self = .unknown
    case 2: self = .notConnected
    case 3: self = .connecting
    case 4: self = .connected
    case 5: self = .disconnecting
    case 6: self = .connectionFailed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .statusUnspecified: return 0
    case .unknown: return 1
    case .notConnected: return 2
    case .connecting: return 3
    case .connected: return 4
    case .disconnecting: return 5
    case .connectionFailed: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Nym_Vpn_ConnectionStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Nym_Vpn_ConnectionStatus] = [
    .statusUnspecified,
    .unknown,
    .notConnected,
    .connecting,
    .connected,
    .disconnecting,
    .connectionFailed,
  ]
}

#endif  // swift(>=4.2)

enum Nym_Vpn_GatewayType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case mixnetEntry // = 1
  case mixnetExit // = 2
  case wg // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .mixnetEntry
    case 2: self = .mixnetExit
    case 3: self = .wg
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .mixnetEntry: return 1
    case .mixnetExit: return 2
    case .wg: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Nym_Vpn_GatewayType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Nym_Vpn_GatewayType] = [
    .unspecified,
    .mixnetEntry,
    .mixnetExit,
    .wg,
  ]
}

#endif  // swift(>=4.2)

enum Nym_Vpn_AccountRegistered: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case accountRegistered // = 1
  case accountNotRegistered // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .accountRegistered
    case 2: self = .accountNotRegistered
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .accountRegistered: return 1
    case .accountNotRegistered: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Nym_Vpn_AccountRegistered: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Nym_Vpn_AccountRegistered] = [
    .unspecified,
    .accountRegistered,
    .accountNotRegistered,
  ]
}

#endif  // swift(>=4.2)

enum Nym_Vpn_MnemonicState: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case notStored // = 1
  case stored // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .notStored
    case 2: self = .stored
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .notStored: return 1
    case .stored: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Nym_Vpn_MnemonicState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Nym_Vpn_MnemonicState] = [
    .unspecified,
    .notStored,
    .stored,
  ]
}

#endif  // swift(>=4.2)

enum Nym_Vpn_AccountState: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case notRegistered // = 1
  case inactive // = 2
  case active // = 3
  case deleteMe // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .notRegistered
    case 2: self = .inactive
    case 3: self = .active
    case 4: self = .deleteMe
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .notRegistered: return 1
    case .inactive: return 2
    case .active: return 3
    case .deleteMe: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Nym_Vpn_AccountState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Nym_Vpn_AccountState] = [
    .unspecified,
    .notRegistered,
    .inactive,
    .active,
    .deleteMe,
  ]
}

#endif  // swift(>=4.2)

enum Nym_Vpn_SubscriptionState: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case notRegistered // = 1
  case pending // = 2
  case active // = 3
  case complete // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .notRegistered
    case 2: self = .pending
    case 3: self = .active
    case 4: self = .complete
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .notRegistered: return 1
    case .pending: return 2
    case .active: return 3
    case .complete: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Nym_Vpn_SubscriptionState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Nym_Vpn_SubscriptionState] = [
    .unspecified,
    .notRegistered,
    .pending,
    .active,
    .complete,
  ]
}

#endif  // swift(>=4.2)

enum Nym_Vpn_DeviceState: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case notRegistered // = 1
  case inactive // = 2
  case active // = 3
  case deleteMe // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .notRegistered
    case 2: self = .inactive
    case 3: self = .active
    case 4: self = .deleteMe
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .notRegistered: return 1
    case .inactive: return 2
    case .active: return 3
    case .deleteMe: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Nym_Vpn_DeviceState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Nym_Vpn_DeviceState] = [
    .unspecified,
    .notRegistered,
    .inactive,
    .active,
    .deleteMe,
  ]
}

#endif  // swift(>=4.2)

enum Nym_Vpn_DeviceStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case active // = 1
  case inactive // = 2
  case deleteMe // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .active
    case 2: self = .inactive
    case 3: self = .deleteMe
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .active: return 1
    case .inactive: return 2
    case .deleteMe: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Nym_Vpn_DeviceStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Nym_Vpn_DeviceStatus] = [
    .unspecified,
    .active,
    .inactive,
    .deleteMe,
  ]
}

#endif  // swift(>=4.2)

struct Nym_Vpn_Empty {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Represents the identity of a gateway
struct Nym_Vpn_Gateway {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Represents a nym-address of the form id.enc@gateway
struct Nym_Vpn_Address {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nymAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_Location {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var twoLetterIsoCountryCode: String = String()

  var latitude: Double {
    get {return _latitude ?? 0}
    set {_latitude = newValue}
  }
  /// Returns true if `latitude` has been explicitly set.
  var hasLatitude: Bool {return self._latitude != nil}
  /// Clears the value of `latitude`. Subsequent reads from it will return its default value.
  mutating func clearLatitude() {self._latitude = nil}

  var longitude: Double {
    get {return _longitude ?? 0}
    set {_longitude = newValue}
  }
  /// Returns true if `longitude` has been explicitly set.
  var hasLongitude: Bool {return self._longitude != nil}
  /// Clears the value of `longitude`. Subsequent reads from it will return its default value.
  mutating func clearLongitude() {self._longitude = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _latitude: Double? = nil
  fileprivate var _longitude: Double? = nil
}

struct Nym_Vpn_EntryNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entryNodeEnum: Nym_Vpn_EntryNode.OneOf_EntryNodeEnum? = nil

  var gateway: Nym_Vpn_Gateway {
    get {
      if case .gateway(let v)? = entryNodeEnum {return v}
      return Nym_Vpn_Gateway()
    }
    set {entryNodeEnum = .gateway(newValue)}
  }

  var location: Nym_Vpn_Location {
    get {
      if case .location(let v)? = entryNodeEnum {return v}
      return Nym_Vpn_Location()
    }
    set {entryNodeEnum = .location(newValue)}
  }

  var randomLowLatency: Nym_Vpn_Empty {
    get {
      if case .randomLowLatency(let v)? = entryNodeEnum {return v}
      return Nym_Vpn_Empty()
    }
    set {entryNodeEnum = .randomLowLatency(newValue)}
  }

  var random: Nym_Vpn_Empty {
    get {
      if case .random(let v)? = entryNodeEnum {return v}
      return Nym_Vpn_Empty()
    }
    set {entryNodeEnum = .random(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_EntryNodeEnum: Equatable {
    case gateway(Nym_Vpn_Gateway)
    case location(Nym_Vpn_Location)
    case randomLowLatency(Nym_Vpn_Empty)
    case random(Nym_Vpn_Empty)

  #if !swift(>=4.1)
    static func ==(lhs: Nym_Vpn_EntryNode.OneOf_EntryNodeEnum, rhs: Nym_Vpn_EntryNode.OneOf_EntryNodeEnum) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.gateway, .gateway): return {
        guard case .gateway(let l) = lhs, case .gateway(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.location, .location): return {
        guard case .location(let l) = lhs, case .location(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.randomLowLatency, .randomLowLatency): return {
        guard case .randomLowLatency(let l) = lhs, case .randomLowLatency(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.random, .random): return {
        guard case .random(let l) = lhs, case .random(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Nym_Vpn_ExitNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var exitNodeEnum: Nym_Vpn_ExitNode.OneOf_ExitNodeEnum? = nil

  var address: Nym_Vpn_Address {
    get {
      if case .address(let v)? = exitNodeEnum {return v}
      return Nym_Vpn_Address()
    }
    set {exitNodeEnum = .address(newValue)}
  }

  var gateway: Nym_Vpn_Gateway {
    get {
      if case .gateway(let v)? = exitNodeEnum {return v}
      return Nym_Vpn_Gateway()
    }
    set {exitNodeEnum = .gateway(newValue)}
  }

  var location: Nym_Vpn_Location {
    get {
      if case .location(let v)? = exitNodeEnum {return v}
      return Nym_Vpn_Location()
    }
    set {exitNodeEnum = .location(newValue)}
  }

  var random: Nym_Vpn_Empty {
    get {
      if case .random(let v)? = exitNodeEnum {return v}
      return Nym_Vpn_Empty()
    }
    set {exitNodeEnum = .random(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ExitNodeEnum: Equatable {
    case address(Nym_Vpn_Address)
    case gateway(Nym_Vpn_Gateway)
    case location(Nym_Vpn_Location)
    case random(Nym_Vpn_Empty)

  #if !swift(>=4.1)
    static func ==(lhs: Nym_Vpn_ExitNode.OneOf_ExitNodeEnum, rhs: Nym_Vpn_ExitNode.OneOf_ExitNodeEnum) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.address, .address): return {
        guard case .address(let l) = lhs, case .address(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.gateway, .gateway): return {
        guard case .gateway(let l) = lhs, case .gateway(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.location, .location): return {
        guard case .location(let l) = lhs, case .location(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.random, .random): return {
        guard case .random(let l) = lhs, case .random(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Nym_Vpn_MixConnectedStateDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nymAddress: Nym_Vpn_Address {
    get {return _nymAddress ?? Nym_Vpn_Address()}
    set {_nymAddress = newValue}
  }
  /// Returns true if `nymAddress` has been explicitly set.
  var hasNymAddress: Bool {return self._nymAddress != nil}
  /// Clears the value of `nymAddress`. Subsequent reads from it will return its default value.
  mutating func clearNymAddress() {self._nymAddress = nil}

  var exitIpr: Nym_Vpn_Address {
    get {return _exitIpr ?? Nym_Vpn_Address()}
    set {_exitIpr = newValue}
  }
  /// Returns true if `exitIpr` has been explicitly set.
  var hasExitIpr: Bool {return self._exitIpr != nil}
  /// Clears the value of `exitIpr`. Subsequent reads from it will return its default value.
  mutating func clearExitIpr() {self._exitIpr = nil}

  var ipv4: String = String()

  var ipv6: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _nymAddress: Nym_Vpn_Address? = nil
  fileprivate var _exitIpr: Nym_Vpn_Address? = nil
}

struct Nym_Vpn_WgConnectedStateDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entryIpv4: String = String()

  var exitIpv4: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_ConnectedStateDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var connectedStateDetails: Nym_Vpn_ConnectedStateDetails.OneOf_ConnectedStateDetails? = nil

  var mix: Nym_Vpn_MixConnectedStateDetails {
    get {
      if case .mix(let v)? = connectedStateDetails {return v}
      return Nym_Vpn_MixConnectedStateDetails()
    }
    set {connectedStateDetails = .mix(newValue)}
  }

  var wg: Nym_Vpn_WgConnectedStateDetails {
    get {
      if case .wg(let v)? = connectedStateDetails {return v}
      return Nym_Vpn_WgConnectedStateDetails()
    }
    set {connectedStateDetails = .wg(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ConnectedStateDetails: Equatable {
    case mix(Nym_Vpn_MixConnectedStateDetails)
    case wg(Nym_Vpn_WgConnectedStateDetails)

  #if !swift(>=4.1)
    static func ==(lhs: Nym_Vpn_ConnectedStateDetails.OneOf_ConnectedStateDetails, rhs: Nym_Vpn_ConnectedStateDetails.OneOf_ConnectedStateDetails) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.mix, .mix): return {
        guard case .mix(let l) = lhs, case .mix(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.wg, .wg): return {
        guard case .wg(let l) = lhs, case .wg(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Nym_Vpn_Dns {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ip: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_Url {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var url: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Inspired by
/// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/User-Agent
/// Forward slashes '/' are not valid
struct Nym_Vpn_UserAgent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Example:
  ///    nym-vpn-app
  ///    nym-vpnd
  ///    nym-vpn-cli
  var application: String = String()

  /// Format: version[-optional] [(daemon version[-optional])]
  /// Example:
  ///    0.1.8
  ///    0.1.8-debug (0.1.6)
  ///    0.2.1-fdroid
  var version: String = String()

  /// Format: OS; OS version; CPU
  /// Example:
  ///    Windows NT 6.1; Win64; x64
  ///    Macintosh; Intel Mac OS X 14.6.1
  ///    iPad; U; CPU OS 3_2 like Mac OS X; en-us
  var platform: String = String()

  /// Format: git hash [(daemon git hash)]
  /// Commit hash should be at least 7 characters long
  /// Example:
  ///    4h9fk59 (4kdufle)
  ///    4h9fk59
  var gitCommit: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_DenomDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var base: String = String()

  var display: String = String()

  var displayExponent: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_ChainDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bech32AccountPrefix: String = String()

  var mixDenom: Nym_Vpn_DenomDetails {
    get {return _mixDenom ?? Nym_Vpn_DenomDetails()}
    set {_mixDenom = newValue}
  }
  /// Returns true if `mixDenom` has been explicitly set.
  var hasMixDenom: Bool {return self._mixDenom != nil}
  /// Clears the value of `mixDenom`. Subsequent reads from it will return its default value.
  mutating func clearMixDenom() {self._mixDenom = nil}

  var stakeDenom: Nym_Vpn_DenomDetails {
    get {return _stakeDenom ?? Nym_Vpn_DenomDetails()}
    set {_stakeDenom = newValue}
  }
  /// Returns true if `stakeDenom` has been explicitly set.
  var hasStakeDenom: Bool {return self._stakeDenom != nil}
  /// Clears the value of `stakeDenom`. Subsequent reads from it will return its default value.
  mutating func clearStakeDenom() {self._stakeDenom = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mixDenom: Nym_Vpn_DenomDetails? = nil
  fileprivate var _stakeDenom: Nym_Vpn_DenomDetails? = nil
}

struct Nym_Vpn_NymContracts {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mixnetContractAddress: String {
    get {return _mixnetContractAddress ?? String()}
    set {_mixnetContractAddress = newValue}
  }
  /// Returns true if `mixnetContractAddress` has been explicitly set.
  var hasMixnetContractAddress: Bool {return self._mixnetContractAddress != nil}
  /// Clears the value of `mixnetContractAddress`. Subsequent reads from it will return its default value.
  mutating func clearMixnetContractAddress() {self._mixnetContractAddress = nil}

  var vestingContractAddress: String {
    get {return _vestingContractAddress ?? String()}
    set {_vestingContractAddress = newValue}
  }
  /// Returns true if `vestingContractAddress` has been explicitly set.
  var hasVestingContractAddress: Bool {return self._vestingContractAddress != nil}
  /// Clears the value of `vestingContractAddress`. Subsequent reads from it will return its default value.
  mutating func clearVestingContractAddress() {self._vestingContractAddress = nil}

  var ecashContractAddress: String {
    get {return _ecashContractAddress ?? String()}
    set {_ecashContractAddress = newValue}
  }
  /// Returns true if `ecashContractAddress` has been explicitly set.
  var hasEcashContractAddress: Bool {return self._ecashContractAddress != nil}
  /// Clears the value of `ecashContractAddress`. Subsequent reads from it will return its default value.
  mutating func clearEcashContractAddress() {self._ecashContractAddress = nil}

  var groupContractAddress: String {
    get {return _groupContractAddress ?? String()}
    set {_groupContractAddress = newValue}
  }
  /// Returns true if `groupContractAddress` has been explicitly set.
  var hasGroupContractAddress: Bool {return self._groupContractAddress != nil}
  /// Clears the value of `groupContractAddress`. Subsequent reads from it will return its default value.
  mutating func clearGroupContractAddress() {self._groupContractAddress = nil}

  var multisigContractAddress: String {
    get {return _multisigContractAddress ?? String()}
    set {_multisigContractAddress = newValue}
  }
  /// Returns true if `multisigContractAddress` has been explicitly set.
  var hasMultisigContractAddress: Bool {return self._multisigContractAddress != nil}
  /// Clears the value of `multisigContractAddress`. Subsequent reads from it will return its default value.
  mutating func clearMultisigContractAddress() {self._multisigContractAddress = nil}

  var coconutDkgContractAddress: String {
    get {return _coconutDkgContractAddress ?? String()}
    set {_coconutDkgContractAddress = newValue}
  }
  /// Returns true if `coconutDkgContractAddress` has been explicitly set.
  var hasCoconutDkgContractAddress: Bool {return self._coconutDkgContractAddress != nil}
  /// Clears the value of `coconutDkgContractAddress`. Subsequent reads from it will return its default value.
  mutating func clearCoconutDkgContractAddress() {self._coconutDkgContractAddress = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mixnetContractAddress: String? = nil
  fileprivate var _vestingContractAddress: String? = nil
  fileprivate var _ecashContractAddress: String? = nil
  fileprivate var _groupContractAddress: String? = nil
  fileprivate var _multisigContractAddress: String? = nil
  fileprivate var _coconutDkgContractAddress: String? = nil
}

struct Nym_Vpn_NymNetworkDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var networkName: String = String()

  var chainDetails: Nym_Vpn_ChainDetails {
    get {return _chainDetails ?? Nym_Vpn_ChainDetails()}
    set {_chainDetails = newValue}
  }
  /// Returns true if `chainDetails` has been explicitly set.
  var hasChainDetails: Bool {return self._chainDetails != nil}
  /// Clears the value of `chainDetails`. Subsequent reads from it will return its default value.
  mutating func clearChainDetails() {self._chainDetails = nil}

  var endpoints: [Nym_Vpn_ValidatorDetails] = []

  var contracts: Nym_Vpn_NymContracts {
    get {return _contracts ?? Nym_Vpn_NymContracts()}
    set {_contracts = newValue}
  }
  /// Returns true if `contracts` has been explicitly set.
  var hasContracts: Bool {return self._contracts != nil}
  /// Clears the value of `contracts`. Subsequent reads from it will return its default value.
  mutating func clearContracts() {self._contracts = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _chainDetails: Nym_Vpn_ChainDetails? = nil
  fileprivate var _contracts: Nym_Vpn_NymContracts? = nil
}

struct Nym_Vpn_NymVpnNetworkDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nymVpnApiURL: Nym_Vpn_Url {
    get {return _nymVpnApiURL ?? Nym_Vpn_Url()}
    set {_nymVpnApiURL = newValue}
  }
  /// Returns true if `nymVpnApiURL` has been explicitly set.
  var hasNymVpnApiURL: Bool {return self._nymVpnApiURL != nil}
  /// Clears the value of `nymVpnApiURL`. Subsequent reads from it will return its default value.
  mutating func clearNymVpnApiURL() {self._nymVpnApiURL = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _nymVpnApiURL: Nym_Vpn_Url? = nil
}

struct Nym_Vpn_AccountManagement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var signUp: Nym_Vpn_Url {
    get {return _signUp ?? Nym_Vpn_Url()}
    set {_signUp = newValue}
  }
  /// Returns true if `signUp` has been explicitly set.
  var hasSignUp: Bool {return self._signUp != nil}
  /// Clears the value of `signUp`. Subsequent reads from it will return its default value.
  mutating func clearSignUp() {self._signUp = nil}

  var signIn: Nym_Vpn_Url {
    get {return _signIn ?? Nym_Vpn_Url()}
    set {_signIn = newValue}
  }
  /// Returns true if `signIn` has been explicitly set.
  var hasSignIn: Bool {return self._signIn != nil}
  /// Clears the value of `signIn`. Subsequent reads from it will return its default value.
  mutating func clearSignIn() {self._signIn = nil}

  var account: Nym_Vpn_Url {
    get {return _account ?? Nym_Vpn_Url()}
    set {_account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  var hasAccount: Bool {return self._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  mutating func clearAccount() {self._account = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _signUp: Nym_Vpn_Url? = nil
  fileprivate var _signIn: Nym_Vpn_Url? = nil
  fileprivate var _account: Nym_Vpn_Url? = nil
}

struct Nym_Vpn_ValidatorDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nyxdURL: Nym_Vpn_Url {
    get {return _nyxdURL ?? Nym_Vpn_Url()}
    set {_nyxdURL = newValue}
  }
  /// Returns true if `nyxdURL` has been explicitly set.
  var hasNyxdURL: Bool {return self._nyxdURL != nil}
  /// Clears the value of `nyxdURL`. Subsequent reads from it will return its default value.
  mutating func clearNyxdURL() {self._nyxdURL = nil}

  var websocketURL: Nym_Vpn_Url {
    get {return _websocketURL ?? Nym_Vpn_Url()}
    set {_websocketURL = newValue}
  }
  /// Returns true if `websocketURL` has been explicitly set.
  var hasWebsocketURL: Bool {return self._websocketURL != nil}
  /// Clears the value of `websocketURL`. Subsequent reads from it will return its default value.
  mutating func clearWebsocketURL() {self._websocketURL = nil}

  var apiURL: Nym_Vpn_Url {
    get {return _apiURL ?? Nym_Vpn_Url()}
    set {_apiURL = newValue}
  }
  /// Returns true if `apiURL` has been explicitly set.
  var hasApiURL: Bool {return self._apiURL != nil}
  /// Clears the value of `apiURL`. Subsequent reads from it will return its default value.
  mutating func clearApiURL() {self._apiURL = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _nyxdURL: Nym_Vpn_Url? = nil
  fileprivate var _websocketURL: Nym_Vpn_Url? = nil
  fileprivate var _apiURL: Nym_Vpn_Url? = nil
}

struct Nym_Vpn_InfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_InfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: String {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  var buildTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._buildTimestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._buildTimestamp = newValue}
  }
  /// Returns true if `buildTimestamp` has been explicitly set.
  var hasBuildTimestamp: Bool {return _storage._buildTimestamp != nil}
  /// Clears the value of `buildTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearBuildTimestamp() {_uniqueStorage()._buildTimestamp = nil}

  var triple: String {
    get {return _storage._triple}
    set {_uniqueStorage()._triple = newValue}
  }

  var platform: String {
    get {return _storage._platform}
    set {_uniqueStorage()._platform = newValue}
  }

  var gitCommit: String {
    get {return _storage._gitCommit}
    set {_uniqueStorage()._gitCommit = newValue}
  }

  var nymNetwork: Nym_Vpn_NymNetworkDetails {
    get {return _storage._nymNetwork ?? Nym_Vpn_NymNetworkDetails()}
    set {_uniqueStorage()._nymNetwork = newValue}
  }
  /// Returns true if `nymNetwork` has been explicitly set.
  var hasNymNetwork: Bool {return _storage._nymNetwork != nil}
  /// Clears the value of `nymNetwork`. Subsequent reads from it will return its default value.
  mutating func clearNymNetwork() {_uniqueStorage()._nymNetwork = nil}

  var nymVpnNetwork: Nym_Vpn_NymVpnNetworkDetails {
    get {return _storage._nymVpnNetwork ?? Nym_Vpn_NymVpnNetworkDetails()}
    set {_uniqueStorage()._nymVpnNetwork = newValue}
  }
  /// Returns true if `nymVpnNetwork` has been explicitly set.
  var hasNymVpnNetwork: Bool {return _storage._nymVpnNetwork != nil}
  /// Clears the value of `nymVpnNetwork`. Subsequent reads from it will return its default value.
  mutating func clearNymVpnNetwork() {_uniqueStorage()._nymVpnNetwork = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Nym_Vpn_SetNetworkRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var network: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_SetNetworkResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var error: Nym_Vpn_SetNetworkRequestError {
    get {return _error ?? Nym_Vpn_SetNetworkRequestError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Nym_Vpn_SetNetworkRequestError? = nil
}

struct Nym_Vpn_SetNetworkRequestError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Nym_Vpn_SetNetworkRequestError.SetNetworkRequestErrorType = .unspecified

  /// Internal message for logging and debugging
  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum SetNetworkRequestErrorType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unspecified // = 0

    /// Unspecified internal error
    case `internal` // = 1

    /// The network name provided is not valid
    case invalidNetworkName // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .internal
      case 2: self = .invalidNetworkName
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .internal: return 1
      case .invalidNetworkName: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Nym_Vpn_SetNetworkRequestError.SetNetworkRequestErrorType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Nym_Vpn_SetNetworkRequestError.SetNetworkRequestErrorType] = [
    .unspecified,
    .internal,
    .invalidNetworkName,
  ]
}

#endif  // swift(>=4.2)

struct Nym_Vpn_SystemMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var message: String = String()

  var properties: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_GetSystemMessagesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_GetSystemMessagesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var messages: [Nym_Vpn_SystemMessage] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_GetFeatureFlagsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_GetFeatureFlagsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var flags: Dictionary<String,String> = [:]

  var groups: Dictionary<String,Nym_Vpn_FeatureFlagGroup> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_FeatureFlagGroup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var map: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_Threshold {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var minPerformance: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_ConnectRequestError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Nym_Vpn_ConnectRequestError.ConnectRequestErrorType = .unspecified

  /// Internal message for logging and debugging
  var message: String = String()

  var messageID: String {
    get {return _messageID ?? String()}
    set {_messageID = newValue}
  }
  /// Returns true if `messageID` has been explicitly set.
  var hasMessageID: Bool {return self._messageID != nil}
  /// Clears the value of `messageID`. Subsequent reads from it will return its default value.
  mutating func clearMessageID() {self._messageID = nil}

  /// When we have an error request zk-nyms, this is the set of zk-nym failures
  var zkNymError: [Nym_Vpn_RequestZkNymError] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ConnectRequestErrorType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unspecified // = 0

    /// Unspecified internal error
    case `internal` // = 1

    /// General error
    case general // = 2

    /// No account recovery phrase stored
    case noAccountStored // = 3

    /// No device keys stored
    case noDeviceStored // = 4

    /// Update account failed
    case updateAccount // = 5

    /// Update device failed
    case updateDevice // = 6

    /// Device registration failed
    case registerDevice // = 7

    /// Requesting zk-nym failed
    case requestZkNym // = 8
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .internal
      case 2: self = .general
      case 3: self = .noAccountStored
      case 4: self = .noDeviceStored
      case 5: self = .updateAccount
      case 6: self = .updateDevice
      case 7: self = .registerDevice
      case 8: self = .requestZkNym
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .internal: return 1
      case .general: return 2
      case .noAccountStored: return 3
      case .noDeviceStored: return 4
      case .updateAccount: return 5
      case .updateDevice: return 6
      case .registerDevice: return 7
      case .requestZkNym: return 8
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _messageID: String? = nil
}

#if swift(>=4.2)

extension Nym_Vpn_ConnectRequestError.ConnectRequestErrorType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Nym_Vpn_ConnectRequestError.ConnectRequestErrorType] = [
    .unspecified,
    .internal,
    .general,
    .noAccountStored,
    .noDeviceStored,
    .updateAccount,
    .updateDevice,
    .registerDevice,
    .requestZkNym,
  ]
}

#endif  // swift(>=4.2)

struct Nym_Vpn_ConnectRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entry: Nym_Vpn_EntryNode {
    get {return _storage._entry ?? Nym_Vpn_EntryNode()}
    set {_uniqueStorage()._entry = newValue}
  }
  /// Returns true if `entry` has been explicitly set.
  var hasEntry: Bool {return _storage._entry != nil}
  /// Clears the value of `entry`. Subsequent reads from it will return its default value.
  mutating func clearEntry() {_uniqueStorage()._entry = nil}

  var exit: Nym_Vpn_ExitNode {
    get {return _storage._exit ?? Nym_Vpn_ExitNode()}
    set {_uniqueStorage()._exit = newValue}
  }
  /// Returns true if `exit` has been explicitly set.
  var hasExit: Bool {return _storage._exit != nil}
  /// Clears the value of `exit`. Subsequent reads from it will return its default value.
  mutating func clearExit() {_uniqueStorage()._exit = nil}

  var dns: Nym_Vpn_Dns {
    get {return _storage._dns ?? Nym_Vpn_Dns()}
    set {_uniqueStorage()._dns = newValue}
  }
  /// Returns true if `dns` has been explicitly set.
  var hasDns: Bool {return _storage._dns != nil}
  /// Clears the value of `dns`. Subsequent reads from it will return its default value.
  mutating func clearDns() {_uniqueStorage()._dns = nil}

  var disableRouting: Bool {
    get {return _storage._disableRouting}
    set {_uniqueStorage()._disableRouting = newValue}
  }

  var enableTwoHop: Bool {
    get {return _storage._enableTwoHop}
    set {_uniqueStorage()._enableTwoHop = newValue}
  }

  var netstack: Bool {
    get {return _storage._netstack}
    set {_uniqueStorage()._netstack = newValue}
  }

  var disablePoissonRate: Bool {
    get {return _storage._disablePoissonRate}
    set {_uniqueStorage()._disablePoissonRate = newValue}
  }

  var disableBackgroundCoverTraffic: Bool {
    get {return _storage._disableBackgroundCoverTraffic}
    set {_uniqueStorage()._disableBackgroundCoverTraffic = newValue}
  }

  var enableCredentialsMode: Bool {
    get {return _storage._enableCredentialsMode}
    set {_uniqueStorage()._enableCredentialsMode = newValue}
  }

  var userAgent: Nym_Vpn_UserAgent {
    get {return _storage._userAgent ?? Nym_Vpn_UserAgent()}
    set {_uniqueStorage()._userAgent = newValue}
  }
  /// Returns true if `userAgent` has been explicitly set.
  var hasUserAgent: Bool {return _storage._userAgent != nil}
  /// Clears the value of `userAgent`. Subsequent reads from it will return its default value.
  mutating func clearUserAgent() {_uniqueStorage()._userAgent = nil}

  /// Optional thresholds
  var minMixnodePerformance: Nym_Vpn_Threshold {
    get {return _storage._minMixnodePerformance ?? Nym_Vpn_Threshold()}
    set {_uniqueStorage()._minMixnodePerformance = newValue}
  }
  /// Returns true if `minMixnodePerformance` has been explicitly set.
  var hasMinMixnodePerformance: Bool {return _storage._minMixnodePerformance != nil}
  /// Clears the value of `minMixnodePerformance`. Subsequent reads from it will return its default value.
  mutating func clearMinMixnodePerformance() {_uniqueStorage()._minMixnodePerformance = nil}

  var minGatewayMixnetPerformance: Nym_Vpn_Threshold {
    get {return _storage._minGatewayMixnetPerformance ?? Nym_Vpn_Threshold()}
    set {_uniqueStorage()._minGatewayMixnetPerformance = newValue}
  }
  /// Returns true if `minGatewayMixnetPerformance` has been explicitly set.
  var hasMinGatewayMixnetPerformance: Bool {return _storage._minGatewayMixnetPerformance != nil}
  /// Clears the value of `minGatewayMixnetPerformance`. Subsequent reads from it will return its default value.
  mutating func clearMinGatewayMixnetPerformance() {_uniqueStorage()._minGatewayMixnetPerformance = nil}

  var minGatewayVpnPerformance: Nym_Vpn_Threshold {
    get {return _storage._minGatewayVpnPerformance ?? Nym_Vpn_Threshold()}
    set {_uniqueStorage()._minGatewayVpnPerformance = newValue}
  }
  /// Returns true if `minGatewayVpnPerformance` has been explicitly set.
  var hasMinGatewayVpnPerformance: Bool {return _storage._minGatewayVpnPerformance != nil}
  /// Clears the value of `minGatewayVpnPerformance`. Subsequent reads from it will return its default value.
  mutating func clearMinGatewayVpnPerformance() {_uniqueStorage()._minGatewayVpnPerformance = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Nym_Vpn_ConnectResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// TODO: consider simplifying by removing the bool
  var success: Bool = false

  var error: Nym_Vpn_ConnectRequestError {
    get {return _error ?? Nym_Vpn_ConnectRequestError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Nym_Vpn_ConnectRequestError? = nil
}

struct Nym_Vpn_DisconnectRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_DisconnectResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var success: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_ConnectionDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entryGateway: Nym_Vpn_Gateway {
    get {return _entryGateway ?? Nym_Vpn_Gateway()}
    set {_entryGateway = newValue}
  }
  /// Returns true if `entryGateway` has been explicitly set.
  var hasEntryGateway: Bool {return self._entryGateway != nil}
  /// Clears the value of `entryGateway`. Subsequent reads from it will return its default value.
  mutating func clearEntryGateway() {self._entryGateway = nil}

  var exitGateway: Nym_Vpn_Gateway {
    get {return _exitGateway ?? Nym_Vpn_Gateway()}
    set {_exitGateway = newValue}
  }
  /// Returns true if `exitGateway` has been explicitly set.
  var hasExitGateway: Bool {return self._exitGateway != nil}
  /// Clears the value of `exitGateway`. Subsequent reads from it will return its default value.
  mutating func clearExitGateway() {self._exitGateway = nil}

  var protocolDetails: Nym_Vpn_ConnectedStateDetails {
    get {return _protocolDetails ?? Nym_Vpn_ConnectedStateDetails()}
    set {_protocolDetails = newValue}
  }
  /// Returns true if `protocolDetails` has been explicitly set.
  var hasProtocolDetails: Bool {return self._protocolDetails != nil}
  /// Clears the value of `protocolDetails`. Subsequent reads from it will return its default value.
  mutating func clearProtocolDetails() {self._protocolDetails = nil}

  var since: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _since ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_since = newValue}
  }
  /// Returns true if `since` has been explicitly set.
  var hasSince: Bool {return self._since != nil}
  /// Clears the value of `since`. Subsequent reads from it will return its default value.
  mutating func clearSince() {self._since = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _entryGateway: Nym_Vpn_Gateway? = nil
  fileprivate var _exitGateway: Nym_Vpn_Gateway? = nil
  fileprivate var _protocolDetails: Nym_Vpn_ConnectedStateDetails? = nil
  fileprivate var _since: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Nym_Vpn_StatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_StatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Nym_Vpn_ConnectionStatus = .statusUnspecified

  var details: Nym_Vpn_ConnectionDetails {
    get {return _details ?? Nym_Vpn_ConnectionDetails()}
    set {_details = newValue}
  }
  /// Returns true if `details` has been explicitly set.
  var hasDetails: Bool {return self._details != nil}
  /// Clears the value of `details`. Subsequent reads from it will return its default value.
  mutating func clearDetails() {self._details = nil}

  var error: Nym_Vpn_Error {
    get {return _error ?? Nym_Vpn_Error()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _details: Nym_Vpn_ConnectionDetails? = nil
  fileprivate var _error: Nym_Vpn_Error? = nil
}

struct Nym_Vpn_ConnectionStateChange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Nym_Vpn_ConnectionStatus = .statusUnspecified

  var error: Nym_Vpn_Error {
    get {return _error ?? Nym_Vpn_Error()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Nym_Vpn_Error? = nil
}

struct Nym_Vpn_ConnectionStatusUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Nym_Vpn_ConnectionStatusUpdate.StatusType = .unspecified

  /// Detailed message for logging and debugging
  var message: String = String()

  /// Optional additional details
  var details: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum StatusType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unspecified // = 0

    /// Status message that is not mapped to a specific type
    case unknown // = 1

    /// Connection to entry gateway established
    /// NOTE: currently not implemented by vpnd
    case entryGatewayConnectionEstablished // = 2

    /// Connection to exit router established
    /// NOTE: currently not implemented by vpnd
    case exitRouterConnectionEstablished // = 3

    /// End-to-end tunnel established and operational
    case tunnelEndToEndConnectionEstablished // = 4

    /// Entry gateway not routing our mixnet messages
    case entryGatewayNotRoutingMixnetMessages // = 5

    /// The exit router is not responding to IPv4 traffic
    case exitRouterNotRespondingToIpv4Ping // = 6

    /// The exit router is not responding to IPv6 traffic
    case exitRouterNotRespondingToIpv6Ping // = 7

    /// The ip packet router connected to on the exit side is not routing IPv4 traffic
    case exitRouterNotRoutingIpv4Traffic // = 8

    /// The ip packet router connected to on the exit side is not routing IPv6 traffic
    case exitRouterNotRoutingIpv6Traffic // = 9

    /// The end-to-end IPv4 connection appears to be operation correctly
    case connectionOkIpv4 // = 10

    /// The end-to-end IPv6 connection appears to be operation correctly
    case connectionOkIpv6 // = 11

    /// Remaining bandwidth available
    case remainingBandwidth // = 12

    /// The user has run out of available bandwidth
    case noBandwidth // = 13

    /// Wireguard tunnel errors sent through the status channel. This error case
    /// will go away in the future.
    case wgTunnelError // = 14

    /// Event containing the statistics for the current mixnet connection.
    /// Includes real and cover packets send and received, retransmissions, acks
    /// received.
    case mixnetBandwidthRate // = 15
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .unknown
      case 2: self = .entryGatewayConnectionEstablished
      case 3: self = .exitRouterConnectionEstablished
      case 4: self = .tunnelEndToEndConnectionEstablished
      case 5: self = .entryGatewayNotRoutingMixnetMessages
      case 6: self = .exitRouterNotRespondingToIpv4Ping
      case 7: self = .exitRouterNotRespondingToIpv6Ping
      case 8: self = .exitRouterNotRoutingIpv4Traffic
      case 9: self = .exitRouterNotRoutingIpv6Traffic
      case 10: self = .connectionOkIpv4
      case 11: self = .connectionOkIpv6
      case 12: self = .remainingBandwidth
      case 13: self = .noBandwidth
      case 14: self = .wgTunnelError
      case 15: self = .mixnetBandwidthRate
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .unknown: return 1
      case .entryGatewayConnectionEstablished: return 2
      case .exitRouterConnectionEstablished: return 3
      case .tunnelEndToEndConnectionEstablished: return 4
      case .entryGatewayNotRoutingMixnetMessages: return 5
      case .exitRouterNotRespondingToIpv4Ping: return 6
      case .exitRouterNotRespondingToIpv6Ping: return 7
      case .exitRouterNotRoutingIpv4Traffic: return 8
      case .exitRouterNotRoutingIpv6Traffic: return 9
      case .connectionOkIpv4: return 10
      case .connectionOkIpv6: return 11
      case .remainingBandwidth: return 12
      case .noBandwidth: return 13
      case .wgTunnelError: return 14
      case .mixnetBandwidthRate: return 15
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Nym_Vpn_ConnectionStatusUpdate.StatusType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Nym_Vpn_ConnectionStatusUpdate.StatusType] = [
    .unspecified,
    .unknown,
    .entryGatewayConnectionEstablished,
    .exitRouterConnectionEstablished,
    .tunnelEndToEndConnectionEstablished,
    .entryGatewayNotRoutingMixnetMessages,
    .exitRouterNotRespondingToIpv4Ping,
    .exitRouterNotRespondingToIpv6Ping,
    .exitRouterNotRoutingIpv4Traffic,
    .exitRouterNotRoutingIpv6Traffic,
    .connectionOkIpv4,
    .connectionOkIpv6,
    .remainingBandwidth,
    .noBandwidth,
    .wgTunnelError,
    .mixnetBandwidthRate,
  ]
}

#endif  // swift(>=4.2)

/// TODO: consider rename this to something like `ConnectionError`, to
/// distinguish from all other types of errors.
struct Nym_Vpn_Error {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Nym_Vpn_Error.ErrorType = .unspecified

  /// Detailed error message for logging and debugging
  var message: String = String()

  /// Optional additional details
  var details: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ErrorType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unspecified // = 0

    /// An error that was not explicitly handled by the vpn service. This should
    /// not happen but it will while we iterate on mapping out all possible
    /// errors
    case unhandled // = 1

    /// The vpn exiting with an error that isn't handled by the automatic
    /// conversion. If this happens it's a bug.
    case unhandledExit // = 49

    /// An internal error that indicates a programmer error and should not
    /// happen. If it did an invariant was probably broken at some point.
    case `internal` // = 33

    /// If the credential storage does not contain any valid credentials when
    /// connecting
    case noValidCredentials // = 2

    /// Generic connection timeout. This could happen  in a number of contexts,
    /// and the provided details needs to be investigated to determine what went
    /// wrong
    case timeout // = 6

    /// Timeout starting the mixnet client
    case mixnetTimeout // = 7

    /// Failed to setup the mixnet storage paths
    case mixnetStoragePaths // = 19

    /// Failed to create a mixnet client with default storage setup
    case mixnetDefaultStorage // = 20

    /// Failed to build the mixnet client instance
    case mixnetBuildClient // = 21

    /// Failed to connect to the mixnet
    case mixnetConnect // = 22

    /// Failed to connect to the mixnet entry gateway
    case mixnetEntryGateway // = 23

    /// Failed to connect to the IPR
    case iprFailedToConnect // = 25

    /// Failed to connect to one of the authenticators
    case authenticatorFailedToConnect // = 34

    /// Failed to connect to the authenticator, timeout waiting for the connect
    /// response
    case authenticatorConnectTimeout // = 35

    /// Failed to connect to the authenticator, the response was invalid
    case authenticatorInvalidResponse // = 36

    /// Failed to verify the registration data provided by the authenticator
    case authenticatorRegistrationDataVerification // = 37

    /// Failed to parse the socket addr provided by the authenticator when
    /// setting up the wireguard configuration
    case authenticatorEntryGatewaySocketAddr // = 38

    /// Failed to parse the IPv4 provided by the authenticator when setting up
    /// the wireguard configuration
    case authenticatorEntryGatewayIpv4 // = 39

    /// The authenticator responded with a response tagged with a version we
    /// can't understand.
    case authenticatorWrongVersion // = 40

    /// The authenticator, or someone else, responded with a reply that we can't
    /// read.
    case authenticatorMalformedReply // = 41

    /// Not authenticator address found for the gateway(s) we're trying to use
    case authenticatorAddressNotFound // = 47

    /// Authentication with the authenticators was not possible, as we we don't
    /// have addresses for them. This is likely an internal programming error.
    case authenticatorAuthenticationNotPossible // = 48

    /// Looking up gateways can fail in a number of ways.
    case gatewayDirectory // = 8

    /// Failing to lookup gateways
    case gatewayDirectoryLookupGateways // = 9

    /// Failing to lookup gateway identity
    case gatewayDirectoryLookupGatewayIdentity // = 10

    /// Failing to lookup the IPR address
    case gatewayDirectoryLookupRouterAddress // = 11

    /// Failing to lookup the gateway IP
    case gatewayDirectoryLookupIp // = 12

    /// Failing to lookup the entry gateway
    case gatewayDirectoryEntry // = 13

    /// Entry gateway identity not found
    case gatewayDirectoryEntryID // = 24

    /// Failing to lookup the entry gateway for a given location
    case gatewayDirectoryEntryLocation // = 14

    /// Failing to lookup the exit gateway
    case gatewayDirectoryExit // = 15

    /// Failing to lookup the exit gateway for a given location
    case gatewayDirectoryExitLocation // = 16

    /// Invalid configuration attempted, with the same entry and exit gateway
    case gatewayDirectorySameEntryAndExitGw // = 17

    /// Client ran out of allocated bandwidth
    case outOfBandwidth // = 18

    /// The user has no available bandwidth to setup tunnel
    case outOfBandwidthWhenSettingUpTunnel // = 26

    /// Failed to bring up the wg interface up
    case bringInterfaceUp // = 27

    /// Failed to init firewall subsystem
    case firewallInit // = 28

    /// Failed to reset the firewall policy
    case firewallResetPolicy // = 29

    /// Failed to init the DNS subsystem
    case dnsInit // = 30

    /// Failed to set DNS
    case dnsSet // = 31

    /// Failed to find the default network interface
    case findDefaultInterface // = 32

    /// Failed to add ipv6 default route to capture ipv6 traffic
    case addIpv6Route // = 42

    /// General failure for the tun device
    case tun // = 43

    /// General failure for routing
    case routing // = 44

    /// General failure setting up the wireguard configuration
    case wireguardConfig // = 45

    /// General failure for the mixnet connection monitor
    case mixnetConnectionMonitor // = 46
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .unhandled
      case 2: self = .noValidCredentials
      case 6: self = .timeout
      case 7: self = .mixnetTimeout
      case 8: self = .gatewayDirectory
      case 9: self = .gatewayDirectoryLookupGateways
      case 10: self = .gatewayDirectoryLookupGatewayIdentity
      case 11: self = .gatewayDirectoryLookupRouterAddress
      case 12: self = .gatewayDirectoryLookupIp
      case 13: self = .gatewayDirectoryEntry
      case 14: self = .gatewayDirectoryEntryLocation
      case 15: self = .gatewayDirectoryExit
      case 16: self = .gatewayDirectoryExitLocation
      case 17: self = .gatewayDirectorySameEntryAndExitGw
      case 18: self = .outOfBandwidth
      case 19: self = .mixnetStoragePaths
      case 20: self = .mixnetDefaultStorage
      case 21: self = .mixnetBuildClient
      case 22: self = .mixnetConnect
      case 23: self = .mixnetEntryGateway
      case 24: self = .gatewayDirectoryEntryID
      case 25: self = .iprFailedToConnect
      case 26: self = .outOfBandwidthWhenSettingUpTunnel
      case 27: self = .bringInterfaceUp
      case 28: self = .firewallInit
      case 29: self = .firewallResetPolicy
      case 30: self = .dnsInit
      case 31: self = .dnsSet
      case 32: self = .findDefaultInterface
      case 33: self = .internal
      case 34: self = .authenticatorFailedToConnect
      case 35: self = .authenticatorConnectTimeout
      case 36: self = .authenticatorInvalidResponse
      case 37: self = .authenticatorRegistrationDataVerification
      case 38: self = .authenticatorEntryGatewaySocketAddr
      case 39: self = .authenticatorEntryGatewayIpv4
      case 40: self = .authenticatorWrongVersion
      case 41: self = .authenticatorMalformedReply
      case 42: self = .addIpv6Route
      case 43: self = .tun
      case 44: self = .routing
      case 45: self = .wireguardConfig
      case 46: self = .mixnetConnectionMonitor
      case 47: self = .authenticatorAddressNotFound
      case 48: self = .authenticatorAuthenticationNotPossible
      case 49: self = .unhandledExit
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .unhandled: return 1
      case .noValidCredentials: return 2
      case .timeout: return 6
      case .mixnetTimeout: return 7
      case .gatewayDirectory: return 8
      case .gatewayDirectoryLookupGateways: return 9
      case .gatewayDirectoryLookupGatewayIdentity: return 10
      case .gatewayDirectoryLookupRouterAddress: return 11
      case .gatewayDirectoryLookupIp: return 12
      case .gatewayDirectoryEntry: return 13
      case .gatewayDirectoryEntryLocation: return 14
      case .gatewayDirectoryExit: return 15
      case .gatewayDirectoryExitLocation: return 16
      case .gatewayDirectorySameEntryAndExitGw: return 17
      case .outOfBandwidth: return 18
      case .mixnetStoragePaths: return 19
      case .mixnetDefaultStorage: return 20
      case .mixnetBuildClient: return 21
      case .mixnetConnect: return 22
      case .mixnetEntryGateway: return 23
      case .gatewayDirectoryEntryID: return 24
      case .iprFailedToConnect: return 25
      case .outOfBandwidthWhenSettingUpTunnel: return 26
      case .bringInterfaceUp: return 27
      case .firewallInit: return 28
      case .firewallResetPolicy: return 29
      case .dnsInit: return 30
      case .dnsSet: return 31
      case .findDefaultInterface: return 32
      case .internal: return 33
      case .authenticatorFailedToConnect: return 34
      case .authenticatorConnectTimeout: return 35
      case .authenticatorInvalidResponse: return 36
      case .authenticatorRegistrationDataVerification: return 37
      case .authenticatorEntryGatewaySocketAddr: return 38
      case .authenticatorEntryGatewayIpv4: return 39
      case .authenticatorWrongVersion: return 40
      case .authenticatorMalformedReply: return 41
      case .addIpv6Route: return 42
      case .tun: return 43
      case .routing: return 44
      case .wireguardConfig: return 45
      case .mixnetConnectionMonitor: return 46
      case .authenticatorAddressNotFound: return 47
      case .authenticatorAuthenticationNotPossible: return 48
      case .unhandledExit: return 49
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Nym_Vpn_Error.ErrorType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Nym_Vpn_Error.ErrorType] = [
    .unspecified,
    .unhandled,
    .unhandledExit,
    .internal,
    .noValidCredentials,
    .timeout,
    .mixnetTimeout,
    .mixnetStoragePaths,
    .mixnetDefaultStorage,
    .mixnetBuildClient,
    .mixnetConnect,
    .mixnetEntryGateway,
    .iprFailedToConnect,
    .authenticatorFailedToConnect,
    .authenticatorConnectTimeout,
    .authenticatorInvalidResponse,
    .authenticatorRegistrationDataVerification,
    .authenticatorEntryGatewaySocketAddr,
    .authenticatorEntryGatewayIpv4,
    .authenticatorWrongVersion,
    .authenticatorMalformedReply,
    .authenticatorAddressNotFound,
    .authenticatorAuthenticationNotPossible,
    .gatewayDirectory,
    .gatewayDirectoryLookupGateways,
    .gatewayDirectoryLookupGatewayIdentity,
    .gatewayDirectoryLookupRouterAddress,
    .gatewayDirectoryLookupIp,
    .gatewayDirectoryEntry,
    .gatewayDirectoryEntryID,
    .gatewayDirectoryEntryLocation,
    .gatewayDirectoryExit,
    .gatewayDirectoryExitLocation,
    .gatewayDirectorySameEntryAndExitGw,
    .outOfBandwidth,
    .outOfBandwidthWhenSettingUpTunnel,
    .bringInterfaceUp,
    .firewallInit,
    .firewallResetPolicy,
    .dnsInit,
    .dnsSet,
    .findDefaultInterface,
    .addIpv6Route,
    .tun,
    .routing,
    .wireguardConfig,
    .mixnetConnectionMonitor,
  ]
}

#endif  // swift(>=4.2)

struct Nym_Vpn_AsEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var canConnect: Bool = false

  var canRoute: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_AsExit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var canConnect: Bool = false

  var canRouteIpV4: Bool = false

  var canRouteIpV6: Bool = false

  var canRouteIpExternalV4: Bool = false

  var canRouteIpExternalV6: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_WgProbeResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var canRegister: Bool = false

  var canHandshake: Bool = false

  var canResolveDns: Bool = false

  var pingHostsPerformance: Float = 0

  var pingIpsPerformance: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_ProbeOutcome {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var asEntry: Nym_Vpn_AsEntry {
    get {return _asEntry ?? Nym_Vpn_AsEntry()}
    set {_asEntry = newValue}
  }
  /// Returns true if `asEntry` has been explicitly set.
  var hasAsEntry: Bool {return self._asEntry != nil}
  /// Clears the value of `asEntry`. Subsequent reads from it will return its default value.
  mutating func clearAsEntry() {self._asEntry = nil}

  var asExit: Nym_Vpn_AsExit {
    get {return _asExit ?? Nym_Vpn_AsExit()}
    set {_asExit = newValue}
  }
  /// Returns true if `asExit` has been explicitly set.
  var hasAsExit: Bool {return self._asExit != nil}
  /// Clears the value of `asExit`. Subsequent reads from it will return its default value.
  mutating func clearAsExit() {self._asExit = nil}

  var wg: Nym_Vpn_WgProbeResult {
    get {return _wg ?? Nym_Vpn_WgProbeResult()}
    set {_wg = newValue}
  }
  /// Returns true if `wg` has been explicitly set.
  var hasWg: Bool {return self._wg != nil}
  /// Clears the value of `wg`. Subsequent reads from it will return its default value.
  mutating func clearWg() {self._wg = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _asEntry: Nym_Vpn_AsEntry? = nil
  fileprivate var _asExit: Nym_Vpn_AsExit? = nil
  fileprivate var _wg: Nym_Vpn_WgProbeResult? = nil
}

struct Nym_Vpn_Probe {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lastUpdatedUtc: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastUpdatedUtc ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastUpdatedUtc = newValue}
  }
  /// Returns true if `lastUpdatedUtc` has been explicitly set.
  var hasLastUpdatedUtc: Bool {return self._lastUpdatedUtc != nil}
  /// Clears the value of `lastUpdatedUtc`. Subsequent reads from it will return its default value.
  mutating func clearLastUpdatedUtc() {self._lastUpdatedUtc = nil}

  var outcome: Nym_Vpn_ProbeOutcome {
    get {return _outcome ?? Nym_Vpn_ProbeOutcome()}
    set {_outcome = newValue}
  }
  /// Returns true if `outcome` has been explicitly set.
  var hasOutcome: Bool {return self._outcome != nil}
  /// Clears the value of `outcome`. Subsequent reads from it will return its default value.
  mutating func clearOutcome() {self._outcome = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _lastUpdatedUtc: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _outcome: Nym_Vpn_ProbeOutcome? = nil
}

struct Nym_Vpn_GatewayResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Nym_Vpn_Gateway {
    get {return _storage._id ?? Nym_Vpn_Gateway()}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return _storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {_uniqueStorage()._id = nil}

  var location: Nym_Vpn_Location {
    get {return _storage._location ?? Nym_Vpn_Location()}
    set {_uniqueStorage()._location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  var hasLocation: Bool {return _storage._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  mutating func clearLocation() {_uniqueStorage()._location = nil}

  var lastProbe: Nym_Vpn_Probe {
    get {return _storage._lastProbe ?? Nym_Vpn_Probe()}
    set {_uniqueStorage()._lastProbe = newValue}
  }
  /// Returns true if `lastProbe` has been explicitly set.
  var hasLastProbe: Bool {return _storage._lastProbe != nil}
  /// Clears the value of `lastProbe`. Subsequent reads from it will return its default value.
  mutating func clearLastProbe() {_uniqueStorage()._lastProbe = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Nym_Vpn_ListGatewaysRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Nym_Vpn_GatewayType = .unspecified

  var userAgent: Nym_Vpn_UserAgent {
    get {return _userAgent ?? Nym_Vpn_UserAgent()}
    set {_userAgent = newValue}
  }
  /// Returns true if `userAgent` has been explicitly set.
  var hasUserAgent: Bool {return self._userAgent != nil}
  /// Clears the value of `userAgent`. Subsequent reads from it will return its default value.
  mutating func clearUserAgent() {self._userAgent = nil}

  /// Optional thresholds
  var minMixnetPerformance: Nym_Vpn_Threshold {
    get {return _minMixnetPerformance ?? Nym_Vpn_Threshold()}
    set {_minMixnetPerformance = newValue}
  }
  /// Returns true if `minMixnetPerformance` has been explicitly set.
  var hasMinMixnetPerformance: Bool {return self._minMixnetPerformance != nil}
  /// Clears the value of `minMixnetPerformance`. Subsequent reads from it will return its default value.
  mutating func clearMinMixnetPerformance() {self._minMixnetPerformance = nil}

  var minVpnPerformance: Nym_Vpn_Threshold {
    get {return _minVpnPerformance ?? Nym_Vpn_Threshold()}
    set {_minVpnPerformance = newValue}
  }
  /// Returns true if `minVpnPerformance` has been explicitly set.
  var hasMinVpnPerformance: Bool {return self._minVpnPerformance != nil}
  /// Clears the value of `minVpnPerformance`. Subsequent reads from it will return its default value.
  mutating func clearMinVpnPerformance() {self._minVpnPerformance = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _userAgent: Nym_Vpn_UserAgent? = nil
  fileprivate var _minMixnetPerformance: Nym_Vpn_Threshold? = nil
  fileprivate var _minVpnPerformance: Nym_Vpn_Threshold? = nil
}

struct Nym_Vpn_ListGatewaysResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gateways: [Nym_Vpn_GatewayResponse] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_ListCountriesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Nym_Vpn_GatewayType = .unspecified

  var userAgent: Nym_Vpn_UserAgent {
    get {return _userAgent ?? Nym_Vpn_UserAgent()}
    set {_userAgent = newValue}
  }
  /// Returns true if `userAgent` has been explicitly set.
  var hasUserAgent: Bool {return self._userAgent != nil}
  /// Clears the value of `userAgent`. Subsequent reads from it will return its default value.
  mutating func clearUserAgent() {self._userAgent = nil}

  /// Optional thresholds
  var minMixnetPerformance: Nym_Vpn_Threshold {
    get {return _minMixnetPerformance ?? Nym_Vpn_Threshold()}
    set {_minMixnetPerformance = newValue}
  }
  /// Returns true if `minMixnetPerformance` has been explicitly set.
  var hasMinMixnetPerformance: Bool {return self._minMixnetPerformance != nil}
  /// Clears the value of `minMixnetPerformance`. Subsequent reads from it will return its default value.
  mutating func clearMinMixnetPerformance() {self._minMixnetPerformance = nil}

  var minVpnPerformance: Nym_Vpn_Threshold {
    get {return _minVpnPerformance ?? Nym_Vpn_Threshold()}
    set {_minVpnPerformance = newValue}
  }
  /// Returns true if `minVpnPerformance` has been explicitly set.
  var hasMinVpnPerformance: Bool {return self._minVpnPerformance != nil}
  /// Clears the value of `minVpnPerformance`. Subsequent reads from it will return its default value.
  mutating func clearMinVpnPerformance() {self._minVpnPerformance = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _userAgent: Nym_Vpn_UserAgent? = nil
  fileprivate var _minMixnetPerformance: Nym_Vpn_Threshold? = nil
  fileprivate var _minVpnPerformance: Nym_Vpn_Threshold? = nil
}

struct Nym_Vpn_ListCountriesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var countries: [Nym_Vpn_Location] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_StoreAccountRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mnemonic: String = String()

  var nonce: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_StoreAccountResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var success: Bool = false

  var error: Nym_Vpn_AccountError {
    get {return _error ?? Nym_Vpn_AccountError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Nym_Vpn_AccountError? = nil
}

struct Nym_Vpn_IsAccountStoredRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_IsAccountStoredResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var resp: Nym_Vpn_IsAccountStoredResponse.OneOf_Resp? = nil

  var isStored: Bool {
    get {
      if case .isStored(let v)? = resp {return v}
      return false
    }
    set {resp = .isStored(newValue)}
  }

  var error: Nym_Vpn_AccountError {
    get {
      if case .error(let v)? = resp {return v}
      return Nym_Vpn_AccountError()
    }
    set {resp = .error(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Resp: Equatable {
    case isStored(Bool)
    case error(Nym_Vpn_AccountError)

  #if !swift(>=4.1)
    static func ==(lhs: Nym_Vpn_IsAccountStoredResponse.OneOf_Resp, rhs: Nym_Vpn_IsAccountStoredResponse.OneOf_Resp) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.isStored, .isStored): return {
        guard case .isStored(let l) = lhs, case .isStored(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Nym_Vpn_RemoveAccountRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_RemoveAccountResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var success: Bool = false

  var error: Nym_Vpn_AccountError {
    get {return _error ?? Nym_Vpn_AccountError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Nym_Vpn_AccountError? = nil
}

struct Nym_Vpn_ForgetAccountRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_ForgetAccountResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var success: Bool = false

  var error: Nym_Vpn_AccountError {
    get {return _error ?? Nym_Vpn_AccountError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Nym_Vpn_AccountError? = nil
}

struct Nym_Vpn_GetAccountIdentityRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_GetAccountIdentityResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Nym_Vpn_GetAccountIdentityResponse.OneOf_ID? = nil

  var accountIdentity: String {
    get {
      if case .accountIdentity(let v)? = id {return v}
      return String()
    }
    set {id = .accountIdentity(newValue)}
  }

  var error: Nym_Vpn_AccountError {
    get {
      if case .error(let v)? = id {return v}
      return Nym_Vpn_AccountError()
    }
    set {id = .error(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ID: Equatable {
    case accountIdentity(String)
    case error(Nym_Vpn_AccountError)

  #if !swift(>=4.1)
    static func ==(lhs: Nym_Vpn_GetAccountIdentityResponse.OneOf_ID, rhs: Nym_Vpn_GetAccountIdentityResponse.OneOf_ID) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.accountIdentity, .accountIdentity): return {
        guard case .accountIdentity(let l) = lhs, case .accountIdentity(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Nym_Vpn_GetAccountLinksRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var locale: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_GetAccountLinksResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var res: Nym_Vpn_GetAccountLinksResponse.OneOf_Res? = nil

  var links: Nym_Vpn_AccountManagement {
    get {
      if case .links(let v)? = res {return v}
      return Nym_Vpn_AccountManagement()
    }
    set {res = .links(newValue)}
  }

  var error: Nym_Vpn_AccountError {
    get {
      if case .error(let v)? = res {return v}
      return Nym_Vpn_AccountError()
    }
    set {res = .error(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Res: Equatable {
    case links(Nym_Vpn_AccountManagement)
    case error(Nym_Vpn_AccountError)

  #if !swift(>=4.1)
    static func ==(lhs: Nym_Vpn_GetAccountLinksResponse.OneOf_Res, rhs: Nym_Vpn_GetAccountLinksResponse.OneOf_Res) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.links, .links): return {
        guard case .links(let l) = lhs, case .links(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Nym_Vpn_DeviceSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var active: UInt64 = 0

  var max: UInt64 = 0

  var remaining: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_AccountSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var account: Nym_Vpn_AccountState = .unspecified

  var subscription: Nym_Vpn_SubscriptionState = .unspecified

  var deviceSummary: Nym_Vpn_DeviceSummary {
    get {return _deviceSummary ?? Nym_Vpn_DeviceSummary()}
    set {_deviceSummary = newValue}
  }
  /// Returns true if `deviceSummary` has been explicitly set.
  var hasDeviceSummary: Bool {return self._deviceSummary != nil}
  /// Clears the value of `deviceSummary`. Subsequent reads from it will return its default value.
  mutating func clearDeviceSummary() {self._deviceSummary = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _deviceSummary: Nym_Vpn_DeviceSummary? = nil
}

struct Nym_Vpn_RegisterDeviceResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Nym_Vpn_RegisterDeviceResult.RegisterDeviceResultType = .registerDeviceResultUnspecified

  var message: String {
    get {return _message ?? String()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {self._message = nil}

  var messageID: String {
    get {return _messageID ?? String()}
    set {_messageID = newValue}
  }
  /// Returns true if `messageID` has been explicitly set.
  var hasMessageID: Bool {return self._messageID != nil}
  /// Clears the value of `messageID`. Subsequent reads from it will return its default value.
  mutating func clearMessageID() {self._messageID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum RegisterDeviceResultType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case registerDeviceResultUnspecified // = 0
    case inProgress // = 1
    case success // = 2
    case failed // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .registerDeviceResultUnspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .registerDeviceResultUnspecified
      case 1: self = .inProgress
      case 2: self = .success
      case 3: self = .failed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .registerDeviceResultUnspecified: return 0
      case .inProgress: return 1
      case .success: return 2
      case .failed: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _message: String? = nil
  fileprivate var _messageID: String? = nil
}

#if swift(>=4.2)

extension Nym_Vpn_RegisterDeviceResult.RegisterDeviceResultType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Nym_Vpn_RegisterDeviceResult.RegisterDeviceResultType] = [
    .registerDeviceResultUnspecified,
    .inProgress,
    .success,
    .failed,
  ]
}

#endif  // swift(>=4.2)

/// The status of a zk-nym request. A request can have multiple successes
/// and failures, depending on how many ticket types were requested.
struct Nym_Vpn_RequestZkNymResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Nym_Vpn_RequestZkNymResult.RequestZkNymResultType = .requestZkNymResultUnspecified

  var successes: [Nym_Vpn_RequestZkNymSuccess] = []

  var failures: [Nym_Vpn_RequestZkNymError] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum RequestZkNymResultType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case requestZkNymResultUnspecified // = 0
    case inProgress // = 1
    case success // = 2
    case failed // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .requestZkNymResultUnspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .requestZkNymResultUnspecified
      case 1: self = .inProgress
      case 2: self = .success
      case 3: self = .failed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .requestZkNymResultUnspecified: return 0
      case .inProgress: return 1
      case .success: return 2
      case .failed: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Nym_Vpn_RequestZkNymResult.RequestZkNymResultType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Nym_Vpn_RequestZkNymResult.RequestZkNymResultType] = [
    .requestZkNymResultUnspecified,
    .inProgress,
    .success,
    .failed,
  ]
}

#endif  // swift(>=4.2)

struct Nym_Vpn_RequestZkNymSuccess {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_RequestZkNymError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Nym_Vpn_RequestZkNymError.RequestZkNymErrorType = .unspecified

  var id: String {
    get {return _id ?? String()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var ticketbookType: String {
    get {return _ticketbookType ?? String()}
    set {_ticketbookType = newValue}
  }
  /// Returns true if `ticketbookType` has been explicitly set.
  var hasTicketbookType: Bool {return self._ticketbookType != nil}
  /// Clears the value of `ticketbookType`. Subsequent reads from it will return its default value.
  mutating func clearTicketbookType() {self._ticketbookType = nil}

  var message: String {
    get {return _message ?? String()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {self._message = nil}

  var messageID: String {
    get {return _messageID ?? String()}
    set {_messageID = newValue}
  }
  /// Returns true if `messageID` has been explicitly set.
  var hasMessageID: Bool {return self._messageID != nil}
  /// Clears the value of `messageID`. Subsequent reads from it will return its default value.
  mutating func clearMessageID() {self._messageID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum RequestZkNymErrorType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unspecified // = 0

    /// Unspecified internal error
    case `internal` // = 1

    /// General error
    case general // = 2

    /// Error returned from the nym-vpn-api endpoint
    case requestZkNymEndpointFailure // = 3

    /// Error returned from the nym-vpn-api polling endpoint
    case pollZkNymEndpointFailure // = 4

    /// The task polling for the result failed
    case pollingTaskError // = 5

    /// Timeout polling for the result
    case pollingTimeout // = 6

    /// Request finished correctly, but the nym-vpn-api returned an error
    /// with the result.
    case finishedWithError // = 7

    /// Failed to import the ticketbook into local storage
    case `import` // = 8
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .internal
      case 2: self = .general
      case 3: self = .requestZkNymEndpointFailure
      case 4: self = .pollZkNymEndpointFailure
      case 5: self = .pollingTaskError
      case 6: self = .pollingTimeout
      case 7: self = .finishedWithError
      case 8: self = .import
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .internal: return 1
      case .general: return 2
      case .requestZkNymEndpointFailure: return 3
      case .pollZkNymEndpointFailure: return 4
      case .pollingTaskError: return 5
      case .pollingTimeout: return 6
      case .finishedWithError: return 7
      case .import: return 8
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _id: String? = nil
  fileprivate var _ticketbookType: String? = nil
  fileprivate var _message: String? = nil
  fileprivate var _messageID: String? = nil
}

#if swift(>=4.2)

extension Nym_Vpn_RequestZkNymError.RequestZkNymErrorType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Nym_Vpn_RequestZkNymError.RequestZkNymErrorType] = [
    .unspecified,
    .internal,
    .general,
    .requestZkNymEndpointFailure,
    .pollZkNymEndpointFailure,
    .pollingTaskError,
    .pollingTimeout,
    .finishedWithError,
    .import,
  ]
}

#endif  // swift(>=4.2)

struct Nym_Vpn_AccountStateSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mnemonic: Nym_Vpn_MnemonicState {
    get {return _mnemonic ?? .unspecified}
    set {_mnemonic = newValue}
  }
  /// Returns true if `mnemonic` has been explicitly set.
  var hasMnemonic: Bool {return self._mnemonic != nil}
  /// Clears the value of `mnemonic`. Subsequent reads from it will return its default value.
  mutating func clearMnemonic() {self._mnemonic = nil}

  var accountRegistered: Nym_Vpn_AccountRegistered {
    get {return _accountRegistered ?? .unspecified}
    set {_accountRegistered = newValue}
  }
  /// Returns true if `accountRegistered` has been explicitly set.
  var hasAccountRegistered: Bool {return self._accountRegistered != nil}
  /// Clears the value of `accountRegistered`. Subsequent reads from it will return its default value.
  mutating func clearAccountRegistered() {self._accountRegistered = nil}

  var accountSummary: Nym_Vpn_AccountSummary {
    get {return _accountSummary ?? Nym_Vpn_AccountSummary()}
    set {_accountSummary = newValue}
  }
  /// Returns true if `accountSummary` has been explicitly set.
  var hasAccountSummary: Bool {return self._accountSummary != nil}
  /// Clears the value of `accountSummary`. Subsequent reads from it will return its default value.
  mutating func clearAccountSummary() {self._accountSummary = nil}

  var device: Nym_Vpn_DeviceState {
    get {return _device ?? .unspecified}
    set {_device = newValue}
  }
  /// Returns true if `device` has been explicitly set.
  var hasDevice: Bool {return self._device != nil}
  /// Clears the value of `device`. Subsequent reads from it will return its default value.
  mutating func clearDevice() {self._device = nil}

  var registerDeviceResult: Nym_Vpn_RegisterDeviceResult {
    get {return _registerDeviceResult ?? Nym_Vpn_RegisterDeviceResult()}
    set {_registerDeviceResult = newValue}
  }
  /// Returns true if `registerDeviceResult` has been explicitly set.
  var hasRegisterDeviceResult: Bool {return self._registerDeviceResult != nil}
  /// Clears the value of `registerDeviceResult`. Subsequent reads from it will return its default value.
  mutating func clearRegisterDeviceResult() {self._registerDeviceResult = nil}

  /// NOTE: don't reuse tag 6
  /// bool pending_zk_nym = 6;
  var requestZkNymResult: Nym_Vpn_RequestZkNymResult {
    get {return _requestZkNymResult ?? Nym_Vpn_RequestZkNymResult()}
    set {_requestZkNymResult = newValue}
  }
  /// Returns true if `requestZkNymResult` has been explicitly set.
  var hasRequestZkNymResult: Bool {return self._requestZkNymResult != nil}
  /// Clears the value of `requestZkNymResult`. Subsequent reads from it will return its default value.
  mutating func clearRequestZkNymResult() {self._requestZkNymResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mnemonic: Nym_Vpn_MnemonicState? = nil
  fileprivate var _accountRegistered: Nym_Vpn_AccountRegistered? = nil
  fileprivate var _accountSummary: Nym_Vpn_AccountSummary? = nil
  fileprivate var _device: Nym_Vpn_DeviceState? = nil
  fileprivate var _registerDeviceResult: Nym_Vpn_RegisterDeviceResult? = nil
  fileprivate var _requestZkNymResult: Nym_Vpn_RequestZkNymResult? = nil
}

struct Nym_Vpn_GetAccountStateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_GetAccountStateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: Nym_Vpn_GetAccountStateResponse.OneOf_Result? = nil

  var account: Nym_Vpn_AccountStateSummary {
    get {
      if case .account(let v)? = result {return v}
      return Nym_Vpn_AccountStateSummary()
    }
    set {result = .account(newValue)}
  }

  var error: Nym_Vpn_AccountError {
    get {
      if case .error(let v)? = result {return v}
      return Nym_Vpn_AccountError()
    }
    set {result = .error(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Result: Equatable {
    case account(Nym_Vpn_AccountStateSummary)
    case error(Nym_Vpn_AccountError)

  #if !swift(>=4.1)
    static func ==(lhs: Nym_Vpn_GetAccountStateResponse.OneOf_Result, rhs: Nym_Vpn_GetAccountStateResponse.OneOf_Result) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.account, .account): return {
        guard case .account(let l) = lhs, case .account(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Nym_Vpn_RefreshAccountStateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_RefreshAccountStateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_AccountUsages {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accountUsages: [Nym_Vpn_AccountUsage] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_AccountUsage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var createdOnUtc: String = String()

  var lastUpdatedUtc: String = String()

  var id: String = String()

  var subscriptionID: String = String()

  var validUntilUtc: String = String()

  var validFromUtc: String = String()

  var bandwidthAllowanceGb: Double = 0

  var bandwidthUsedGb: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_GetAccountUsageRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_GetAccountUsageResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: Nym_Vpn_GetAccountUsageResponse.OneOf_Result? = nil

  var accountUsages: Nym_Vpn_AccountUsages {
    get {
      if case .accountUsages(let v)? = result {return v}
      return Nym_Vpn_AccountUsages()
    }
    set {result = .accountUsages(newValue)}
  }

  var error: Nym_Vpn_AccountError {
    get {
      if case .error(let v)? = result {return v}
      return Nym_Vpn_AccountError()
    }
    set {result = .error(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Result: Equatable {
    case accountUsages(Nym_Vpn_AccountUsages)
    case error(Nym_Vpn_AccountError)

  #if !swift(>=4.1)
    static func ==(lhs: Nym_Vpn_GetAccountUsageResponse.OneOf_Result, rhs: Nym_Vpn_GetAccountUsageResponse.OneOf_Result) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.accountUsages, .accountUsages): return {
        guard case .accountUsages(let l) = lhs, case .accountUsages(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Nym_Vpn_FetchRawAccountSummaryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_FetchRawAccountSummaryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var json: String = String()

  var error: Nym_Vpn_AccountError {
    get {return _error ?? Nym_Vpn_AccountError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Nym_Vpn_AccountError? = nil
}

struct Nym_Vpn_FetchRawDevicesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_FetchRawDevicesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var json: String = String()

  var error: Nym_Vpn_AccountError {
    get {return _error ?? Nym_Vpn_AccountError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Nym_Vpn_AccountError? = nil
}

struct Nym_Vpn_ResetDeviceIdentityRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 32 byte seed, [u8; 32]
  var seed: Data {
    get {return _seed ?? Data()}
    set {_seed = newValue}
  }
  /// Returns true if `seed` has been explicitly set.
  var hasSeed: Bool {return self._seed != nil}
  /// Clears the value of `seed`. Subsequent reads from it will return its default value.
  mutating func clearSeed() {self._seed = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _seed: Data? = nil
}

struct Nym_Vpn_ResetDeviceIdentityResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var success: Bool = false

  var error: Nym_Vpn_AccountError {
    get {return _error ?? Nym_Vpn_AccountError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Nym_Vpn_AccountError? = nil
}

struct Nym_Vpn_GetDeviceIdentityRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_GetDeviceIdentityResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Nym_Vpn_GetDeviceIdentityResponse.OneOf_ID? = nil

  var deviceIdentity: String {
    get {
      if case .deviceIdentity(let v)? = id {return v}
      return String()
    }
    set {id = .deviceIdentity(newValue)}
  }

  var error: Nym_Vpn_AccountError {
    get {
      if case .error(let v)? = id {return v}
      return Nym_Vpn_AccountError()
    }
    set {id = .error(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ID: Equatable {
    case deviceIdentity(String)
    case error(Nym_Vpn_AccountError)

  #if !swift(>=4.1)
    static func ==(lhs: Nym_Vpn_GetDeviceIdentityResponse.OneOf_ID, rhs: Nym_Vpn_GetDeviceIdentityResponse.OneOf_ID) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.deviceIdentity, .deviceIdentity): return {
        guard case .deviceIdentity(let l) = lhs, case .deviceIdentity(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Nym_Vpn_RegisterDeviceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_RegisterDeviceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var json: String = String()

  var error: Nym_Vpn_AccountError {
    get {return _error ?? Nym_Vpn_AccountError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Nym_Vpn_AccountError? = nil
}

struct Nym_Vpn_Device {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var createdOnUtc: String = String()

  var lastUpdatedUtc: String = String()

  var deviceIdentityKey: String = String()

  var status: Nym_Vpn_DeviceStatus = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_Devices {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var devices: [Nym_Vpn_Device] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_GetDevicesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_GetDevicesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: Nym_Vpn_GetDevicesResponse.OneOf_Result? = nil

  var devices: Nym_Vpn_Devices {
    get {
      if case .devices(let v)? = result {return v}
      return Nym_Vpn_Devices()
    }
    set {result = .devices(newValue)}
  }

  var error: Nym_Vpn_AccountError {
    get {
      if case .error(let v)? = result {return v}
      return Nym_Vpn_AccountError()
    }
    set {result = .error(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Result: Equatable {
    case devices(Nym_Vpn_Devices)
    case error(Nym_Vpn_AccountError)

  #if !swift(>=4.1)
    static func ==(lhs: Nym_Vpn_GetDevicesResponse.OneOf_Result, rhs: Nym_Vpn_GetDevicesResponse.OneOf_Result) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.devices, .devices): return {
        guard case .devices(let l) = lhs, case .devices(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Nym_Vpn_GetActiveDevicesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_GetActiveDevicesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: Nym_Vpn_GetActiveDevicesResponse.OneOf_Result? = nil

  var devices: Nym_Vpn_Devices {
    get {
      if case .devices(let v)? = result {return v}
      return Nym_Vpn_Devices()
    }
    set {result = .devices(newValue)}
  }

  var error: Nym_Vpn_AccountError {
    get {
      if case .error(let v)? = result {return v}
      return Nym_Vpn_AccountError()
    }
    set {result = .error(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Result: Equatable {
    case devices(Nym_Vpn_Devices)
    case error(Nym_Vpn_AccountError)

  #if !swift(>=4.1)
    static func ==(lhs: Nym_Vpn_GetActiveDevicesResponse.OneOf_Result, rhs: Nym_Vpn_GetActiveDevicesResponse.OneOf_Result) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.devices, .devices): return {
        guard case .devices(let l) = lhs, case .devices(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Nym_Vpn_RequestZkNymRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_RequestZkNymResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var json: String = String()

  var error: Nym_Vpn_AccountError {
    get {return _error ?? Nym_Vpn_AccountError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Nym_Vpn_AccountError? = nil
}

struct Nym_Vpn_GetDeviceZkNymsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_GetDeviceZkNymsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var json: String = String()

  var error: Nym_Vpn_AccountError {
    get {return _error ?? Nym_Vpn_AccountError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Nym_Vpn_AccountError? = nil
}

struct Nym_Vpn_GetZkNymsAvailableForDownloadRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_GetZkNymsAvailableForDownloadResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var json: String = String()

  var error: Nym_Vpn_AccountError {
    get {return _error ?? Nym_Vpn_AccountError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Nym_Vpn_AccountError? = nil
}

struct Nym_Vpn_GetZkNymByIdRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_GetZkNymByIdResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var json: String = String()

  var error: Nym_Vpn_AccountError {
    get {return _error ?? Nym_Vpn_AccountError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Nym_Vpn_AccountError? = nil
}

struct Nym_Vpn_ConfirmZkNymDownloadedRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_ConfirmZkNymDownloadedResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var error: Nym_Vpn_AccountError {
    get {return _error ?? Nym_Vpn_AccountError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Nym_Vpn_AccountError? = nil
}

struct Nym_Vpn_AvailableTickets {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Remaining number of mixnet entry tickets
  var mixnetEntryTickets: UInt64 = 0

  /// Remaining mixnet entry data in bytes
  var mixnetEntryData: UInt64 = 0

  /// Remaining mixnet entry data formatted to a string using SI units
  var mixnetEntryDataSi: String = String()

  /// Remaining number of mixnet exit tickets
  var mixnetExitTickets: UInt64 = 0

  /// Remaining mixnet exit data in bytes
  var mixnetExitData: UInt64 = 0

  /// Remaining mixnet exit data formatted to a string using SI units
  var mixnetExitDataSi: String = String()

  /// Remaining number of vpn entry tickets
  var vpnEntryTickets: UInt64 = 0

  /// Remaining vpn entry data in bytes
  var vpnEntryData: UInt64 = 0

  /// Remaining vpn entry data formatted to a string using SI units
  var vpnEntryDataSi: String = String()

  /// Remaining number of vpn exit tickets
  var vpnExitTickets: UInt64 = 0

  /// Remaining vpn exit data in bytes
  var vpnExitData: UInt64 = 0

  /// Remaining vpn exit data formatted to a string using SI units
  var vpnExitDataSi: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_GetAvailableTicketsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_GetAvailableTicketsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var resp: Nym_Vpn_GetAvailableTicketsResponse.OneOf_Resp? = nil

  var availableTickets: Nym_Vpn_AvailableTickets {
    get {
      if case .availableTickets(let v)? = resp {return v}
      return Nym_Vpn_AvailableTickets()
    }
    set {resp = .availableTickets(newValue)}
  }

  var error: Nym_Vpn_AccountError {
    get {
      if case .error(let v)? = resp {return v}
      return Nym_Vpn_AccountError()
    }
    set {resp = .error(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Resp: Equatable {
    case availableTickets(Nym_Vpn_AvailableTickets)
    case error(Nym_Vpn_AccountError)

  #if !swift(>=4.1)
    static func ==(lhs: Nym_Vpn_GetAvailableTicketsResponse.OneOf_Resp, rhs: Nym_Vpn_GetAvailableTicketsResponse.OneOf_Resp) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.availableTickets, .availableTickets): return {
        guard case .availableTickets(let l) = lhs, case .availableTickets(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Nym_Vpn_IsReadyToConnectRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_IsReadyToConnectResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Nym_Vpn_IsReadyToConnectResponse.IsReadyToConnectResponseType = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum IsReadyToConnectResponseType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unspecified // = 0

    /// We are ready to attempt to connect
    case ready // = 1

    /// No account recovery phrase stored
    case noAccountStored // = 2

    /// The account is not synced
    case accountNotSynced // = 3

    /// The account is not registered
    case accountNotRegistered // = 4

    /// The account is not active
    case accountNotActive // = 5

    /// The account does not have an active subscription
    case noActiveSubscription // = 6

    /// The device is not registered
    case deviceNotRegistered // = 7

    /// The device is not active
    /// NOTE: in the future we will try to re-active an inactive device on
    /// connect
    case deviceNotActive // = 8

    /// The device has reached the maximum number of devices
    case maxDevicesReached // = 9
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .ready
      case 2: self = .noAccountStored
      case 3: self = .accountNotSynced
      case 4: self = .accountNotRegistered
      case 5: self = .accountNotActive
      case 6: self = .noActiveSubscription
      case 7: self = .deviceNotRegistered
      case 8: self = .deviceNotActive
      case 9: self = .maxDevicesReached
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .ready: return 1
      case .noAccountStored: return 2
      case .accountNotSynced: return 3
      case .accountNotRegistered: return 4
      case .accountNotActive: return 5
      case .noActiveSubscription: return 6
      case .deviceNotRegistered: return 7
      case .deviceNotActive: return 8
      case .maxDevicesReached: return 9
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Nym_Vpn_IsReadyToConnectResponse.IsReadyToConnectResponseType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Nym_Vpn_IsReadyToConnectResponse.IsReadyToConnectResponseType] = [
    .unspecified,
    .ready,
    .noAccountStored,
    .accountNotSynced,
    .accountNotRegistered,
    .accountNotActive,
    .noActiveSubscription,
    .deviceNotRegistered,
    .deviceNotActive,
    .maxDevicesReached,
  ]
}

#endif  // swift(>=4.2)

struct Nym_Vpn_AccountError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Nym_Vpn_AccountError.AccountErrorType = .storeAccountErrorUnspecified

  /// Detailed error message for logging and debugging
  var message: String = String()

  /// Optional additional details
  var details: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum AccountErrorType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case storeAccountErrorUnspecified // = 0

    /// The provided mnemonic was not able to be parsed
    case invalidMnemonic // = 1

    /// General error from the storage backend
    case storage // = 2

    /// Unable to proceed while connected
    case isConnected // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .storeAccountErrorUnspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .storeAccountErrorUnspecified
      case 1: self = .invalidMnemonic
      case 2: self = .storage
      case 3: self = .isConnected
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .storeAccountErrorUnspecified: return 0
      case .invalidMnemonic: return 1
      case .storage: return 2
      case .isConnected: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Nym_Vpn_AccountError.AccountErrorType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Nym_Vpn_AccountError.AccountErrorType] = [
    .storeAccountErrorUnspecified,
    .invalidMnemonic,
    .storage,
    .isConnected,
  ]
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension Nym_Vpn_ConnectionStatus: @unchecked Sendable {}
extension Nym_Vpn_GatewayType: @unchecked Sendable {}
extension Nym_Vpn_AccountRegistered: @unchecked Sendable {}
extension Nym_Vpn_MnemonicState: @unchecked Sendable {}
extension Nym_Vpn_AccountState: @unchecked Sendable {}
extension Nym_Vpn_SubscriptionState: @unchecked Sendable {}
extension Nym_Vpn_DeviceState: @unchecked Sendable {}
extension Nym_Vpn_DeviceStatus: @unchecked Sendable {}
extension Nym_Vpn_Empty: @unchecked Sendable {}
extension Nym_Vpn_Gateway: @unchecked Sendable {}
extension Nym_Vpn_Address: @unchecked Sendable {}
extension Nym_Vpn_Location: @unchecked Sendable {}
extension Nym_Vpn_EntryNode: @unchecked Sendable {}
extension Nym_Vpn_EntryNode.OneOf_EntryNodeEnum: @unchecked Sendable {}
extension Nym_Vpn_ExitNode: @unchecked Sendable {}
extension Nym_Vpn_ExitNode.OneOf_ExitNodeEnum: @unchecked Sendable {}
extension Nym_Vpn_MixConnectedStateDetails: @unchecked Sendable {}
extension Nym_Vpn_WgConnectedStateDetails: @unchecked Sendable {}
extension Nym_Vpn_ConnectedStateDetails: @unchecked Sendable {}
extension Nym_Vpn_ConnectedStateDetails.OneOf_ConnectedStateDetails: @unchecked Sendable {}
extension Nym_Vpn_Dns: @unchecked Sendable {}
extension Nym_Vpn_Url: @unchecked Sendable {}
extension Nym_Vpn_UserAgent: @unchecked Sendable {}
extension Nym_Vpn_DenomDetails: @unchecked Sendable {}
extension Nym_Vpn_ChainDetails: @unchecked Sendable {}
extension Nym_Vpn_NymContracts: @unchecked Sendable {}
extension Nym_Vpn_NymNetworkDetails: @unchecked Sendable {}
extension Nym_Vpn_NymVpnNetworkDetails: @unchecked Sendable {}
extension Nym_Vpn_AccountManagement: @unchecked Sendable {}
extension Nym_Vpn_ValidatorDetails: @unchecked Sendable {}
extension Nym_Vpn_InfoRequest: @unchecked Sendable {}
extension Nym_Vpn_InfoResponse: @unchecked Sendable {}
extension Nym_Vpn_SetNetworkRequest: @unchecked Sendable {}
extension Nym_Vpn_SetNetworkResponse: @unchecked Sendable {}
extension Nym_Vpn_SetNetworkRequestError: @unchecked Sendable {}
extension Nym_Vpn_SetNetworkRequestError.SetNetworkRequestErrorType: @unchecked Sendable {}
extension Nym_Vpn_SystemMessage: @unchecked Sendable {}
extension Nym_Vpn_GetSystemMessagesRequest: @unchecked Sendable {}
extension Nym_Vpn_GetSystemMessagesResponse: @unchecked Sendable {}
extension Nym_Vpn_GetFeatureFlagsRequest: @unchecked Sendable {}
extension Nym_Vpn_GetFeatureFlagsResponse: @unchecked Sendable {}
extension Nym_Vpn_FeatureFlagGroup: @unchecked Sendable {}
extension Nym_Vpn_Threshold: @unchecked Sendable {}
extension Nym_Vpn_ConnectRequestError: @unchecked Sendable {}
extension Nym_Vpn_ConnectRequestError.ConnectRequestErrorType: @unchecked Sendable {}
extension Nym_Vpn_ConnectRequest: @unchecked Sendable {}
extension Nym_Vpn_ConnectResponse: @unchecked Sendable {}
extension Nym_Vpn_DisconnectRequest: @unchecked Sendable {}
extension Nym_Vpn_DisconnectResponse: @unchecked Sendable {}
extension Nym_Vpn_ConnectionDetails: @unchecked Sendable {}
extension Nym_Vpn_StatusRequest: @unchecked Sendable {}
extension Nym_Vpn_StatusResponse: @unchecked Sendable {}
extension Nym_Vpn_ConnectionStateChange: @unchecked Sendable {}
extension Nym_Vpn_ConnectionStatusUpdate: @unchecked Sendable {}
extension Nym_Vpn_ConnectionStatusUpdate.StatusType: @unchecked Sendable {}
extension Nym_Vpn_Error: @unchecked Sendable {}
extension Nym_Vpn_Error.ErrorType: @unchecked Sendable {}
extension Nym_Vpn_AsEntry: @unchecked Sendable {}
extension Nym_Vpn_AsExit: @unchecked Sendable {}
extension Nym_Vpn_WgProbeResult: @unchecked Sendable {}
extension Nym_Vpn_ProbeOutcome: @unchecked Sendable {}
extension Nym_Vpn_Probe: @unchecked Sendable {}
extension Nym_Vpn_GatewayResponse: @unchecked Sendable {}
extension Nym_Vpn_ListGatewaysRequest: @unchecked Sendable {}
extension Nym_Vpn_ListGatewaysResponse: @unchecked Sendable {}
extension Nym_Vpn_ListCountriesRequest: @unchecked Sendable {}
extension Nym_Vpn_ListCountriesResponse: @unchecked Sendable {}
extension Nym_Vpn_StoreAccountRequest: @unchecked Sendable {}
extension Nym_Vpn_StoreAccountResponse: @unchecked Sendable {}
extension Nym_Vpn_IsAccountStoredRequest: @unchecked Sendable {}
extension Nym_Vpn_IsAccountStoredResponse: @unchecked Sendable {}
extension Nym_Vpn_IsAccountStoredResponse.OneOf_Resp: @unchecked Sendable {}
extension Nym_Vpn_RemoveAccountRequest: @unchecked Sendable {}
extension Nym_Vpn_RemoveAccountResponse: @unchecked Sendable {}
extension Nym_Vpn_ForgetAccountRequest: @unchecked Sendable {}
extension Nym_Vpn_ForgetAccountResponse: @unchecked Sendable {}
extension Nym_Vpn_GetAccountIdentityRequest: @unchecked Sendable {}
extension Nym_Vpn_GetAccountIdentityResponse: @unchecked Sendable {}
extension Nym_Vpn_GetAccountIdentityResponse.OneOf_ID: @unchecked Sendable {}
extension Nym_Vpn_GetAccountLinksRequest: @unchecked Sendable {}
extension Nym_Vpn_GetAccountLinksResponse: @unchecked Sendable {}
extension Nym_Vpn_GetAccountLinksResponse.OneOf_Res: @unchecked Sendable {}
extension Nym_Vpn_DeviceSummary: @unchecked Sendable {}
extension Nym_Vpn_AccountSummary: @unchecked Sendable {}
extension Nym_Vpn_RegisterDeviceResult: @unchecked Sendable {}
extension Nym_Vpn_RegisterDeviceResult.RegisterDeviceResultType: @unchecked Sendable {}
extension Nym_Vpn_RequestZkNymResult: @unchecked Sendable {}
extension Nym_Vpn_RequestZkNymResult.RequestZkNymResultType: @unchecked Sendable {}
extension Nym_Vpn_RequestZkNymSuccess: @unchecked Sendable {}
extension Nym_Vpn_RequestZkNymError: @unchecked Sendable {}
extension Nym_Vpn_RequestZkNymError.RequestZkNymErrorType: @unchecked Sendable {}
extension Nym_Vpn_AccountStateSummary: @unchecked Sendable {}
extension Nym_Vpn_GetAccountStateRequest: @unchecked Sendable {}
extension Nym_Vpn_GetAccountStateResponse: @unchecked Sendable {}
extension Nym_Vpn_GetAccountStateResponse.OneOf_Result: @unchecked Sendable {}
extension Nym_Vpn_RefreshAccountStateRequest: @unchecked Sendable {}
extension Nym_Vpn_RefreshAccountStateResponse: @unchecked Sendable {}
extension Nym_Vpn_AccountUsages: @unchecked Sendable {}
extension Nym_Vpn_AccountUsage: @unchecked Sendable {}
extension Nym_Vpn_GetAccountUsageRequest: @unchecked Sendable {}
extension Nym_Vpn_GetAccountUsageResponse: @unchecked Sendable {}
extension Nym_Vpn_GetAccountUsageResponse.OneOf_Result: @unchecked Sendable {}
extension Nym_Vpn_FetchRawAccountSummaryRequest: @unchecked Sendable {}
extension Nym_Vpn_FetchRawAccountSummaryResponse: @unchecked Sendable {}
extension Nym_Vpn_FetchRawDevicesRequest: @unchecked Sendable {}
extension Nym_Vpn_FetchRawDevicesResponse: @unchecked Sendable {}
extension Nym_Vpn_ResetDeviceIdentityRequest: @unchecked Sendable {}
extension Nym_Vpn_ResetDeviceIdentityResponse: @unchecked Sendable {}
extension Nym_Vpn_GetDeviceIdentityRequest: @unchecked Sendable {}
extension Nym_Vpn_GetDeviceIdentityResponse: @unchecked Sendable {}
extension Nym_Vpn_GetDeviceIdentityResponse.OneOf_ID: @unchecked Sendable {}
extension Nym_Vpn_RegisterDeviceRequest: @unchecked Sendable {}
extension Nym_Vpn_RegisterDeviceResponse: @unchecked Sendable {}
extension Nym_Vpn_Device: @unchecked Sendable {}
extension Nym_Vpn_Devices: @unchecked Sendable {}
extension Nym_Vpn_GetDevicesRequest: @unchecked Sendable {}
extension Nym_Vpn_GetDevicesResponse: @unchecked Sendable {}
extension Nym_Vpn_GetDevicesResponse.OneOf_Result: @unchecked Sendable {}
extension Nym_Vpn_GetActiveDevicesRequest: @unchecked Sendable {}
extension Nym_Vpn_GetActiveDevicesResponse: @unchecked Sendable {}
extension Nym_Vpn_GetActiveDevicesResponse.OneOf_Result: @unchecked Sendable {}
extension Nym_Vpn_RequestZkNymRequest: @unchecked Sendable {}
extension Nym_Vpn_RequestZkNymResponse: @unchecked Sendable {}
extension Nym_Vpn_GetDeviceZkNymsRequest: @unchecked Sendable {}
extension Nym_Vpn_GetDeviceZkNymsResponse: @unchecked Sendable {}
extension Nym_Vpn_GetZkNymsAvailableForDownloadRequest: @unchecked Sendable {}
extension Nym_Vpn_GetZkNymsAvailableForDownloadResponse: @unchecked Sendable {}
extension Nym_Vpn_GetZkNymByIdRequest: @unchecked Sendable {}
extension Nym_Vpn_GetZkNymByIdResponse: @unchecked Sendable {}
extension Nym_Vpn_ConfirmZkNymDownloadedRequest: @unchecked Sendable {}
extension Nym_Vpn_ConfirmZkNymDownloadedResponse: @unchecked Sendable {}
extension Nym_Vpn_AvailableTickets: @unchecked Sendable {}
extension Nym_Vpn_GetAvailableTicketsRequest: @unchecked Sendable {}
extension Nym_Vpn_GetAvailableTicketsResponse: @unchecked Sendable {}
extension Nym_Vpn_GetAvailableTicketsResponse.OneOf_Resp: @unchecked Sendable {}
extension Nym_Vpn_IsReadyToConnectRequest: @unchecked Sendable {}
extension Nym_Vpn_IsReadyToConnectResponse: @unchecked Sendable {}
extension Nym_Vpn_IsReadyToConnectResponse.IsReadyToConnectResponseType: @unchecked Sendable {}
extension Nym_Vpn_AccountError: @unchecked Sendable {}
extension Nym_Vpn_AccountError.AccountErrorType: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "nym.vpn"

extension Nym_Vpn_ConnectionStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNSPECIFIED"),
    1: .same(proto: "UNKNOWN"),
    2: .same(proto: "NOT_CONNECTED"),
    3: .same(proto: "CONNECTING"),
    4: .same(proto: "CONNECTED"),
    5: .same(proto: "DISCONNECTING"),
    6: .same(proto: "CONNECTION_FAILED"),
  ]
}

extension Nym_Vpn_GatewayType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GATEWAY_TYPE_UNSPECIFIED"),
    1: .same(proto: "MIXNET_ENTRY"),
    2: .same(proto: "MIXNET_EXIT"),
    3: .same(proto: "WG"),
  ]
}

extension Nym_Vpn_AccountRegistered: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ACCOUNT_REGISTERED_UNSPECIFIED"),
    1: .same(proto: "ACCOUNT_REGISTERED"),
    2: .same(proto: "ACCOUNT_NOT_REGISTERED"),
  ]
}

extension Nym_Vpn_MnemonicState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MNEMONIC_STATE_UNSPECIFIED"),
    1: .same(proto: "MNEMONIC_STATE_NOT_STORED"),
    2: .same(proto: "MNEMONIC_STATE_STORED"),
  ]
}

extension Nym_Vpn_AccountState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ACCOUNT_STATE_UNSPECIFIED"),
    1: .same(proto: "ACCOUNT_STATE_NOT_REGISTERED"),
    2: .same(proto: "ACCOUNT_STATE_INACTIVE"),
    3: .same(proto: "ACCOUNT_STATE_ACTIVE"),
    4: .same(proto: "ACCOUNT_STATE_DELETE_ME"),
  ]
}

extension Nym_Vpn_SubscriptionState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUBSCRIPTION_STATE_UNSPECIFIED"),
    1: .same(proto: "SUBSCRIPTION_STATE_NOT_REGISTERED"),
    2: .same(proto: "SUBSCRIPTION_STATE_PENDING"),
    3: .same(proto: "SUBSCRIPTION_STATE_ACTIVE"),
    4: .same(proto: "SUBSCRIPTION_STATE_COMPLETE"),
  ]
}

extension Nym_Vpn_DeviceState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEVICE_STATE_UNSPECIFIED"),
    1: .same(proto: "DEVICE_STATE_NOT_REGISTERED"),
    2: .same(proto: "DEVICE_STATE_INACTIVE"),
    3: .same(proto: "DEVICE_STATE_ACTIVE"),
    4: .same(proto: "DEVICE_STATE_DELETE_ME"),
  ]
}

extension Nym_Vpn_DeviceStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEVICE_STATUS_UNSPECIFIED"),
    1: .same(proto: "DEVICE_STATUS_ACTIVE"),
    2: .same(proto: "DEVICE_STATUS_INACTIVE"),
    3: .same(proto: "DEVICE_STATUS_DELETE_ME"),
  ]
}

extension Nym_Vpn_Empty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Empty"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_Empty, rhs: Nym_Vpn_Empty) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_Gateway: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Gateway"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_Gateway, rhs: Nym_Vpn_Gateway) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_Address: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Address"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "nym_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.nymAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nymAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.nymAddress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_Address, rhs: Nym_Vpn_Address) -> Bool {
    if lhs.nymAddress != rhs.nymAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_Location: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Location"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "two_letter_iso_country_code"),
    2: .same(proto: "latitude"),
    3: .same(proto: "longitude"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.twoLetterIsoCountryCode) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self._latitude) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self._longitude) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.twoLetterIsoCountryCode.isEmpty {
      try visitor.visitSingularStringField(value: self.twoLetterIsoCountryCode, fieldNumber: 1)
    }
    try { if let v = self._latitude {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._longitude {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_Location, rhs: Nym_Vpn_Location) -> Bool {
    if lhs.twoLetterIsoCountryCode != rhs.twoLetterIsoCountryCode {return false}
    if lhs._latitude != rhs._latitude {return false}
    if lhs._longitude != rhs._longitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_EntryNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EntryNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gateway"),
    2: .same(proto: "location"),
    3: .standard(proto: "random_low_latency"),
    4: .same(proto: "random"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Nym_Vpn_Gateway?
        var hadOneofValue = false
        if let current = self.entryNodeEnum {
          hadOneofValue = true
          if case .gateway(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.entryNodeEnum = .gateway(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_Location?
        var hadOneofValue = false
        if let current = self.entryNodeEnum {
          hadOneofValue = true
          if case .location(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.entryNodeEnum = .location(v)
        }
      }()
      case 3: try {
        var v: Nym_Vpn_Empty?
        var hadOneofValue = false
        if let current = self.entryNodeEnum {
          hadOneofValue = true
          if case .randomLowLatency(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.entryNodeEnum = .randomLowLatency(v)
        }
      }()
      case 4: try {
        var v: Nym_Vpn_Empty?
        var hadOneofValue = false
        if let current = self.entryNodeEnum {
          hadOneofValue = true
          if case .random(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.entryNodeEnum = .random(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.entryNodeEnum {
    case .gateway?: try {
      guard case .gateway(let v)? = self.entryNodeEnum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .location?: try {
      guard case .location(let v)? = self.entryNodeEnum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .randomLowLatency?: try {
      guard case .randomLowLatency(let v)? = self.entryNodeEnum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .random?: try {
      guard case .random(let v)? = self.entryNodeEnum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_EntryNode, rhs: Nym_Vpn_EntryNode) -> Bool {
    if lhs.entryNodeEnum != rhs.entryNodeEnum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ExitNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExitNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "gateway"),
    3: .same(proto: "location"),
    4: .same(proto: "random"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Nym_Vpn_Address?
        var hadOneofValue = false
        if let current = self.exitNodeEnum {
          hadOneofValue = true
          if case .address(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.exitNodeEnum = .address(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_Gateway?
        var hadOneofValue = false
        if let current = self.exitNodeEnum {
          hadOneofValue = true
          if case .gateway(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.exitNodeEnum = .gateway(v)
        }
      }()
      case 3: try {
        var v: Nym_Vpn_Location?
        var hadOneofValue = false
        if let current = self.exitNodeEnum {
          hadOneofValue = true
          if case .location(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.exitNodeEnum = .location(v)
        }
      }()
      case 4: try {
        var v: Nym_Vpn_Empty?
        var hadOneofValue = false
        if let current = self.exitNodeEnum {
          hadOneofValue = true
          if case .random(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.exitNodeEnum = .random(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.exitNodeEnum {
    case .address?: try {
      guard case .address(let v)? = self.exitNodeEnum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .gateway?: try {
      guard case .gateway(let v)? = self.exitNodeEnum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .location?: try {
      guard case .location(let v)? = self.exitNodeEnum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .random?: try {
      guard case .random(let v)? = self.exitNodeEnum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ExitNode, rhs: Nym_Vpn_ExitNode) -> Bool {
    if lhs.exitNodeEnum != rhs.exitNodeEnum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_MixConnectedStateDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MixConnectedStateDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "nym_address"),
    2: .standard(proto: "exit_ipr"),
    3: .same(proto: "ipv4"),
    4: .same(proto: "ipv6"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._nymAddress) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._exitIpr) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ipv4) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.ipv6) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nymAddress {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._exitIpr {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.ipv4.isEmpty {
      try visitor.visitSingularStringField(value: self.ipv4, fieldNumber: 3)
    }
    if !self.ipv6.isEmpty {
      try visitor.visitSingularStringField(value: self.ipv6, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_MixConnectedStateDetails, rhs: Nym_Vpn_MixConnectedStateDetails) -> Bool {
    if lhs._nymAddress != rhs._nymAddress {return false}
    if lhs._exitIpr != rhs._exitIpr {return false}
    if lhs.ipv4 != rhs.ipv4 {return false}
    if lhs.ipv6 != rhs.ipv6 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_WgConnectedStateDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WgConnectedStateDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "entry_ipv4"),
    2: .standard(proto: "exit_ipv4"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.entryIpv4) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.exitIpv4) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entryIpv4.isEmpty {
      try visitor.visitSingularStringField(value: self.entryIpv4, fieldNumber: 1)
    }
    if !self.exitIpv4.isEmpty {
      try visitor.visitSingularStringField(value: self.exitIpv4, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_WgConnectedStateDetails, rhs: Nym_Vpn_WgConnectedStateDetails) -> Bool {
    if lhs.entryIpv4 != rhs.entryIpv4 {return false}
    if lhs.exitIpv4 != rhs.exitIpv4 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ConnectedStateDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectedStateDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mix"),
    2: .same(proto: "wg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Nym_Vpn_MixConnectedStateDetails?
        var hadOneofValue = false
        if let current = self.connectedStateDetails {
          hadOneofValue = true
          if case .mix(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.connectedStateDetails = .mix(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_WgConnectedStateDetails?
        var hadOneofValue = false
        if let current = self.connectedStateDetails {
          hadOneofValue = true
          if case .wg(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.connectedStateDetails = .wg(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.connectedStateDetails {
    case .mix?: try {
      guard case .mix(let v)? = self.connectedStateDetails else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .wg?: try {
      guard case .wg(let v)? = self.connectedStateDetails else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ConnectedStateDetails, rhs: Nym_Vpn_ConnectedStateDetails) -> Bool {
    if lhs.connectedStateDetails != rhs.connectedStateDetails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_Dns: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Dns"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ip"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ip) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ip.isEmpty {
      try visitor.visitSingularStringField(value: self.ip, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_Dns, rhs: Nym_Vpn_Dns) -> Bool {
    if lhs.ip != rhs.ip {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_Url: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Url"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_Url, rhs: Nym_Vpn_Url) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_UserAgent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserAgent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "application"),
    2: .same(proto: "version"),
    3: .same(proto: "platform"),
    4: .standard(proto: "git_commit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.application) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.platform) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.gitCommit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.application.isEmpty {
      try visitor.visitSingularStringField(value: self.application, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    if !self.platform.isEmpty {
      try visitor.visitSingularStringField(value: self.platform, fieldNumber: 3)
    }
    if !self.gitCommit.isEmpty {
      try visitor.visitSingularStringField(value: self.gitCommit, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_UserAgent, rhs: Nym_Vpn_UserAgent) -> Bool {
    if lhs.application != rhs.application {return false}
    if lhs.version != rhs.version {return false}
    if lhs.platform != rhs.platform {return false}
    if lhs.gitCommit != rhs.gitCommit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_DenomDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DenomDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "base"),
    2: .same(proto: "display"),
    3: .standard(proto: "display_exponent"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.base) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.display) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.displayExponent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.base.isEmpty {
      try visitor.visitSingularStringField(value: self.base, fieldNumber: 1)
    }
    if !self.display.isEmpty {
      try visitor.visitSingularStringField(value: self.display, fieldNumber: 2)
    }
    if self.displayExponent != 0 {
      try visitor.visitSingularUInt32Field(value: self.displayExponent, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_DenomDetails, rhs: Nym_Vpn_DenomDetails) -> Bool {
    if lhs.base != rhs.base {return false}
    if lhs.display != rhs.display {return false}
    if lhs.displayExponent != rhs.displayExponent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ChainDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChainDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bech32_account_prefix"),
    2: .standard(proto: "mix_denom"),
    3: .standard(proto: "stake_denom"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bech32AccountPrefix) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._mixDenom) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._stakeDenom) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.bech32AccountPrefix.isEmpty {
      try visitor.visitSingularStringField(value: self.bech32AccountPrefix, fieldNumber: 1)
    }
    try { if let v = self._mixDenom {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._stakeDenom {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ChainDetails, rhs: Nym_Vpn_ChainDetails) -> Bool {
    if lhs.bech32AccountPrefix != rhs.bech32AccountPrefix {return false}
    if lhs._mixDenom != rhs._mixDenom {return false}
    if lhs._stakeDenom != rhs._stakeDenom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_NymContracts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NymContracts"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "mixnet_contract_address"),
    2: .standard(proto: "vesting_contract_address"),
    3: .standard(proto: "ecash_contract_address"),
    4: .standard(proto: "group_contract_address"),
    5: .standard(proto: "multisig_contract_address"),
    6: .standard(proto: "coconut_dkg_contract_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._mixnetContractAddress) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._vestingContractAddress) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._ecashContractAddress) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._groupContractAddress) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._multisigContractAddress) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._coconutDkgContractAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mixnetContractAddress {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._vestingContractAddress {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._ecashContractAddress {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._groupContractAddress {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._multisigContractAddress {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._coconutDkgContractAddress {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_NymContracts, rhs: Nym_Vpn_NymContracts) -> Bool {
    if lhs._mixnetContractAddress != rhs._mixnetContractAddress {return false}
    if lhs._vestingContractAddress != rhs._vestingContractAddress {return false}
    if lhs._ecashContractAddress != rhs._ecashContractAddress {return false}
    if lhs._groupContractAddress != rhs._groupContractAddress {return false}
    if lhs._multisigContractAddress != rhs._multisigContractAddress {return false}
    if lhs._coconutDkgContractAddress != rhs._coconutDkgContractAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_NymNetworkDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NymNetworkDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "network_name"),
    2: .standard(proto: "chain_details"),
    3: .same(proto: "endpoints"),
    4: .same(proto: "contracts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.networkName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._chainDetails) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.endpoints) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._contracts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.networkName.isEmpty {
      try visitor.visitSingularStringField(value: self.networkName, fieldNumber: 1)
    }
    try { if let v = self._chainDetails {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.endpoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.endpoints, fieldNumber: 3)
    }
    try { if let v = self._contracts {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_NymNetworkDetails, rhs: Nym_Vpn_NymNetworkDetails) -> Bool {
    if lhs.networkName != rhs.networkName {return false}
    if lhs._chainDetails != rhs._chainDetails {return false}
    if lhs.endpoints != rhs.endpoints {return false}
    if lhs._contracts != rhs._contracts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_NymVpnNetworkDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NymVpnNetworkDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "nym_vpn_api_url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._nymVpnApiURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nymVpnApiURL {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_NymVpnNetworkDetails, rhs: Nym_Vpn_NymVpnNetworkDetails) -> Bool {
    if lhs._nymVpnApiURL != rhs._nymVpnApiURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_AccountManagement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountManagement"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sign_up"),
    2: .standard(proto: "sign_in"),
    3: .same(proto: "account"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._signUp) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._signIn) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._account) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._signUp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._signIn {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._account {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_AccountManagement, rhs: Nym_Vpn_AccountManagement) -> Bool {
    if lhs._signUp != rhs._signUp {return false}
    if lhs._signIn != rhs._signIn {return false}
    if lhs._account != rhs._account {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ValidatorDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ValidatorDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "nyxd_url"),
    2: .standard(proto: "websocket_url"),
    3: .standard(proto: "api_url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._nyxdURL) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._websocketURL) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._apiURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nyxdURL {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._websocketURL {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._apiURL {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ValidatorDetails, rhs: Nym_Vpn_ValidatorDetails) -> Bool {
    if lhs._nyxdURL != rhs._nyxdURL {return false}
    if lhs._websocketURL != rhs._websocketURL {return false}
    if lhs._apiURL != rhs._apiURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_InfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InfoRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_InfoRequest, rhs: Nym_Vpn_InfoRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_InfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .standard(proto: "build_timestamp"),
    3: .same(proto: "triple"),
    4: .same(proto: "platform"),
    5: .standard(proto: "git_commit"),
    6: .standard(proto: "nym_network"),
    7: .standard(proto: "nym_vpn_network"),
  ]

  fileprivate class _StorageClass {
    var _version: String = String()
    var _buildTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _triple: String = String()
    var _platform: String = String()
    var _gitCommit: String = String()
    var _nymNetwork: Nym_Vpn_NymNetworkDetails? = nil
    var _nymVpnNetwork: Nym_Vpn_NymVpnNetworkDetails? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _version = source._version
      _buildTimestamp = source._buildTimestamp
      _triple = source._triple
      _platform = source._platform
      _gitCommit = source._gitCommit
      _nymNetwork = source._nymNetwork
      _nymVpnNetwork = source._nymVpnNetwork
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._version) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._buildTimestamp) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._triple) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._platform) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._gitCommit) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._nymNetwork) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._nymVpnNetwork) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 1)
      }
      try { if let v = _storage._buildTimestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._triple.isEmpty {
        try visitor.visitSingularStringField(value: _storage._triple, fieldNumber: 3)
      }
      if !_storage._platform.isEmpty {
        try visitor.visitSingularStringField(value: _storage._platform, fieldNumber: 4)
      }
      if !_storage._gitCommit.isEmpty {
        try visitor.visitSingularStringField(value: _storage._gitCommit, fieldNumber: 5)
      }
      try { if let v = _storage._nymNetwork {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._nymVpnNetwork {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_InfoResponse, rhs: Nym_Vpn_InfoResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._version != rhs_storage._version {return false}
        if _storage._buildTimestamp != rhs_storage._buildTimestamp {return false}
        if _storage._triple != rhs_storage._triple {return false}
        if _storage._platform != rhs_storage._platform {return false}
        if _storage._gitCommit != rhs_storage._gitCommit {return false}
        if _storage._nymNetwork != rhs_storage._nymNetwork {return false}
        if _storage._nymVpnNetwork != rhs_storage._nymVpnNetwork {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_SetNetworkRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetNetworkRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "network"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.network) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.network.isEmpty {
      try visitor.visitSingularStringField(value: self.network, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_SetNetworkRequest, rhs: Nym_Vpn_SetNetworkRequest) -> Bool {
    if lhs.network != rhs.network {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_SetNetworkResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetNetworkResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_SetNetworkResponse, rhs: Nym_Vpn_SetNetworkResponse) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_SetNetworkRequestError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetNetworkRequestError"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.kind != .unspecified {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_SetNetworkRequestError, rhs: Nym_Vpn_SetNetworkRequestError) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_SetNetworkRequestError.SetNetworkRequestErrorType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SET_NETWORK_REQUEST_ERROR_TYPE_UNSPECIFIED"),
    1: .same(proto: "INTERNAL"),
    2: .same(proto: "INVALID_NETWORK_NAME"),
  ]
}

extension Nym_Vpn_SystemMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SystemMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "message"),
    3: .same(proto: "properties"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.properties) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.properties.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.properties, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_SystemMessage, rhs: Nym_Vpn_SystemMessage) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.message != rhs.message {return false}
    if lhs.properties != rhs.properties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetSystemMessagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSystemMessagesRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetSystemMessagesRequest, rhs: Nym_Vpn_GetSystemMessagesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetSystemMessagesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSystemMessagesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messages"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetSystemMessagesResponse, rhs: Nym_Vpn_GetSystemMessagesResponse) -> Bool {
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetFeatureFlagsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetFeatureFlagsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetFeatureFlagsRequest, rhs: Nym_Vpn_GetFeatureFlagsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetFeatureFlagsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetFeatureFlagsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "flags"),
    2: .same(proto: "groups"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.flags) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Nym_Vpn_FeatureFlagGroup>.self, value: &self.groups) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.flags.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.flags, fieldNumber: 1)
    }
    if !self.groups.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Nym_Vpn_FeatureFlagGroup>.self, value: self.groups, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetFeatureFlagsResponse, rhs: Nym_Vpn_GetFeatureFlagsResponse) -> Bool {
    if lhs.flags != rhs.flags {return false}
    if lhs.groups != rhs.groups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_FeatureFlagGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FeatureFlagGroup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "map"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.map) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.map.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.map, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_FeatureFlagGroup, rhs: Nym_Vpn_FeatureFlagGroup) -> Bool {
    if lhs.map != rhs.map {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_Threshold: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Threshold"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_performance"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.minPerformance) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.minPerformance != 0 {
      try visitor.visitSingularUInt32Field(value: self.minPerformance, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_Threshold, rhs: Nym_Vpn_Threshold) -> Bool {
    if lhs.minPerformance != rhs.minPerformance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ConnectRequestError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectRequestError"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .same(proto: "message"),
    3: .standard(proto: "message_id"),
    4: .standard(proto: "zk_nym_error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._messageID) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.zkNymError) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.kind != .unspecified {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._messageID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    if !self.zkNymError.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.zkNymError, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ConnectRequestError, rhs: Nym_Vpn_ConnectRequestError) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.message != rhs.message {return false}
    if lhs._messageID != rhs._messageID {return false}
    if lhs.zkNymError != rhs.zkNymError {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ConnectRequestError.ConnectRequestErrorType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONNECT_REQUEST_ERROR_TYPE_UNSPECIFIED"),
    1: .same(proto: "INTERNAL"),
    2: .same(proto: "GENERAL"),
    3: .same(proto: "NO_ACCOUNT_STORED"),
    4: .same(proto: "NO_DEVICE_STORED"),
    5: .same(proto: "UPDATE_ACCOUNT"),
    6: .same(proto: "UPDATE_DEVICE"),
    7: .same(proto: "REGISTER_DEVICE"),
    8: .same(proto: "REQUEST_ZK_NYM"),
  ]
}

extension Nym_Vpn_ConnectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entry"),
    2: .same(proto: "exit"),
    3: .same(proto: "dns"),
    4: .standard(proto: "disable_routing"),
    5: .standard(proto: "enable_two_hop"),
    13: .same(proto: "netstack"),
    6: .standard(proto: "disable_poisson_rate"),
    7: .standard(proto: "disable_background_cover_traffic"),
    8: .standard(proto: "enable_credentials_mode"),
    12: .standard(proto: "user_agent"),
    9: .standard(proto: "min_mixnode_performance"),
    10: .standard(proto: "min_gateway_mixnet_performance"),
    11: .standard(proto: "min_gateway_vpn_performance"),
  ]

  fileprivate class _StorageClass {
    var _entry: Nym_Vpn_EntryNode? = nil
    var _exit: Nym_Vpn_ExitNode? = nil
    var _dns: Nym_Vpn_Dns? = nil
    var _disableRouting: Bool = false
    var _enableTwoHop: Bool = false
    var _netstack: Bool = false
    var _disablePoissonRate: Bool = false
    var _disableBackgroundCoverTraffic: Bool = false
    var _enableCredentialsMode: Bool = false
    var _userAgent: Nym_Vpn_UserAgent? = nil
    var _minMixnodePerformance: Nym_Vpn_Threshold? = nil
    var _minGatewayMixnetPerformance: Nym_Vpn_Threshold? = nil
    var _minGatewayVpnPerformance: Nym_Vpn_Threshold? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _entry = source._entry
      _exit = source._exit
      _dns = source._dns
      _disableRouting = source._disableRouting
      _enableTwoHop = source._enableTwoHop
      _netstack = source._netstack
      _disablePoissonRate = source._disablePoissonRate
      _disableBackgroundCoverTraffic = source._disableBackgroundCoverTraffic
      _enableCredentialsMode = source._enableCredentialsMode
      _userAgent = source._userAgent
      _minMixnodePerformance = source._minMixnodePerformance
      _minGatewayMixnetPerformance = source._minGatewayMixnetPerformance
      _minGatewayVpnPerformance = source._minGatewayVpnPerformance
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._entry) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._exit) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._dns) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._disableRouting) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._enableTwoHop) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._disablePoissonRate) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._disableBackgroundCoverTraffic) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._enableCredentialsMode) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._minMixnodePerformance) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._minGatewayMixnetPerformance) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._minGatewayVpnPerformance) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._userAgent) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._netstack) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._entry {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._exit {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._dns {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._disableRouting != false {
        try visitor.visitSingularBoolField(value: _storage._disableRouting, fieldNumber: 4)
      }
      if _storage._enableTwoHop != false {
        try visitor.visitSingularBoolField(value: _storage._enableTwoHop, fieldNumber: 5)
      }
      if _storage._disablePoissonRate != false {
        try visitor.visitSingularBoolField(value: _storage._disablePoissonRate, fieldNumber: 6)
      }
      if _storage._disableBackgroundCoverTraffic != false {
        try visitor.visitSingularBoolField(value: _storage._disableBackgroundCoverTraffic, fieldNumber: 7)
      }
      if _storage._enableCredentialsMode != false {
        try visitor.visitSingularBoolField(value: _storage._enableCredentialsMode, fieldNumber: 8)
      }
      try { if let v = _storage._minMixnodePerformance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._minGatewayMixnetPerformance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._minGatewayVpnPerformance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._userAgent {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if _storage._netstack != false {
        try visitor.visitSingularBoolField(value: _storage._netstack, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ConnectRequest, rhs: Nym_Vpn_ConnectRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._entry != rhs_storage._entry {return false}
        if _storage._exit != rhs_storage._exit {return false}
        if _storage._dns != rhs_storage._dns {return false}
        if _storage._disableRouting != rhs_storage._disableRouting {return false}
        if _storage._enableTwoHop != rhs_storage._enableTwoHop {return false}
        if _storage._netstack != rhs_storage._netstack {return false}
        if _storage._disablePoissonRate != rhs_storage._disablePoissonRate {return false}
        if _storage._disableBackgroundCoverTraffic != rhs_storage._disableBackgroundCoverTraffic {return false}
        if _storage._enableCredentialsMode != rhs_storage._enableCredentialsMode {return false}
        if _storage._userAgent != rhs_storage._userAgent {return false}
        if _storage._minMixnodePerformance != rhs_storage._minMixnodePerformance {return false}
        if _storage._minGatewayMixnetPerformance != rhs_storage._minGatewayMixnetPerformance {return false}
        if _storage._minGatewayVpnPerformance != rhs_storage._minGatewayVpnPerformance {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ConnectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ConnectResponse, rhs: Nym_Vpn_ConnectResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_DisconnectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisconnectRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_DisconnectRequest, rhs: Nym_Vpn_DisconnectRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_DisconnectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisconnectResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_DisconnectResponse, rhs: Nym_Vpn_DisconnectResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ConnectionDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectionDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "entry_gateway"),
    2: .standard(proto: "exit_gateway"),
    3: .standard(proto: "protocol_details"),
    4: .same(proto: "since"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._entryGateway) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._exitGateway) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._protocolDetails) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._since) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._entryGateway {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._exitGateway {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._protocolDetails {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._since {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ConnectionDetails, rhs: Nym_Vpn_ConnectionDetails) -> Bool {
    if lhs._entryGateway != rhs._entryGateway {return false}
    if lhs._exitGateway != rhs._exitGateway {return false}
    if lhs._protocolDetails != rhs._protocolDetails {return false}
    if lhs._since != rhs._since {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_StatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StatusRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_StatusRequest, rhs: Nym_Vpn_StatusRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_StatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StatusResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "details"),
    3: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.status != .statusUnspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_StatusResponse, rhs: Nym_Vpn_StatusResponse) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs._details != rhs._details {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ConnectionStateChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectionStateChange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.status != .statusUnspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ConnectionStateChange, rhs: Nym_Vpn_ConnectionStateChange) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ConnectionStatusUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectionStatusUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .same(proto: "message"),
    3: .same(proto: "details"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.details) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.kind != .unspecified {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.details.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.details, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ConnectionStatusUpdate, rhs: Nym_Vpn_ConnectionStatusUpdate) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.message != rhs.message {return false}
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ConnectionStatusUpdate.StatusType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_TYPE_UNSPECIFIED"),
    1: .same(proto: "UNKNOWN"),
    2: .same(proto: "ENTRY_GATEWAY_CONNECTION_ESTABLISHED"),
    3: .same(proto: "EXIT_ROUTER_CONNECTION_ESTABLISHED"),
    4: .same(proto: "TUNNEL_END_TO_END_CONNECTION_ESTABLISHED"),
    5: .same(proto: "ENTRY_GATEWAY_NOT_ROUTING_MIXNET_MESSAGES"),
    6: .same(proto: "EXIT_ROUTER_NOT_RESPONDING_TO_IPV4_PING"),
    7: .same(proto: "EXIT_ROUTER_NOT_RESPONDING_TO_IPV6_PING"),
    8: .same(proto: "EXIT_ROUTER_NOT_ROUTING_IPV4_TRAFFIC"),
    9: .same(proto: "EXIT_ROUTER_NOT_ROUTING_IPV6_TRAFFIC"),
    10: .same(proto: "CONNECTION_OK_IPV4"),
    11: .same(proto: "CONNECTION_OK_IPV6"),
    12: .same(proto: "REMAINING_BANDWIDTH"),
    13: .same(proto: "NO_BANDWIDTH"),
    14: .same(proto: "WG_TUNNEL_ERROR"),
    15: .same(proto: "MIXNET_BANDWIDTH_RATE"),
  ]
}

extension Nym_Vpn_Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Error"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .same(proto: "message"),
    3: .same(proto: "details"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.details) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.kind != .unspecified {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.details.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.details, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_Error, rhs: Nym_Vpn_Error) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.message != rhs.message {return false}
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_Error.ErrorType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ERROR_TYPE_UNSPECIFIED"),
    1: .same(proto: "UNHANDLED"),
    2: .same(proto: "NO_VALID_CREDENTIALS"),
    6: .same(proto: "TIMEOUT"),
    7: .same(proto: "MIXNET_TIMEOUT"),
    8: .same(proto: "GATEWAY_DIRECTORY"),
    9: .same(proto: "GATEWAY_DIRECTORY_LOOKUP_GATEWAYS"),
    10: .same(proto: "GATEWAY_DIRECTORY_LOOKUP_GATEWAY_IDENTITY"),
    11: .same(proto: "GATEWAY_DIRECTORY_LOOKUP_ROUTER_ADDRESS"),
    12: .same(proto: "GATEWAY_DIRECTORY_LOOKUP_IP"),
    13: .same(proto: "GATEWAY_DIRECTORY_ENTRY"),
    14: .same(proto: "GATEWAY_DIRECTORY_ENTRY_LOCATION"),
    15: .same(proto: "GATEWAY_DIRECTORY_EXIT"),
    16: .same(proto: "GATEWAY_DIRECTORY_EXIT_LOCATION"),
    17: .same(proto: "GATEWAY_DIRECTORY_SAME_ENTRY_AND_EXIT_GW"),
    18: .same(proto: "OUT_OF_BANDWIDTH"),
    19: .same(proto: "MIXNET_STORAGE_PATHS"),
    20: .same(proto: "MIXNET_DEFAULT_STORAGE"),
    21: .same(proto: "MIXNET_BUILD_CLIENT"),
    22: .same(proto: "MIXNET_CONNECT"),
    23: .same(proto: "MIXNET_ENTRY_GATEWAY"),
    24: .same(proto: "GATEWAY_DIRECTORY_ENTRY_ID"),
    25: .same(proto: "IPR_FAILED_TO_CONNECT"),
    26: .same(proto: "OUT_OF_BANDWIDTH_WHEN_SETTING_UP_TUNNEL"),
    27: .same(proto: "BRING_INTERFACE_UP"),
    28: .same(proto: "FIREWALL_INIT"),
    29: .same(proto: "FIREWALL_RESET_POLICY"),
    30: .same(proto: "DNS_INIT"),
    31: .same(proto: "DNS_SET"),
    32: .same(proto: "FIND_DEFAULT_INTERFACE"),
    33: .same(proto: "INTERNAL"),
    34: .same(proto: "AUTHENTICATOR_FAILED_TO_CONNECT"),
    35: .same(proto: "AUTHENTICATOR_CONNECT_TIMEOUT"),
    36: .same(proto: "AUTHENTICATOR_INVALID_RESPONSE"),
    37: .same(proto: "AUTHENTICATOR_REGISTRATION_DATA_VERIFICATION"),
    38: .same(proto: "AUTHENTICATOR_ENTRY_GATEWAY_SOCKET_ADDR"),
    39: .same(proto: "AUTHENTICATOR_ENTRY_GATEWAY_IPV4"),
    40: .same(proto: "AUTHENTICATOR_WRONG_VERSION"),
    41: .same(proto: "AUTHENTICATOR_MALFORMED_REPLY"),
    42: .same(proto: "ADD_IPV6_ROUTE"),
    43: .same(proto: "TUN"),
    44: .same(proto: "ROUTING"),
    45: .same(proto: "WIREGUARD_CONFIG"),
    46: .same(proto: "MIXNET_CONNECTION_MONITOR"),
    47: .same(proto: "AUTHENTICATOR_ADDRESS_NOT_FOUND"),
    48: .same(proto: "AUTHENTICATOR_AUTHENTICATION_NOT_POSSIBLE"),
    49: .same(proto: "UNHANDLED_EXIT"),
  ]
}

extension Nym_Vpn_AsEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AsEntry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "can_connect"),
    2: .standard(proto: "can_route"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.canConnect) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.canRoute) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.canConnect != false {
      try visitor.visitSingularBoolField(value: self.canConnect, fieldNumber: 1)
    }
    if self.canRoute != false {
      try visitor.visitSingularBoolField(value: self.canRoute, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_AsEntry, rhs: Nym_Vpn_AsEntry) -> Bool {
    if lhs.canConnect != rhs.canConnect {return false}
    if lhs.canRoute != rhs.canRoute {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_AsExit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AsExit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "can_connect"),
    2: .standard(proto: "can_route_ip_v4"),
    3: .standard(proto: "can_route_ip_v6"),
    4: .standard(proto: "can_route_ip_external_v4"),
    5: .standard(proto: "can_route_ip_external_v6"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.canConnect) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.canRouteIpV4) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.canRouteIpV6) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.canRouteIpExternalV4) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.canRouteIpExternalV6) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.canConnect != false {
      try visitor.visitSingularBoolField(value: self.canConnect, fieldNumber: 1)
    }
    if self.canRouteIpV4 != false {
      try visitor.visitSingularBoolField(value: self.canRouteIpV4, fieldNumber: 2)
    }
    if self.canRouteIpV6 != false {
      try visitor.visitSingularBoolField(value: self.canRouteIpV6, fieldNumber: 3)
    }
    if self.canRouteIpExternalV4 != false {
      try visitor.visitSingularBoolField(value: self.canRouteIpExternalV4, fieldNumber: 4)
    }
    if self.canRouteIpExternalV6 != false {
      try visitor.visitSingularBoolField(value: self.canRouteIpExternalV6, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_AsExit, rhs: Nym_Vpn_AsExit) -> Bool {
    if lhs.canConnect != rhs.canConnect {return false}
    if lhs.canRouteIpV4 != rhs.canRouteIpV4 {return false}
    if lhs.canRouteIpV6 != rhs.canRouteIpV6 {return false}
    if lhs.canRouteIpExternalV4 != rhs.canRouteIpExternalV4 {return false}
    if lhs.canRouteIpExternalV6 != rhs.canRouteIpExternalV6 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_WgProbeResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WgProbeResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "can_register"),
    2: .standard(proto: "can_handshake"),
    3: .standard(proto: "can_resolve_dns"),
    4: .standard(proto: "ping_hosts_performance"),
    5: .standard(proto: "ping_ips_performance"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.canRegister) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.canHandshake) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.canResolveDns) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.pingHostsPerformance) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.pingIpsPerformance) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.canRegister != false {
      try visitor.visitSingularBoolField(value: self.canRegister, fieldNumber: 1)
    }
    if self.canHandshake != false {
      try visitor.visitSingularBoolField(value: self.canHandshake, fieldNumber: 2)
    }
    if self.canResolveDns != false {
      try visitor.visitSingularBoolField(value: self.canResolveDns, fieldNumber: 3)
    }
    if self.pingHostsPerformance != 0 {
      try visitor.visitSingularFloatField(value: self.pingHostsPerformance, fieldNumber: 4)
    }
    if self.pingIpsPerformance != 0 {
      try visitor.visitSingularFloatField(value: self.pingIpsPerformance, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_WgProbeResult, rhs: Nym_Vpn_WgProbeResult) -> Bool {
    if lhs.canRegister != rhs.canRegister {return false}
    if lhs.canHandshake != rhs.canHandshake {return false}
    if lhs.canResolveDns != rhs.canResolveDns {return false}
    if lhs.pingHostsPerformance != rhs.pingHostsPerformance {return false}
    if lhs.pingIpsPerformance != rhs.pingIpsPerformance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ProbeOutcome: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProbeOutcome"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "as_entry"),
    2: .standard(proto: "as_exit"),
    3: .same(proto: "wg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asEntry) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._asExit) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._wg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asEntry {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._asExit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._wg {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ProbeOutcome, rhs: Nym_Vpn_ProbeOutcome) -> Bool {
    if lhs._asEntry != rhs._asEntry {return false}
    if lhs._asExit != rhs._asExit {return false}
    if lhs._wg != rhs._wg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_Probe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Probe"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "last_updated_utc"),
    2: .same(proto: "outcome"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._lastUpdatedUtc) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._outcome) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._lastUpdatedUtc {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._outcome {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_Probe, rhs: Nym_Vpn_Probe) -> Bool {
    if lhs._lastUpdatedUtc != rhs._lastUpdatedUtc {return false}
    if lhs._outcome != rhs._outcome {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GatewayResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GatewayResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "location"),
    3: .standard(proto: "last_probe"),
  ]

  fileprivate class _StorageClass {
    var _id: Nym_Vpn_Gateway? = nil
    var _location: Nym_Vpn_Location? = nil
    var _lastProbe: Nym_Vpn_Probe? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _location = source._location
      _lastProbe = source._lastProbe
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._location) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._lastProbe) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._id {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._location {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._lastProbe {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GatewayResponse, rhs: Nym_Vpn_GatewayResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._location != rhs_storage._location {return false}
        if _storage._lastProbe != rhs_storage._lastProbe {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ListGatewaysRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListGatewaysRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    4: .standard(proto: "user_agent"),
    2: .standard(proto: "min_mixnet_performance"),
    3: .standard(proto: "min_vpn_performance"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._minMixnetPerformance) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._minVpnPerformance) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._userAgent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.kind != .unspecified {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
    }
    try { if let v = self._minMixnetPerformance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._minVpnPerformance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._userAgent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ListGatewaysRequest, rhs: Nym_Vpn_ListGatewaysRequest) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs._userAgent != rhs._userAgent {return false}
    if lhs._minMixnetPerformance != rhs._minMixnetPerformance {return false}
    if lhs._minVpnPerformance != rhs._minVpnPerformance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ListGatewaysResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListGatewaysResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gateways"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.gateways) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gateways.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.gateways, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ListGatewaysResponse, rhs: Nym_Vpn_ListGatewaysResponse) -> Bool {
    if lhs.gateways != rhs.gateways {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ListCountriesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListCountriesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    4: .standard(proto: "user_agent"),
    2: .standard(proto: "min_mixnet_performance"),
    3: .standard(proto: "min_vpn_performance"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._minMixnetPerformance) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._minVpnPerformance) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._userAgent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.kind != .unspecified {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
    }
    try { if let v = self._minMixnetPerformance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._minVpnPerformance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._userAgent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ListCountriesRequest, rhs: Nym_Vpn_ListCountriesRequest) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs._userAgent != rhs._userAgent {return false}
    if lhs._minMixnetPerformance != rhs._minMixnetPerformance {return false}
    if lhs._minVpnPerformance != rhs._minVpnPerformance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ListCountriesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListCountriesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "countries"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.countries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.countries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.countries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ListCountriesResponse, rhs: Nym_Vpn_ListCountriesResponse) -> Bool {
    if lhs.countries != rhs.countries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_StoreAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StoreAccountRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mnemonic"),
    2: .same(proto: "nonce"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mnemonic) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.nonce) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mnemonic.isEmpty {
      try visitor.visitSingularStringField(value: self.mnemonic, fieldNumber: 1)
    }
    if self.nonce != 0 {
      try visitor.visitSingularUInt32Field(value: self.nonce, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_StoreAccountRequest, rhs: Nym_Vpn_StoreAccountRequest) -> Bool {
    if lhs.mnemonic != rhs.mnemonic {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_StoreAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StoreAccountResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_StoreAccountResponse, rhs: Nym_Vpn_StoreAccountResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_IsAccountStoredRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IsAccountStoredRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_IsAccountStoredRequest, rhs: Nym_Vpn_IsAccountStoredRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_IsAccountStoredResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IsAccountStoredResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_stored"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.resp != nil {try decoder.handleConflictingOneOf()}
          self.resp = .isStored(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_AccountError?
        var hadOneofValue = false
        if let current = self.resp {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.resp = .error(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.resp {
    case .isStored?: try {
      guard case .isStored(let v)? = self.resp else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }()
    case .error?: try {
      guard case .error(let v)? = self.resp else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_IsAccountStoredResponse, rhs: Nym_Vpn_IsAccountStoredResponse) -> Bool {
    if lhs.resp != rhs.resp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_RemoveAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoveAccountRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_RemoveAccountRequest, rhs: Nym_Vpn_RemoveAccountRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_RemoveAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoveAccountResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_RemoveAccountResponse, rhs: Nym_Vpn_RemoveAccountResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ForgetAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ForgetAccountRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ForgetAccountRequest, rhs: Nym_Vpn_ForgetAccountRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ForgetAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ForgetAccountResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ForgetAccountResponse, rhs: Nym_Vpn_ForgetAccountResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetAccountIdentityRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAccountIdentityRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetAccountIdentityRequest, rhs: Nym_Vpn_GetAccountIdentityRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetAccountIdentityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAccountIdentityResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_identity"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.id != nil {try decoder.handleConflictingOneOf()}
          self.id = .accountIdentity(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_AccountError?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .error(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.id {
    case .accountIdentity?: try {
      guard case .accountIdentity(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .error?: try {
      guard case .error(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetAccountIdentityResponse, rhs: Nym_Vpn_GetAccountIdentityResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetAccountLinksRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAccountLinksRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "locale"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.locale) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.locale.isEmpty {
      try visitor.visitSingularStringField(value: self.locale, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetAccountLinksRequest, rhs: Nym_Vpn_GetAccountLinksRequest) -> Bool {
    if lhs.locale != rhs.locale {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetAccountLinksResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAccountLinksResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "links"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Nym_Vpn_AccountManagement?
        var hadOneofValue = false
        if let current = self.res {
          hadOneofValue = true
          if case .links(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.res = .links(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_AccountError?
        var hadOneofValue = false
        if let current = self.res {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.res = .error(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.res {
    case .links?: try {
      guard case .links(let v)? = self.res else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .error?: try {
      guard case .error(let v)? = self.res else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetAccountLinksResponse, rhs: Nym_Vpn_GetAccountLinksResponse) -> Bool {
    if lhs.res != rhs.res {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_DeviceSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeviceSummary"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "active"),
    2: .same(proto: "max"),
    3: .same(proto: "remaining"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.active) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.max) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.remaining) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.active != 0 {
      try visitor.visitSingularUInt64Field(value: self.active, fieldNumber: 1)
    }
    if self.max != 0 {
      try visitor.visitSingularUInt64Field(value: self.max, fieldNumber: 2)
    }
    if self.remaining != 0 {
      try visitor.visitSingularUInt64Field(value: self.remaining, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_DeviceSummary, rhs: Nym_Vpn_DeviceSummary) -> Bool {
    if lhs.active != rhs.active {return false}
    if lhs.max != rhs.max {return false}
    if lhs.remaining != rhs.remaining {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_AccountSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountSummary"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "subscription"),
    3: .standard(proto: "device_summary"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.account) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.subscription) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._deviceSummary) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.account != .unspecified {
      try visitor.visitSingularEnumField(value: self.account, fieldNumber: 1)
    }
    if self.subscription != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscription, fieldNumber: 2)
    }
    try { if let v = self._deviceSummary {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_AccountSummary, rhs: Nym_Vpn_AccountSummary) -> Bool {
    if lhs.account != rhs.account {return false}
    if lhs.subscription != rhs.subscription {return false}
    if lhs._deviceSummary != rhs._deviceSummary {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_RegisterDeviceResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegisterDeviceResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .same(proto: "message"),
    3: .standard(proto: "message_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._message) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._messageID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.kind != .registerDeviceResultUnspecified {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
    }
    try { if let v = self._message {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._messageID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_RegisterDeviceResult, rhs: Nym_Vpn_RegisterDeviceResult) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs._message != rhs._message {return false}
    if lhs._messageID != rhs._messageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_RegisterDeviceResult.RegisterDeviceResultType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REGISTER_DEVICE_RESULT_UNSPECIFIED"),
    1: .same(proto: "IN_PROGRESS"),
    2: .same(proto: "SUCCESS"),
    3: .same(proto: "FAILED"),
  ]
}

extension Nym_Vpn_RequestZkNymResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestZkNymResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .same(proto: "successes"),
    3: .same(proto: "failures"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.successes) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.failures) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.kind != .requestZkNymResultUnspecified {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
    }
    if !self.successes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.successes, fieldNumber: 2)
    }
    if !self.failures.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.failures, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_RequestZkNymResult, rhs: Nym_Vpn_RequestZkNymResult) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.successes != rhs.successes {return false}
    if lhs.failures != rhs.failures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_RequestZkNymResult.RequestZkNymResultType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REQUEST_ZK_NYM_RESULT_UNSPECIFIED"),
    1: .same(proto: "IN_PROGRESS"),
    2: .same(proto: "SUCCESS"),
    3: .same(proto: "FAILED"),
  ]
}

extension Nym_Vpn_RequestZkNymSuccess: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestZkNymSuccess"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_RequestZkNymSuccess, rhs: Nym_Vpn_RequestZkNymSuccess) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_RequestZkNymError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestZkNymError"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .same(proto: "id"),
    3: .standard(proto: "ticketbook_type"),
    4: .same(proto: "message"),
    5: .standard(proto: "message_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._id) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._ticketbookType) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._message) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._messageID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.kind != .unspecified {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
    }
    try { if let v = self._id {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._ticketbookType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._message {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._messageID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_RequestZkNymError, rhs: Nym_Vpn_RequestZkNymError) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs._id != rhs._id {return false}
    if lhs._ticketbookType != rhs._ticketbookType {return false}
    if lhs._message != rhs._message {return false}
    if lhs._messageID != rhs._messageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_RequestZkNymError.RequestZkNymErrorType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REQUEST_ZK_NYM_ERROR_TYPE_UNSPECIFIED"),
    1: .same(proto: "INTERNAL"),
    2: .same(proto: "GENERAL"),
    3: .same(proto: "REQUEST_ZK_NYM_ENDPOINT_FAILURE"),
    4: .same(proto: "POLL_ZK_NYM_ENDPOINT_FAILURE"),
    5: .same(proto: "POLLING_TASK_ERROR"),
    6: .same(proto: "POLLING_TIMEOUT"),
    7: .same(proto: "FINISHED_WITH_ERROR"),
    8: .same(proto: "IMPORT"),
  ]
}

extension Nym_Vpn_AccountStateSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountStateSummary"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mnemonic"),
    2: .standard(proto: "account_registered"),
    3: .standard(proto: "account_summary"),
    4: .same(proto: "device"),
    5: .standard(proto: "register_device_result"),
    7: .standard(proto: "request_zk_nym_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._mnemonic) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._accountRegistered) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._accountSummary) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._device) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._registerDeviceResult) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._requestZkNymResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mnemonic {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._accountRegistered {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._accountSummary {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._device {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._registerDeviceResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._requestZkNymResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_AccountStateSummary, rhs: Nym_Vpn_AccountStateSummary) -> Bool {
    if lhs._mnemonic != rhs._mnemonic {return false}
    if lhs._accountRegistered != rhs._accountRegistered {return false}
    if lhs._accountSummary != rhs._accountSummary {return false}
    if lhs._device != rhs._device {return false}
    if lhs._registerDeviceResult != rhs._registerDeviceResult {return false}
    if lhs._requestZkNymResult != rhs._requestZkNymResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetAccountStateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAccountStateRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetAccountStateRequest, rhs: Nym_Vpn_GetAccountStateRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetAccountStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAccountStateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Nym_Vpn_AccountStateSummary?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .account(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .account(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_AccountError?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .error(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .account?: try {
      guard case .account(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .error?: try {
      guard case .error(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetAccountStateResponse, rhs: Nym_Vpn_GetAccountStateResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_RefreshAccountStateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RefreshAccountStateRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_RefreshAccountStateRequest, rhs: Nym_Vpn_RefreshAccountStateRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_RefreshAccountStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RefreshAccountStateResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_RefreshAccountStateResponse, rhs: Nym_Vpn_RefreshAccountStateResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_AccountUsages: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountUsages"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_usages"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.accountUsages) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountUsages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accountUsages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_AccountUsages, rhs: Nym_Vpn_AccountUsages) -> Bool {
    if lhs.accountUsages != rhs.accountUsages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_AccountUsage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountUsage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "created_on_utc"),
    2: .standard(proto: "last_updated_utc"),
    3: .same(proto: "id"),
    4: .standard(proto: "subscription_id"),
    5: .standard(proto: "valid_until_utc"),
    6: .standard(proto: "valid_from_utc"),
    7: .standard(proto: "bandwidth_allowance_gb"),
    8: .standard(proto: "bandwidth_used_gb"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.createdOnUtc) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.lastUpdatedUtc) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.subscriptionID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.validUntilUtc) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.validFromUtc) }()
      case 7: try { try decoder.decodeSingularDoubleField(value: &self.bandwidthAllowanceGb) }()
      case 8: try { try decoder.decodeSingularDoubleField(value: &self.bandwidthUsedGb) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.createdOnUtc.isEmpty {
      try visitor.visitSingularStringField(value: self.createdOnUtc, fieldNumber: 1)
    }
    if !self.lastUpdatedUtc.isEmpty {
      try visitor.visitSingularStringField(value: self.lastUpdatedUtc, fieldNumber: 2)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 3)
    }
    if !self.subscriptionID.isEmpty {
      try visitor.visitSingularStringField(value: self.subscriptionID, fieldNumber: 4)
    }
    if !self.validUntilUtc.isEmpty {
      try visitor.visitSingularStringField(value: self.validUntilUtc, fieldNumber: 5)
    }
    if !self.validFromUtc.isEmpty {
      try visitor.visitSingularStringField(value: self.validFromUtc, fieldNumber: 6)
    }
    if self.bandwidthAllowanceGb != 0 {
      try visitor.visitSingularDoubleField(value: self.bandwidthAllowanceGb, fieldNumber: 7)
    }
    if self.bandwidthUsedGb != 0 {
      try visitor.visitSingularDoubleField(value: self.bandwidthUsedGb, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_AccountUsage, rhs: Nym_Vpn_AccountUsage) -> Bool {
    if lhs.createdOnUtc != rhs.createdOnUtc {return false}
    if lhs.lastUpdatedUtc != rhs.lastUpdatedUtc {return false}
    if lhs.id != rhs.id {return false}
    if lhs.subscriptionID != rhs.subscriptionID {return false}
    if lhs.validUntilUtc != rhs.validUntilUtc {return false}
    if lhs.validFromUtc != rhs.validFromUtc {return false}
    if lhs.bandwidthAllowanceGb != rhs.bandwidthAllowanceGb {return false}
    if lhs.bandwidthUsedGb != rhs.bandwidthUsedGb {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetAccountUsageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAccountUsageRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetAccountUsageRequest, rhs: Nym_Vpn_GetAccountUsageRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetAccountUsageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAccountUsageResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_usages"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Nym_Vpn_AccountUsages?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .accountUsages(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .accountUsages(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_AccountError?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .error(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .accountUsages?: try {
      guard case .accountUsages(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .error?: try {
      guard case .error(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetAccountUsageResponse, rhs: Nym_Vpn_GetAccountUsageResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_FetchRawAccountSummaryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FetchRawAccountSummaryRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_FetchRawAccountSummaryRequest, rhs: Nym_Vpn_FetchRawAccountSummaryRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_FetchRawAccountSummaryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FetchRawAccountSummaryResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "json"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.json) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.json.isEmpty {
      try visitor.visitSingularStringField(value: self.json, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_FetchRawAccountSummaryResponse, rhs: Nym_Vpn_FetchRawAccountSummaryResponse) -> Bool {
    if lhs.json != rhs.json {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_FetchRawDevicesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FetchRawDevicesRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_FetchRawDevicesRequest, rhs: Nym_Vpn_FetchRawDevicesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_FetchRawDevicesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FetchRawDevicesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "json"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.json) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.json.isEmpty {
      try visitor.visitSingularStringField(value: self.json, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_FetchRawDevicesResponse, rhs: Nym_Vpn_FetchRawDevicesResponse) -> Bool {
    if lhs.json != rhs.json {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ResetDeviceIdentityRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResetDeviceIdentityRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "seed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._seed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._seed {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ResetDeviceIdentityRequest, rhs: Nym_Vpn_ResetDeviceIdentityRequest) -> Bool {
    if lhs._seed != rhs._seed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ResetDeviceIdentityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResetDeviceIdentityResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ResetDeviceIdentityResponse, rhs: Nym_Vpn_ResetDeviceIdentityResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetDeviceIdentityRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetDeviceIdentityRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetDeviceIdentityRequest, rhs: Nym_Vpn_GetDeviceIdentityRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetDeviceIdentityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetDeviceIdentityResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_identity"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.id != nil {try decoder.handleConflictingOneOf()}
          self.id = .deviceIdentity(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_AccountError?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .error(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.id {
    case .deviceIdentity?: try {
      guard case .deviceIdentity(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .error?: try {
      guard case .error(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetDeviceIdentityResponse, rhs: Nym_Vpn_GetDeviceIdentityResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_RegisterDeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegisterDeviceRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_RegisterDeviceRequest, rhs: Nym_Vpn_RegisterDeviceRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_RegisterDeviceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegisterDeviceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "json"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.json) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.json.isEmpty {
      try visitor.visitSingularStringField(value: self.json, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_RegisterDeviceResponse, rhs: Nym_Vpn_RegisterDeviceResponse) -> Bool {
    if lhs.json != rhs.json {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_Device: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Device"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "created_on_utc"),
    2: .standard(proto: "last_updated_utc"),
    3: .standard(proto: "device_identity_key"),
    4: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.createdOnUtc) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.lastUpdatedUtc) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.deviceIdentityKey) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.createdOnUtc.isEmpty {
      try visitor.visitSingularStringField(value: self.createdOnUtc, fieldNumber: 1)
    }
    if !self.lastUpdatedUtc.isEmpty {
      try visitor.visitSingularStringField(value: self.lastUpdatedUtc, fieldNumber: 2)
    }
    if !self.deviceIdentityKey.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceIdentityKey, fieldNumber: 3)
    }
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_Device, rhs: Nym_Vpn_Device) -> Bool {
    if lhs.createdOnUtc != rhs.createdOnUtc {return false}
    if lhs.lastUpdatedUtc != rhs.lastUpdatedUtc {return false}
    if lhs.deviceIdentityKey != rhs.deviceIdentityKey {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_Devices: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Devices"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "devices"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.devices) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.devices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.devices, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_Devices, rhs: Nym_Vpn_Devices) -> Bool {
    if lhs.devices != rhs.devices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetDevicesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetDevicesRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetDevicesRequest, rhs: Nym_Vpn_GetDevicesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetDevicesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetDevicesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "devices"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Nym_Vpn_Devices?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .devices(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .devices(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_AccountError?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .error(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .devices?: try {
      guard case .devices(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .error?: try {
      guard case .error(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetDevicesResponse, rhs: Nym_Vpn_GetDevicesResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetActiveDevicesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetActiveDevicesRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetActiveDevicesRequest, rhs: Nym_Vpn_GetActiveDevicesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetActiveDevicesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetActiveDevicesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "devices"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Nym_Vpn_Devices?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .devices(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .devices(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_AccountError?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .error(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .devices?: try {
      guard case .devices(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .error?: try {
      guard case .error(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetActiveDevicesResponse, rhs: Nym_Vpn_GetActiveDevicesResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_RequestZkNymRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestZkNymRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_RequestZkNymRequest, rhs: Nym_Vpn_RequestZkNymRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_RequestZkNymResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestZkNymResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "json"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.json) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.json.isEmpty {
      try visitor.visitSingularStringField(value: self.json, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_RequestZkNymResponse, rhs: Nym_Vpn_RequestZkNymResponse) -> Bool {
    if lhs.json != rhs.json {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetDeviceZkNymsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetDeviceZkNymsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetDeviceZkNymsRequest, rhs: Nym_Vpn_GetDeviceZkNymsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetDeviceZkNymsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetDeviceZkNymsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "json"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.json) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.json.isEmpty {
      try visitor.visitSingularStringField(value: self.json, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetDeviceZkNymsResponse, rhs: Nym_Vpn_GetDeviceZkNymsResponse) -> Bool {
    if lhs.json != rhs.json {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetZkNymsAvailableForDownloadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetZkNymsAvailableForDownloadRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetZkNymsAvailableForDownloadRequest, rhs: Nym_Vpn_GetZkNymsAvailableForDownloadRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetZkNymsAvailableForDownloadResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetZkNymsAvailableForDownloadResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "json"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.json) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.json.isEmpty {
      try visitor.visitSingularStringField(value: self.json, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetZkNymsAvailableForDownloadResponse, rhs: Nym_Vpn_GetZkNymsAvailableForDownloadResponse) -> Bool {
    if lhs.json != rhs.json {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetZkNymByIdRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetZkNymByIdRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetZkNymByIdRequest, rhs: Nym_Vpn_GetZkNymByIdRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetZkNymByIdResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetZkNymByIdResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "json"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.json) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.json.isEmpty {
      try visitor.visitSingularStringField(value: self.json, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetZkNymByIdResponse, rhs: Nym_Vpn_GetZkNymByIdResponse) -> Bool {
    if lhs.json != rhs.json {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ConfirmZkNymDownloadedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConfirmZkNymDownloadedRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ConfirmZkNymDownloadedRequest, rhs: Nym_Vpn_ConfirmZkNymDownloadedRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ConfirmZkNymDownloadedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConfirmZkNymDownloadedResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ConfirmZkNymDownloadedResponse, rhs: Nym_Vpn_ConfirmZkNymDownloadedResponse) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_AvailableTickets: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AvailableTickets"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "mixnet_entry_tickets"),
    2: .standard(proto: "mixnet_entry_data"),
    3: .standard(proto: "mixnet_entry_data_si"),
    4: .standard(proto: "mixnet_exit_tickets"),
    5: .standard(proto: "mixnet_exit_data"),
    6: .standard(proto: "mixnet_exit_data_si"),
    7: .standard(proto: "vpn_entry_tickets"),
    8: .standard(proto: "vpn_entry_data"),
    9: .standard(proto: "vpn_entry_data_si"),
    10: .standard(proto: "vpn_exit_tickets"),
    11: .standard(proto: "vpn_exit_data"),
    12: .standard(proto: "vpn_exit_data_si"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.mixnetEntryTickets) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.mixnetEntryData) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.mixnetEntryDataSi) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.mixnetExitTickets) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.mixnetExitData) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.mixnetExitDataSi) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.vpnEntryTickets) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.vpnEntryData) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.vpnEntryDataSi) }()
      case 10: try { try decoder.decodeSingularUInt64Field(value: &self.vpnExitTickets) }()
      case 11: try { try decoder.decodeSingularUInt64Field(value: &self.vpnExitData) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.vpnExitDataSi) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mixnetEntryTickets != 0 {
      try visitor.visitSingularUInt64Field(value: self.mixnetEntryTickets, fieldNumber: 1)
    }
    if self.mixnetEntryData != 0 {
      try visitor.visitSingularUInt64Field(value: self.mixnetEntryData, fieldNumber: 2)
    }
    if !self.mixnetEntryDataSi.isEmpty {
      try visitor.visitSingularStringField(value: self.mixnetEntryDataSi, fieldNumber: 3)
    }
    if self.mixnetExitTickets != 0 {
      try visitor.visitSingularUInt64Field(value: self.mixnetExitTickets, fieldNumber: 4)
    }
    if self.mixnetExitData != 0 {
      try visitor.visitSingularUInt64Field(value: self.mixnetExitData, fieldNumber: 5)
    }
    if !self.mixnetExitDataSi.isEmpty {
      try visitor.visitSingularStringField(value: self.mixnetExitDataSi, fieldNumber: 6)
    }
    if self.vpnEntryTickets != 0 {
      try visitor.visitSingularUInt64Field(value: self.vpnEntryTickets, fieldNumber: 7)
    }
    if self.vpnEntryData != 0 {
      try visitor.visitSingularUInt64Field(value: self.vpnEntryData, fieldNumber: 8)
    }
    if !self.vpnEntryDataSi.isEmpty {
      try visitor.visitSingularStringField(value: self.vpnEntryDataSi, fieldNumber: 9)
    }
    if self.vpnExitTickets != 0 {
      try visitor.visitSingularUInt64Field(value: self.vpnExitTickets, fieldNumber: 10)
    }
    if self.vpnExitData != 0 {
      try visitor.visitSingularUInt64Field(value: self.vpnExitData, fieldNumber: 11)
    }
    if !self.vpnExitDataSi.isEmpty {
      try visitor.visitSingularStringField(value: self.vpnExitDataSi, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_AvailableTickets, rhs: Nym_Vpn_AvailableTickets) -> Bool {
    if lhs.mixnetEntryTickets != rhs.mixnetEntryTickets {return false}
    if lhs.mixnetEntryData != rhs.mixnetEntryData {return false}
    if lhs.mixnetEntryDataSi != rhs.mixnetEntryDataSi {return false}
    if lhs.mixnetExitTickets != rhs.mixnetExitTickets {return false}
    if lhs.mixnetExitData != rhs.mixnetExitData {return false}
    if lhs.mixnetExitDataSi != rhs.mixnetExitDataSi {return false}
    if lhs.vpnEntryTickets != rhs.vpnEntryTickets {return false}
    if lhs.vpnEntryData != rhs.vpnEntryData {return false}
    if lhs.vpnEntryDataSi != rhs.vpnEntryDataSi {return false}
    if lhs.vpnExitTickets != rhs.vpnExitTickets {return false}
    if lhs.vpnExitData != rhs.vpnExitData {return false}
    if lhs.vpnExitDataSi != rhs.vpnExitDataSi {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetAvailableTicketsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAvailableTicketsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetAvailableTicketsRequest, rhs: Nym_Vpn_GetAvailableTicketsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetAvailableTicketsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAvailableTicketsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "available_tickets"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Nym_Vpn_AvailableTickets?
        var hadOneofValue = false
        if let current = self.resp {
          hadOneofValue = true
          if case .availableTickets(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.resp = .availableTickets(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_AccountError?
        var hadOneofValue = false
        if let current = self.resp {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.resp = .error(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.resp {
    case .availableTickets?: try {
      guard case .availableTickets(let v)? = self.resp else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .error?: try {
      guard case .error(let v)? = self.resp else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetAvailableTicketsResponse, rhs: Nym_Vpn_GetAvailableTicketsResponse) -> Bool {
    if lhs.resp != rhs.resp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_IsReadyToConnectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IsReadyToConnectRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_IsReadyToConnectRequest, rhs: Nym_Vpn_IsReadyToConnectRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_IsReadyToConnectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IsReadyToConnectResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.kind != .unspecified {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_IsReadyToConnectResponse, rhs: Nym_Vpn_IsReadyToConnectResponse) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_IsReadyToConnectResponse.IsReadyToConnectResponseType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IS_READY_TO_CONNECT_RESPONSE_TYPE_UNSPECIFIED"),
    1: .same(proto: "READY"),
    2: .same(proto: "NO_ACCOUNT_STORED"),
    3: .same(proto: "ACCOUNT_NOT_SYNCED"),
    4: .same(proto: "ACCOUNT_NOT_REGISTERED"),
    5: .same(proto: "ACCOUNT_NOT_ACTIVE"),
    6: .same(proto: "NO_ACTIVE_SUBSCRIPTION"),
    7: .same(proto: "DEVICE_NOT_REGISTERED"),
    8: .same(proto: "DEVICE_NOT_ACTIVE"),
    9: .same(proto: "MAX_DEVICES_REACHED"),
  ]
}

extension Nym_Vpn_AccountError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountError"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .same(proto: "message"),
    3: .same(proto: "details"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.details) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.kind != .storeAccountErrorUnspecified {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.details.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.details, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_AccountError, rhs: Nym_Vpn_AccountError) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.message != rhs.message {return false}
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_AccountError.AccountErrorType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STORE_ACCOUNT_ERROR_UNSPECIFIED"),
    1: .same(proto: "INVALID_MNEMONIC"),
    2: .same(proto: "STORAGE"),
    3: .same(proto: "IS_CONNECTED"),
  ]
}
