// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: vpn.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// swiftlint:disable all

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Nym_Vpn_ConnectionStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case statusUnspecified // = 0
  case unknown // = 1
  case notConnected // = 2
  case connecting // = 3
  case connected // = 4
  case disconnecting // = 5
  case connectionFailed // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .statusUnspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .statusUnspecified
    case 1: self = .unknown
    case 2: self = .notConnected
    case 3: self = .connecting
    case 4: self = .connected
    case 5: self = .disconnecting
    case 6: self = .connectionFailed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .statusUnspecified: return 0
    case .unknown: return 1
    case .notConnected: return 2
    case .connecting: return 3
    case .connected: return 4
    case .disconnecting: return 5
    case .connectionFailed: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Nym_Vpn_ConnectionStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Nym_Vpn_ConnectionStatus] = [
    .statusUnspecified,
    .unknown,
    .notConnected,
    .connecting,
    .connected,
    .disconnecting,
    .connectionFailed,
  ]
}

#endif  // swift(>=4.2)

struct Nym_Vpn_Empty {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Represents the identity of a gateway
struct Nym_Vpn_Gateway {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Represents a nym-address of the form id.enc@gateway
struct Nym_Vpn_Address {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nymAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_Location {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var twoLetterIsoCountryCode: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_EntryNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entryNodeEnum: Nym_Vpn_EntryNode.OneOf_EntryNodeEnum? = nil

  var gateway: Nym_Vpn_Gateway {
    get {
      if case .gateway(let v)? = entryNodeEnum {return v}
      return Nym_Vpn_Gateway()
    }
    set {entryNodeEnum = .gateway(newValue)}
  }

  var location: Nym_Vpn_Location {
    get {
      if case .location(let v)? = entryNodeEnum {return v}
      return Nym_Vpn_Location()
    }
    set {entryNodeEnum = .location(newValue)}
  }

  var randomLowLatency: Nym_Vpn_Empty {
    get {
      if case .randomLowLatency(let v)? = entryNodeEnum {return v}
      return Nym_Vpn_Empty()
    }
    set {entryNodeEnum = .randomLowLatency(newValue)}
  }

  var random: Nym_Vpn_Empty {
    get {
      if case .random(let v)? = entryNodeEnum {return v}
      return Nym_Vpn_Empty()
    }
    set {entryNodeEnum = .random(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_EntryNodeEnum: Equatable {
    case gateway(Nym_Vpn_Gateway)
    case location(Nym_Vpn_Location)
    case randomLowLatency(Nym_Vpn_Empty)
    case random(Nym_Vpn_Empty)

  #if !swift(>=4.1)
    static func ==(lhs: Nym_Vpn_EntryNode.OneOf_EntryNodeEnum, rhs: Nym_Vpn_EntryNode.OneOf_EntryNodeEnum) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.gateway, .gateway): return {
        guard case .gateway(let l) = lhs, case .gateway(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.location, .location): return {
        guard case .location(let l) = lhs, case .location(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.randomLowLatency, .randomLowLatency): return {
        guard case .randomLowLatency(let l) = lhs, case .randomLowLatency(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.random, .random): return {
        guard case .random(let l) = lhs, case .random(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Nym_Vpn_ExitNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var exitNodeEnum: Nym_Vpn_ExitNode.OneOf_ExitNodeEnum? = nil

  var address: Nym_Vpn_Address {
    get {
      if case .address(let v)? = exitNodeEnum {return v}
      return Nym_Vpn_Address()
    }
    set {exitNodeEnum = .address(newValue)}
  }

  var gateway: Nym_Vpn_Gateway {
    get {
      if case .gateway(let v)? = exitNodeEnum {return v}
      return Nym_Vpn_Gateway()
    }
    set {exitNodeEnum = .gateway(newValue)}
  }

  var location: Nym_Vpn_Location {
    get {
      if case .location(let v)? = exitNodeEnum {return v}
      return Nym_Vpn_Location()
    }
    set {exitNodeEnum = .location(newValue)}
  }

  var random: Nym_Vpn_Empty {
    get {
      if case .random(let v)? = exitNodeEnum {return v}
      return Nym_Vpn_Empty()
    }
    set {exitNodeEnum = .random(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ExitNodeEnum: Equatable {
    case address(Nym_Vpn_Address)
    case gateway(Nym_Vpn_Gateway)
    case location(Nym_Vpn_Location)
    case random(Nym_Vpn_Empty)

  #if !swift(>=4.1)
    static func ==(lhs: Nym_Vpn_ExitNode.OneOf_ExitNodeEnum, rhs: Nym_Vpn_ExitNode.OneOf_ExitNodeEnum) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.address, .address): return {
        guard case .address(let l) = lhs, case .address(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.gateway, .gateway): return {
        guard case .gateway(let l) = lhs, case .gateway(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.location, .location): return {
        guard case .location(let l) = lhs, case .location(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.random, .random): return {
        guard case .random(let l) = lhs, case .random(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Nym_Vpn_Dns {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ip: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_ConnectRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entry: Nym_Vpn_EntryNode {
    get {return _entry ?? Nym_Vpn_EntryNode()}
    set {_entry = newValue}
  }
  /// Returns true if `entry` has been explicitly set.
  var hasEntry: Bool {return self._entry != nil}
  /// Clears the value of `entry`. Subsequent reads from it will return its default value.
  mutating func clearEntry() {self._entry = nil}

  var exit: Nym_Vpn_ExitNode {
    get {return _exit ?? Nym_Vpn_ExitNode()}
    set {_exit = newValue}
  }
  /// Returns true if `exit` has been explicitly set.
  var hasExit: Bool {return self._exit != nil}
  /// Clears the value of `exit`. Subsequent reads from it will return its default value.
  mutating func clearExit() {self._exit = nil}

  var dns: Nym_Vpn_Dns {
    get {return _dns ?? Nym_Vpn_Dns()}
    set {_dns = newValue}
  }
  /// Returns true if `dns` has been explicitly set.
  var hasDns: Bool {return self._dns != nil}
  /// Clears the value of `dns`. Subsequent reads from it will return its default value.
  mutating func clearDns() {self._dns = nil}

  var disableRouting: Bool = false

  var enableTwoHop: Bool = false

  var enablePoissonRate: Bool = false

  var disableBackgroundCoverTraffic: Bool = false

  var enableCredentialsMode: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _entry: Nym_Vpn_EntryNode? = nil
  fileprivate var _exit: Nym_Vpn_ExitNode? = nil
  fileprivate var _dns: Nym_Vpn_Dns? = nil
}

struct Nym_Vpn_ConnectResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var success: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_DisconnectRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_DisconnectResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var success: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_StatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_StatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Nym_Vpn_ConnectionStatus = .statusUnspecified

  var error: Nym_Vpn_Error {
    get {return _error ?? Nym_Vpn_Error()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Nym_Vpn_Error? = nil
}

struct Nym_Vpn_ConnectionStateChange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Nym_Vpn_ConnectionStatus = .statusUnspecified

  var error: Nym_Vpn_Error {
    get {return _error ?? Nym_Vpn_Error()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Nym_Vpn_Error? = nil
}

struct Nym_Vpn_ConnectionStatusUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_Error {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_ImportUserCredentialRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var credential: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_ImportUserCredentialResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var success: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Nym_Vpn_ConnectionStatus: @unchecked Sendable {}
extension Nym_Vpn_Empty: @unchecked Sendable {}
extension Nym_Vpn_Gateway: @unchecked Sendable {}
extension Nym_Vpn_Address: @unchecked Sendable {}
extension Nym_Vpn_Location: @unchecked Sendable {}
extension Nym_Vpn_EntryNode: @unchecked Sendable {}
extension Nym_Vpn_EntryNode.OneOf_EntryNodeEnum: @unchecked Sendable {}
extension Nym_Vpn_ExitNode: @unchecked Sendable {}
extension Nym_Vpn_ExitNode.OneOf_ExitNodeEnum: @unchecked Sendable {}
extension Nym_Vpn_Dns: @unchecked Sendable {}
extension Nym_Vpn_ConnectRequest: @unchecked Sendable {}
extension Nym_Vpn_ConnectResponse: @unchecked Sendable {}
extension Nym_Vpn_DisconnectRequest: @unchecked Sendable {}
extension Nym_Vpn_DisconnectResponse: @unchecked Sendable {}
extension Nym_Vpn_StatusRequest: @unchecked Sendable {}
extension Nym_Vpn_StatusResponse: @unchecked Sendable {}
extension Nym_Vpn_ConnectionStateChange: @unchecked Sendable {}
extension Nym_Vpn_ConnectionStatusUpdate: @unchecked Sendable {}
extension Nym_Vpn_Error: @unchecked Sendable {}
extension Nym_Vpn_ImportUserCredentialRequest: @unchecked Sendable {}
extension Nym_Vpn_ImportUserCredentialResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "nym.vpn"

extension Nym_Vpn_ConnectionStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNSPECIFIED"),
    1: .same(proto: "UNKNOWN"),
    2: .same(proto: "NOT_CONNECTED"),
    3: .same(proto: "CONNECTING"),
    4: .same(proto: "CONNECTED"),
    5: .same(proto: "DISCONNECTING"),
    6: .same(proto: "CONNECTION_FAILED"),
  ]
}

extension Nym_Vpn_Empty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Empty"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_Empty, rhs: Nym_Vpn_Empty) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_Gateway: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Gateway"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_Gateway, rhs: Nym_Vpn_Gateway) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_Address: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Address"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "nym_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.nymAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nymAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.nymAddress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_Address, rhs: Nym_Vpn_Address) -> Bool {
    if lhs.nymAddress != rhs.nymAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_Location: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Location"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "two_letter_iso_country_code"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.twoLetterIsoCountryCode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.twoLetterIsoCountryCode.isEmpty {
      try visitor.visitSingularStringField(value: self.twoLetterIsoCountryCode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_Location, rhs: Nym_Vpn_Location) -> Bool {
    if lhs.twoLetterIsoCountryCode != rhs.twoLetterIsoCountryCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_EntryNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EntryNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gateway"),
    2: .same(proto: "location"),
    3: .standard(proto: "random_low_latency"),
    4: .same(proto: "random"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Nym_Vpn_Gateway?
        var hadOneofValue = false
        if let current = self.entryNodeEnum {
          hadOneofValue = true
          if case .gateway(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.entryNodeEnum = .gateway(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_Location?
        var hadOneofValue = false
        if let current = self.entryNodeEnum {
          hadOneofValue = true
          if case .location(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.entryNodeEnum = .location(v)
        }
      }()
      case 3: try {
        var v: Nym_Vpn_Empty?
        var hadOneofValue = false
        if let current = self.entryNodeEnum {
          hadOneofValue = true
          if case .randomLowLatency(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.entryNodeEnum = .randomLowLatency(v)
        }
      }()
      case 4: try {
        var v: Nym_Vpn_Empty?
        var hadOneofValue = false
        if let current = self.entryNodeEnum {
          hadOneofValue = true
          if case .random(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.entryNodeEnum = .random(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.entryNodeEnum {
    case .gateway?: try {
      guard case .gateway(let v)? = self.entryNodeEnum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .location?: try {
      guard case .location(let v)? = self.entryNodeEnum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .randomLowLatency?: try {
      guard case .randomLowLatency(let v)? = self.entryNodeEnum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .random?: try {
      guard case .random(let v)? = self.entryNodeEnum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_EntryNode, rhs: Nym_Vpn_EntryNode) -> Bool {
    if lhs.entryNodeEnum != rhs.entryNodeEnum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ExitNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExitNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "gateway"),
    3: .same(proto: "location"),
    4: .same(proto: "random"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Nym_Vpn_Address?
        var hadOneofValue = false
        if let current = self.exitNodeEnum {
          hadOneofValue = true
          if case .address(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.exitNodeEnum = .address(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_Gateway?
        var hadOneofValue = false
        if let current = self.exitNodeEnum {
          hadOneofValue = true
          if case .gateway(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.exitNodeEnum = .gateway(v)
        }
      }()
      case 3: try {
        var v: Nym_Vpn_Location?
        var hadOneofValue = false
        if let current = self.exitNodeEnum {
          hadOneofValue = true
          if case .location(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.exitNodeEnum = .location(v)
        }
      }()
      case 4: try {
        var v: Nym_Vpn_Empty?
        var hadOneofValue = false
        if let current = self.exitNodeEnum {
          hadOneofValue = true
          if case .random(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.exitNodeEnum = .random(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.exitNodeEnum {
    case .address?: try {
      guard case .address(let v)? = self.exitNodeEnum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .gateway?: try {
      guard case .gateway(let v)? = self.exitNodeEnum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .location?: try {
      guard case .location(let v)? = self.exitNodeEnum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .random?: try {
      guard case .random(let v)? = self.exitNodeEnum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ExitNode, rhs: Nym_Vpn_ExitNode) -> Bool {
    if lhs.exitNodeEnum != rhs.exitNodeEnum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_Dns: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Dns"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ip"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ip) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ip.isEmpty {
      try visitor.visitSingularStringField(value: self.ip, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_Dns, rhs: Nym_Vpn_Dns) -> Bool {
    if lhs.ip != rhs.ip {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ConnectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entry"),
    2: .same(proto: "exit"),
    3: .same(proto: "dns"),
    4: .standard(proto: "disable_routing"),
    5: .standard(proto: "enable_two_hop"),
    6: .standard(proto: "enable_poisson_rate"),
    7: .standard(proto: "disable_background_cover_traffic"),
    8: .standard(proto: "enable_credentials_mode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._entry) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._exit) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._dns) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.disableRouting) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.enableTwoHop) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.enablePoissonRate) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.disableBackgroundCoverTraffic) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.enableCredentialsMode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._entry {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._exit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._dns {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.disableRouting != false {
      try visitor.visitSingularBoolField(value: self.disableRouting, fieldNumber: 4)
    }
    if self.enableTwoHop != false {
      try visitor.visitSingularBoolField(value: self.enableTwoHop, fieldNumber: 5)
    }
    if self.enablePoissonRate != false {
      try visitor.visitSingularBoolField(value: self.enablePoissonRate, fieldNumber: 6)
    }
    if self.disableBackgroundCoverTraffic != false {
      try visitor.visitSingularBoolField(value: self.disableBackgroundCoverTraffic, fieldNumber: 7)
    }
    if self.enableCredentialsMode != false {
      try visitor.visitSingularBoolField(value: self.enableCredentialsMode, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ConnectRequest, rhs: Nym_Vpn_ConnectRequest) -> Bool {
    if lhs._entry != rhs._entry {return false}
    if lhs._exit != rhs._exit {return false}
    if lhs._dns != rhs._dns {return false}
    if lhs.disableRouting != rhs.disableRouting {return false}
    if lhs.enableTwoHop != rhs.enableTwoHop {return false}
    if lhs.enablePoissonRate != rhs.enablePoissonRate {return false}
    if lhs.disableBackgroundCoverTraffic != rhs.disableBackgroundCoverTraffic {return false}
    if lhs.enableCredentialsMode != rhs.enableCredentialsMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ConnectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ConnectResponse, rhs: Nym_Vpn_ConnectResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_DisconnectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisconnectRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_DisconnectRequest, rhs: Nym_Vpn_DisconnectRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_DisconnectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisconnectResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_DisconnectResponse, rhs: Nym_Vpn_DisconnectResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_StatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StatusRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_StatusRequest, rhs: Nym_Vpn_StatusRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_StatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StatusResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.status != .statusUnspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_StatusResponse, rhs: Nym_Vpn_StatusResponse) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ConnectionStateChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectionStateChange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.status != .statusUnspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ConnectionStateChange, rhs: Nym_Vpn_ConnectionStateChange) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ConnectionStatusUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectionStatusUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ConnectionStatusUpdate, rhs: Nym_Vpn_ConnectionStatusUpdate) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Error"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_Error, rhs: Nym_Vpn_Error) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ImportUserCredentialRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImportUserCredentialRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "credential"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.credential) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.credential.isEmpty {
      try visitor.visitSingularBytesField(value: self.credential, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ImportUserCredentialRequest, rhs: Nym_Vpn_ImportUserCredentialRequest) -> Bool {
    if lhs.credential != rhs.credential {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ImportUserCredentialResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImportUserCredentialResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ImportUserCredentialResponse, rhs: Nym_Vpn_ImportUserCredentialResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
// swiftlint:enable all
